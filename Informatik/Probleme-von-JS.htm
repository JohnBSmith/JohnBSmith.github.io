<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Probleme von JavaScript</title>
  <style>
body{
  margin-top: 2em;
  margin-left: 10%;
  margin-bottom: 10em;
  max-width: 40em;
  font-family: "DejaVu Sans", "Verdana", sans-serif;
  color: #404030;
}
@media(max-width: 46em){
  body{margin-left: 6%; margin-left: 4%;}
}
@media(max-width: 26em){
  body{margin-left: 2%; margin-right: 1%;}
  ol, ul{padding-left: 2em;}
}
h1,h2,h3,h4{color: #463c20;}
a{color: #20506a; text-decoration: none;}
a:hover{color: #102a40; text-decoration: underline;}
pre, code{
  font-family: "FreeMono", "Courier New", monospace;
  color: #403020;
}
table.bt{border-collapse: collapse;}
table.bt td, table.bt th{
  border: 1px solid #b0b0a0;
  padding-left: 0.2em;
  text-align: left;
  vertical-align: top;
}
table.bt th{
  background-color: #e0e0c0;
}

.keyword{color: #204080; font-weight: bold;}
.string{color: #a00060;}
.comment{color: #604000;}
.symbol{color: #202020; font-weight: bold;}
.bracket{color: #006060; font-weight: bold;}
.number{color: #204040;}
  </style>
  <script>
function isalpha(s){
  return /^[a-z]+$/i.test(s);
}

function isdigit(s){
  return /^\d+$/.test(s);
}

var keyword = {
  "break": 0,
  "case": 0, "catch": 0, "class": 0, "const": 0, "continue": 0,
  "debugger": 0, "default": 0, "delete": 0, "do": 0,
  "else": 0, "export": 0, "extends": 0,
  "finally": 0, "for": 0, "function": 0,
  "if": 0, "import": 0, "in": 0, "instanceof": 0,
  "new": 0, "return": 0, "super": 0, "switch": 0,
  "this": 0, "throw": 0, "try": 0, "typeof": 0,
  "var": 0, "void": 0,
  "while": 0, "with": 0,
  "yield": 0,
};

function js_syntax(s){
  var id,s2,st,c;
  s2="";
  var i=0;
  while(i<s.length){
    c=s[i];
    if(isalpha(c) || s[i]=='_'){
      id="";
      while(i<s.length && (isalpha(s[i]) || isdigit(s[i]) || s[i]=='_')){
        id+=s[i];
        i++;
      }
      if(keyword.hasOwnProperty(id)){
        s2+="<span class='keyword'>"+id+"</span>";
      }else{
        s2+=id;
      }
    }else if(isdigit(c)){
      st="";
      while(i<s.length && isdigit(s[i])){
        st+=s[i];
        i++;
      }
      s2+="<span class='number'>"+st+"</span>";
    }else if(c=='"'){
      st="<span class='string'>\"";
      i++;
      while(i<s.length && s[i]!='"'){
        st+=s[i];
        i++;
      }
      i++;
      st+="\"</span>";
      s2+=st;
    }else if(c=="'"){
      st="<span class='string'>'";
      i++;
      while(i<s.length && s[i]!="'"){
        st+=s[i];
        i++;
      }
      i++;
      st+="'</span>";
      s2+=st;
    }else if(c=='#'){
      st="<span class='preprocessor'>";
      while(i<s.length && s[i]!='\n'){
        st+=s[i];
        i++;
      }
      st+="</span>";
      s2+=st;
    }else if(c=='/' && i+1<s.length && s[i+1]=='/'){
      st="<span class='comment'>";
      while(i<s.length && s[i]!='\n'){
        st+=s[i];
        i++;
      }
      st+="</span>";
      s2+=st;
    }else if(c=='/' && i+1<s.length && s[i+1]=='*'){
      st="<span class='comment'>/*";
      i+=2;
      while(i+1<s.length && s[i]!='*' && s[i+1]!='/'){
        st+=s[i];
        i++;
      }
      i+=2;
      st+="*/</span>";
      s2+=st;
    }else if(c=='<'){
      st="";
      while(i<s.length && s[i]!='>'){
        st+=s[i];
        i++;
      }
      i++; st+=">";
      s2+=st;
    }else if(c=='&'){
      st="";
      while(i<s.length && s[i]!=';'){
        st+=s[i];
        i++;
      }
      s2+="<span class='symbol'>"+st+";</span>";
      i++;
    }else if(c=='(' || c==')' || c=='[' || c==']' || c=='{' || c=='}'){
      s2+="<span class='bracket'>"+c+"</span>";
      i++;
    }else if(c=='+' || c=='-' || c=='*' || c=='/' || c=='|' ||
      c=='.' || c=='=' || c=='!' || c==':' || c=='%' || c=='^' ||
      c=='~'
    ){
      s2+="<span class='symbol'>"+c+"</span>";
      i++;
    }else{
      s2+=c;
      i++;
    }
  }
  return s2;
}

function main(){
  var a = document.getElementsByClassName("js");
  for(var i=0; i<a.length; i++){
    a[i].innerHTML = js_syntax(a[i].innerHTML);
  }
}

window.onload = main;
  </script>
</head>
<body>

<br>
<h1>Probleme von JavaScript</h1>
<h2 id="toc">Inhaltsverzeichnis</h2>
<ol class="toc">
<li><a href="#Umwandlung">Umwandlung von Arrays in Zeichenketten</a>
<li><a href="#Typisierung">Schwache Typisierung</a>
<li><a href="#Variablen">Globale Variablen</a>
<li><a href="#Operatoren">Operatorüberladung</a>
<li><a href="#this">Das this-Argument</a>
<li><a href="#Woerterbuch">Wörterbuch-Syntax</a>
</ol>

<h2 id="Umwandlung">Umwandlung von Arrays in Zeichenketten</h2>
<p>Normalerweise sollte die Umwandlung eines Arrays in eine
Zeichenkette auch genau so ausschauen wie das Literal.
Aber in JavaScript fehlen die eckigen Klammern:
<pre class="js">
&gt; String([1,2])
"1,2"
</pre>
<p>Man kann sich denken: »Gut, die kann ich ja noch hinzufügen«.
Aber bei verschachtelten Arrays wird es schlimmer:
<pre class="js">
&gt; String([[1,2],[3,4]])
&gt; "1,2,3,4"
</pre>

<h2 id="Typisierung">Schwache Typisierung</h2>
<pre class="js">
&gt; [1,2]+3
"1,23"
</pre>
<p>Was passiert hier? Nun, das Array wird vor der Addition implizit
in eine Zeichenkette umgewandelt. Wie wir schon gesehen haben, wird
bei der Umwandlung eines Arrays in eine Zeichenkette die Klammerung
ausgelassen.

<p>Man wird es kaum glauben: JavaScript ist typsicher. Ist ein
JavaScript-Interpreter korrekt implementiert, so kann kein
JavaScript-Programm die Speichersicherheit gefärden.
Nur weil JavaScript typsicher ist, heißt das aber nicht, dass es
auch streng typisiert ist.

<h2 id="Variablen">Globale Variablen</h2>
<p>In JavaScript ist es vorgesehen, dass eine undeklarierte Variable
auf der linken Seite einer Zuweisenung automatisch global ist.
In der Funktion
<pre class="js">
function f(x){
  y=2*x;
  return y;
}
</pre>
<p>wird z.&nbsp;B. unintuitiverweise die globale Variable
<code>y</code> geändert, was man höchstwahrscheinlich nicht wollte.
Ein solches Verhalten führt in einer Vielzahl von Fällen zu seltsamen
Bugs. Ein explizite deklaration von globalen Variablen wäre sinnvoll:
<pre class="js">
function f(x){
  <span class='keyword'>global</span> y=2*x;
  return y;
}
</pre>

<h2 id="Operatoren">Operatorüberladung</h2>
<p>In JavaScript ist Operatorüberladung leider nicht möglich, obwohl
es trivial zu implementieren wäre. Es kommt stattdessen folgends
Verhalten zustande:
<pre class="js">
&gt; x = {}; y = {}
&gt; x+y
"[object Object][object Object]"
</pre>
<p>Der Interpreter überprüft ja schon zur Laufzeit, welchen Datentyp
die Variablen <code>x,y</code> besitzen. Falls der Datentyp kein
einfacher ist, werden die Objekte in diesem Residualfall einfach
implizit in Zeichenketten umgewandelt. Genau in diesem Residualfall
wäre es aber möglich gewesen, eine zugehörige Methode <code>add</code>
im Objekt <code>x</code> oder in dessen Prototypenkette aufzurufen:
<pre class="js">
  x+y == x.add(y)
</pre>

<h2 id="this">Das this-Argument</h2>
<p>In JavaScript lässt sich unter Zuhilfenahme von Closures der
Kompositionsoperator formulieren:
<pre class="js">
function compose(g,f){
  return function(x){return g(f(x));};
}
</pre>
<p>Diesen Operator möchten wir nun als Methode einer Funktion
haben. Man macht folgenden Ansatz:
<pre class="js">
Function.prototype.o = function(f){
  return function(x){return this(f(x));};
}
</pre>
<p>Hier ergibt sich das Problem, dass das <code>this</code>-Argument
zur inneren Funktion gehört, und nicht zur äußeren.
Stattdessen ist man gezwungen zu:
<pre class="js">
Function.prototype.o = function(f){
  var g = this;
  return function(x){return g(f(x));};
}
</pre>
<p>Es wäre sinnvoll, wenn es in JavaScript eine Möglichkeit geben
würde, den Namen des <code>this</code>-Arguments individuell
festzulegen, wie bei jeder anderen gewöhnlichen Variable auch. Z.B. so:
<pre class="js">
Function.prototype.o = function(g;f){
  return function(x){return g(f(x));};
}
</pre>


<h2 id="Woerterbuch">Wörterbuch-Syntax</h2>
<p>In JavaScript koinzidieren Wörterbücher mit strukturierten
Objekten. Die Syntax von Wörterbuch- bzw. Objekt-Literalen besitzt
das Manko, dass zunächst keine Ausdrücke als Schlüssel möglich sind.
Weil nämlich die Schreibweisen
<pre class="js">
  t = {"a": 1, "b": 2};
  t = {a: 1, b: 2};
</pre>
<p>äquivalent sind, wäre die letztere Schreibweise zweideutig, wenn
Ausdrücke als Schlüssel auf der linken Seite zugelassen wären.
Man hat diesen Umstand in ES6 durch die Notation
<pre class="js">
  t = {["a"]: 1, ["b"]: 2};
</pre>
<p>umgangen. Diese Notation ist umständlich lang und schaut
dahingehend seltsam aus, dass die Schlüssel doch eigentlich auch
Arrays sein könnten:
<pre class="js">
  t = {[[1,2]]: 1, [[3,4]]: 2};
</pre>
<p>Hier ergibt sich ein weiteres Problem: alle Schlüssel werden
implizit in Zeichenketten umgewandelt. Zumindest bei Ganzzahlen
ergibt das keinen Sinn, da das direkte hashen von Ganzzahlen
wesentlich effizienter ist, als Zeichenketten neu zu erzeugen.
Problematisch ist weiterhin, dass die eckigen Klammern bei der
Umwandlung verloren gehen, die Schlüssel
<pre class="js">
  [1,[2,3]] und [1,2,3]
</pre>
<p>somit gleich sind.

<p>Meines erachtens wäre folgende Syntax sinnvoller gewesen:
<pre class="js">
  t = {"x": 1, "y": 2};
  t = {x=1, y=2};
</pre>
<p>Hiermit lassen sich auch recht angenehm Schlüsselwort-Argumente
(wie sie in Python und&nbsp;R zu finden sind) simulieren.

</body>
</html>

