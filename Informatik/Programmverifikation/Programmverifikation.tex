\documentclass[8pt,fleqn,aspectratio=169]{beamer}
\usetheme{Antibes}
\useinnertheme{rectangles}
\useoutertheme{infolines}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% Patch the look of +, = in arev
\usefonttheme{serif}

\usepackage{arev}
% Patch punctuation to be upright
\DeclareMathSymbol{.}{\mathpunct}{operators}{`.}
\DeclareMathSymbol{,}{\mathpunct}{operators}{`,}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}

\setbeamertemplate{footline}{%
\begin{beamercolorbox}[ht=3.0ex,dp=1ex]{title in head/foot}
\hfill\footnotesize\insertpagenumber\enspace\enspace\end{beamercolorbox}}

% \documentclass[8pt,aspectratio=169]{beamer}
\setbeamersize{text margin left=6em}
\setbeamersize{text margin right=6em}

\definecolor{bluegreen1}{rgb}{0.0,0.20,0.28}
\definecolor{bluegreen2}{rgb}{0.0,0.20,0.28}
\setbeamercolor*{palette primary}{fg=white,bg=bluegreen1}
\setbeamercolor*{palette secondary}{fg=white,bg=bluegreen2}
\setbeamercolor*{palette tertiary}{fg=white,bg=bluegreen2}
\setbeamercolor{itemize item}{fg=black}
\setbeamercolor{block title}{bg=bluegreen2}
\newcommand{\modest}[1]{{\small\color{gray}#1}}
\hypersetup{colorlinks,urlcolor=magenta}

\usepackage{listings}
\lstset{basicstyle=\ttfamily}
\lstdefinelanguage{IMP}{sensitive=true, keywords={
  true, false, skip, if, then, else, end, while, do, not, and, or}}
\lstdefinelanguage{Coq}{sensitive=true, keywords={
  Require, Import, Definition, Inductive, Fixpoint, Theorem, Proof, Qed,
  Goal, Module, End, Open, Scope,
  forall, fun, match, with, end, if, then, else}}

\newcommand{\inferrulewidth}{0.4608pt}
\usepackage{ebproof}
\ebproofset{rule margin = 0.5ex}
\ebproofset{label separation = 0.3em}
\ebproofset{right label template={\scriptsize\inserttext}}
\ebproofset{rule thickness=\inferrulewidth}

\newcommand{\ttq}{\textquotesingle}
\newcommand{\unit}[1]{\mathrm{#1}}
\newcommand{\strong}[1]{\textsf{\textbf{#1}}}
\newcommand{\defiff}{\quad:\Longleftrightarrow\quad}
\newcommand{\infernote}[1]{\!\text{\footnotesize #1}}
\renewcommand{\qedsymbol}{\ensuremath{\Box}}
\newcommand{\discharge}[1]{$\sim$#1}
\newcommand{\centerheadline}[1]{%
  \begin{center}\strong{#1}\end{center}}
\newcommand{\parspace}{\vspace{0.8em}}
\newcommand{\cond}{\rightarrow}

\newcommand{\kw}[1]{\textbf{\texttt{#1}}}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\qb}[1]{[\!\![#1]\!\!]}
\newcommand{\Bool}{\mathrm{Bool}}
\newcommand{\Int}{\mathrm{Int}}
\newcommand{\Loc}{\mathrm{Loc}}
\newcommand{\Aexp}{\mathrm{Aexp}}
\newcommand{\Bexp}{\mathrm{Bexp}}
\newcommand{\Com}{\mathrm{Com}}
\newcommand{\evA}{\mathcal A}
\newcommand{\evB}{\mathcal B}
\newcommand{\evC}{\mathcal C}

\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Abb}{\mathrm{Abb}}

\title{Programmverifikation}
% \subtitle{Untertitel}
\date{}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\begin{frame}
\centerheadline{Die Sprache IMP}
\end{frame}

\begin{frame}
Grundlegende Aspekte der Semantik von Programmiersprachen klären wir
anhand von IMP, einer minimalistischen imperativen Programmiersprache,
die uns als Studienobjekt dienen wird.
\end{frame}

\begin{frame}[fragile]

Beispiel für ein Programm in IMP:
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent]
y := 1; k := n;
while not k = 0 do
   y := y*x;
   k := k - 1
end
\end{lstlisting}\pause
Es berechnet zu ganzen Zahlen $\code{x},\code{n}$ mit $\code{n}\ge 0$
die Potenz $\code{y} = \code{x}^\code{n}$. Klar ersichtlich.\pause

\parspace
Das \emph{schnelle Exponentiation} genannte Programm
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent]
y := 1; a := x; k := n;
while 2 <= k do
   q := k/2; r := k - 2*q;
   if r = 1 then y := y*a else skip end;
   k := q; a := a*a
end;
if k = 1 then y := y*a else skip end
\end{lstlisting}
berechnet die Potenz ebenfalls. Immer noch klar ersichtlich?

\parspace
Wir würden dies gern \emph{beweisen}.
\end{frame}

\begin{frame}
Zunächst wird eine formale Definition der Sprache IMP unternommen.\pause

\parspace
Es sei $\Int$ die Menge der ganzen Zahlen im Dezimalsystem. Während also
$\Z$ die Menge der ganzen Zahlen bezeichnet, besteht $\Int$ aus konkreten
syntaktischen Darstellungen der Zahlen aus $\Z$.\pause

\parspace
Entsprechend sei $\Bool:=\{\kw{false},\kw{true}\}$, wobei die
Symbole \kw{false} und \kw{true} syntaktische Darstellungen der
Wahrheitswerte seien.
\end{frame}

\begin{frame}
Ein \strong{arithmetischer Ausdruck} $a$, kurz \strong{Term}, sei durch die
folgenden Produktionsregeln festgelegt.
\begin{itemize}
\item Eine ganze Zahl aus $\Int$ ist ein Term.
\item Eine Variable aus $\Loc$ ist ein Term.
\item Sind $a,a'$ Terme, so sind auch $a+a'$, $a-a'$, $a*a'$, $a\,/\,a'$ Terme.
\item Nichts anderes ist ein Term.
\end{itemize}
{\footnotesize Wir fassen die Terme hierbei als abstrakte Syntaxbäume auf.
Auf die genaue Grammatik und die Konstruktion eines Parsers will ich
an dieser Stelle nicht näher eingehen, damit der Fokus auf die
eigentliche Problemstellung nicht verloren geht. Die Operationen sollen
auf die gewöhnliche Art geschrieben werden, die Operatoren dabei die
gewöhnliche Rangfolge besitzen.}
\end{frame}

\begin{frame}
Ein \strong{boolescher Ausdruck} $b$, kurz \strong{Ausdruck}, sei durch
die folgenden Produktionsregeln festgelegt.
\begin{itemize}
\item Die Symbole \kw{false} und \kw{true} sind Ausdrücke.
\item Sind $a,a'$ Terme, so sind $a\;\code{=}\;a'$ und $a \;\code{<=}\; a'$ Ausdrücke.
\item Ist $b$ ein Ausdruck, so ist auch $\kw{not}\;b$ ein Ausdruck.
\item Sind $b,b'$ Ausdrücke, so sind auch $b\;\kw{and}\;b$ und $b\;\kw{or}\;b$ Ausdrücke.
\item Nichts anderes ist ein Ausdruck.
\end{itemize}
\end{frame}

\begin{frame}
Ein \strong{Kommando} $c$, auch \strong{Programm} genannt, sei durch die
folgenden Produktionsregeln festgelegt.
\begin{itemize}
\item Das Symbol \kw{skip} ist ein Kommando.
\item Ist $X$ eine Variable aus $\mathrm{Loc}$ und $a$ ein Term, so ist $X:=a$ ein Kommando.
\item Sind $c,c'$ Kommandos, so ist auch $c$; $c'$ ein Kommando.
\item Ist $b$ ein Ausdruck und sind $c,c'$ Kommandos, so ist auch\\
  \kw{if} $b$ \kw{then} $c$ \kw{else} $c'$ \kw{end} ein Kommando.
\item Ist $b$ ein Ausdruck und $c$ ein Kommando, so ist auch\\
  \kw{while} $b$ \kw{do} $c$ \kw{end} ein Kommando.
\item Nichts anderes ist ein Kommando.
\end{itemize}
\end{frame}

\begin{frame}
\centerheadline{Denotationelle Semantik}
\end{frame}

\begin{frame}
Wir bezeichnen
\begin{itemize}
\item mit $\Aexp$ die Menge der arithmetischen Ausdrücke,
\item mit $\Bexp$ die Menge der booleschen Ausdrücke,
\item mit $\Com$ die Menge der Kommandos.
\end{itemize}\pause
Will man nun einen arithmetischen Ausdruck auswerten, denkt
man sich dafür eine Funktion $\evA\colon\Aexp\to\Int$. Es ist
\[\evA\qb{1+2} = 3\]
usw. Nun kann ein arithmetischer Ausdruck aber auch Variablen enthalten,
womit bspw. auch der Wert $\evA\qb{\code{x}+1}$ bezüglich $\code{x}\in\Loc$
bestimmt sein muss.
\end{frame}

\begin{frame}
Die Auswertungsfunktion $\evA$ wird daher parametrisiert durch den aktuellen
Zustand $s$. Wir haben also $\evA\colon\Aexp\to (S\to\Int)$
bzw. $\evA\colon\Aexp\times S\to\Int$.\pause

\parspace
Einen \strong{Zustand} $s$ modellieren wir schlicht als die Belegung
der verfügbaren Variablen, also als eine Funktion $s\in S$ mit
$S:=\Abb(\Loc,\Int)$.\pause

\parspace
Zum Beispiel
\[s(X) := \begin{cases}
1, & \text{wenn $X=\code{x}$},\\
2, & \text{wenn $X=\code{y}$},\\
0 & \text{sonst}. 
\end{cases}\]
\end{frame}

\begin{frame}
Wir legen $\evA\colon\Aexp\to (S\to\Int)$ rekursiv fest gemäß
\begin{gather*}
\evA\qb{n}(s) := n,\\
\evA\qb{X}(s) := s(X),\\
\evA\qb{a+a'}(s) := \evA\qb{a}(s) + \evA\qb{a'}(s),\\
\evA\qb{a-a'}(s) := \evA\qb{a}(s) - \evA\qb{a'}(s),\\
\evA\qb{a*a'}(s) := \evA\qb{a}(s) \cdot \evA\qb{a'}(s),\\
\evA\qb{a\,/\,a'}(s) := \evA\qb{a}(s)\,/\, \evA\qb{a'}(s).
\end{gather*}
bezüglich $n\in\Int$, $X\in\Loc$ und $a,a'\in\Aexp$.
Die Operationen auf der rechten Seite werden hierbei auf die übliche
Art und Weise berechnet. Wir verwenden euklidische Ganzzahldivision
und setzen $n\,/\,0:=0$ für jedes $n\in\Int$.
\end{frame}

\begin{frame}
Wir legen $\evB\colon\Bexp\to (S\to\Bool)$ rekursiv fest gemäß
\begin{gather*}
\evB\qb{\kw{false}}(s) := \kw{false},\\
\evB\qb{\kw{true}}(s) := \kw{true},\\
\evB\qb{a \;\code{=}\; a'}(s) := (\evA\qb{a}(s) = \evA\qb{a'}(s)),\\
\evB\qb{a \;\code{<=}\; a'}(s) := (\evA\qb{a}(s)\le \evA\qb{a'}(s)),\\
\evB\qb{\kw{not}\;b} := \lnot\evB\qb{b}(s),\\
\evB\qb{b\;\kw{and}\;b'} := \evB\qb{b}(s)\land\evB\qb{b'}(s),\\
\evB\qb{b\;\kw{or}\;b'} := \evB\qb{b}(s)\lor\evB\qb{b'}(s),
\end{gather*}
bezüglich $a,a'\in\Aexp$ und $b,b'\in\Bexp$. Der Wahrheitswert der
Relationen bzw. Verknüpfungen auf der rechten Seite wird hierbei auf die
übliche Art und Weise berechnet.
\end{frame}

\begin{frame}
Wir legen $\evC\colon\Com\to (S\rightharpoonup S)$ rekursiv fest gemäß
\begin{gather*}
\evC\qb{\kw{skip}}(s) := s,\\
\evC\qb{X:=a}(s) := s[X:=A\qb{a}(s)],\\
\evC\qb{c; c'}(s) := \evC\qb{c'}(\evC\qb{c}(s)) = (\evC\qb{c'}\circ \evC\qb{c})(s),\\
\evC\qb{\text{\kw{if} $b$ \kw{then} $c$ \kw{else} $c'$ \kw{end}}}(s) := \begin{cases}
\evC\qb{c}(s),& \text{wenn $\evB\qb{b}(s)=\kw{true}$},\\
\evC\qb{c'}(s)& \text{sonst}.
\end{cases}\\
\evC\qb{\text{\kw{while} $b$ \kw{do} $c$ \kw{end}}}(s) := \begin{cases}
\varphi_{b,c}(\evC\qb{c}(s)),& \text{wenn $\evB\qb{b}(s)=\kw{true}$},\\
s & \text{sonst}
\end{cases}
\end{gather*}
mit $\varphi_{b,c}(s) := \evC\qb{\text{\kw{while} $b$ \kw{do} $c$ \kw{end}}}(s)$.\pause

\parspace
Bei $\evC\qb{c}$ handelt es sich um eine partielle Funktion, da die rekursive Auswertung
der while"=Schleife unter Umständen nicht terminiert -- zum Beispiel bei
\[\texttt{\kw{while} \kw{true} \kw{do} \kw{skip} \kw{end}}.\]
\end{frame}

\begin{frame}
\centerheadline{Die Zusicherungssprache}
\end{frame}

\begin{frame}
\emph{Zusicherungen} sind Aussagen, die man in einem bestimmten Zustand als
erfüllt sehen will. Zum Beispiel ist nach der Ausführung des Kommandos
$\code{y := x*x}$ die Zusicherung $\code{y}\ge 0$
erfüllt.\pause

\parspace
Zusicherungen sind logische Formeln, die der Sprache der einsortigen Logik
erster Stufe entstammen sollen. Die logische Sprache wird passend zur
Programmiersprache IMP definiert, dergestalt dass das Diskursuniversum
$\Int$ sei und die Variablen aus $\Loc$ in den Termen auftauchen dürfen.
Benötigte Funktionssymbole der Signatur $\Int^n\to\Int$ und
Relationssymbole der Signatur $\Int^n\to\Bool$ zu $n\in\N_{\ge 0}$ kann man
je nach Bedarf in ihrer üblichen Bedeutung hinzufügen; die Operatoren
von IMP sollen dabei aber mindestens verfügbar sein.\pause

\parspace
Wir müssen nun allerdings zwischen Variablen $x,y,z$ und Variablen
$\code{x},\code{y},\code{z}\in\Loc$ unterscheiden. Die kursiven tauchen
als freie und gebundene Variablen in den Formeln auf. Die aufrechten
verhalten sich dagegen wie Konstantensymbole, über sie kann nicht
quantifiziert werden.
\end{frame}

\begin{frame}
Die Notation $I,s\models A$ stehe für die Aussage, dass
die Interpretation $I=(\mathcal M,\beta)$ und der Zustand $s$
die Formel $A$ erfüllen. Hierbei ist $\mathcal M$ eine Struktur, die
die Bedeutung der Funktions- und Relationssymbole festlegt,
und $\beta$ eine Belegung der kursiven Variablen. Der Zustand $s$
belegt die aufrechten Variablen. {\footnotesize Die Definition der
Erfüllung geschieht analog zur gewöhnlichen Logik erster Stufe, weshalb
ich sie hier nicht näher ausführen will.}\pause

\parspace
Wir betrachten nur das Modell $\mathcal M_0$, das die Symbole mit ihrer üblichen
Bedeutung versieht. Daher sei $\mathcal I_0:=\{(\mathcal M,\beta)\mid\mathcal M=\mathcal M_0\}$,
das heißt, $\mathcal I_0$ sei die Menge der Interpretationen, deren Struktur
$\mathcal M_0$ ist.\pause

\parspace
Wir schreiben später $s\models A$ als Abkürzung für $I,s\models A$,
sofern sich dadurch keine Zweideutigkeiten ergeben.
\end{frame}

\begin{frame}
\centerheadline{Der Hoare-Kalkül}
\end{frame}

\begin{frame}[fragile]
An ein Kommando $c$ können wir Zusicherungen machen. Wir notieren
$\{A\}c\{B\}$ für die Aussage, dass die Aussage $B$ unter allen Umständen
nach der Ausführung von $c$ erfüllt ist, sofern die Aussage $A$ zuvor
erfüllt war. Man nennt $A$ diesbezüglich eine \emph{Vorbedingung}
und $B$ eine \emph{Nachbedingung} von $c$.\pause

\parspace
Beispiel für ein allgemeingültiges Tripel:
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\kw{true}\}$
y := x*x
$\{\code{y}\ge 0\}$
\end{lstlisting}
\end{frame}

\begin{frame}
Die Allgemeingültigkeit des Tripels $\{A\}c\{B\}$ wird dahingehend
definiert als
\[(\models\{A\}c \{B\}) \;:\Leftrightarrow\; \forall I\in\mathcal I_0\colon\forall s\in S\colon
(I,s\models A)\Rightarrow\forall s'\in S\colon \evC\qb{c}(s)=s'\Rightarrow (I,s'\models B).\]\pause
{\footnotesize In Bezug auf IMP ist der Wert $s'$,
sofern $\evC\qb{c}(s)$ existiert, eindeutig bestimmt.
Denken wir uns nun den ungültigen Zustand $\bot$, der sich ergeben soll,
wenn $c$ eine nicht terminierende Schleife ist, bekommt man eine totale Funktion
$\evC\qb{c}\colon S\cup\{\bot\}\to S\cup\{\bot\}$, wobei $\evC\qb{c}(\bot):=\bot$
gesetzt wird. Diesbezüglich verkürzt sich die Allgemeingültigkeit zu
\[(\models\{A\}c \{B\}) \;\Leftrightarrow\; \forall I\in\mathcal I_0\colon\forall s\in S\colon
(I,s\models A)\Rightarrow (I,\evC\qb{c}(s)\models B).\]
Hierbei verlangt man, dass $I,\bot\models A$ für jede Formel $A$ gilt.}
\end{frame}

\begin{frame}
\strong{Bemerkung.}
Wir können die Zusicherungssprache erweitern um eine modale Operation
$\Box_c B$ je Kommando $c$, üblicherweise $[c]B$ geschrieben.\pause{} Deren Semantik sei
\[(I,s\models [c]B) \;:\Leftrightarrow\; \forall s'\in S\colon R_c(s,s')\Rightarrow (I,s'\models B)\]
mit der Zugänglichkeitsrelation $R_c(s,s')\,:\Leftrightarrow\, \evC\qb{c}(s)=s'$.\pause

\parspace
Diesbezüglich sind $\{A\}c\{B\}$ und $A\Rightarrow [c]B$ semantisch äquivalent.\pause

\parspace
Die so erweiterte Logik nennt man die \emph{dynamische Logik} von IMP.
Die denotationelle Semantik nimmt hierbei die Rolle einer Kripke"=Semantik
ein, wobei die Zustände die Kripke"=Welten sind.
\end{frame}

\begin{frame}
Ein Tripel $\{A\}c\{B\}$ fordert allerdings nicht, dass $c$ terminiert;
lediglich dass $B$ gilt, \emph{falls} $c$ terminiert. Man nennt ein
solches Programm \emph{partiell korrekt} in Bezug auf $A,B$.\pause

\parspace
Terminiert das Programm zusätzlich, nennen wir es \emph{total korrekt}
in Bezug auf $A,B$ und notieren dies $[A]c[B]$.\pause

\parspace
Da die Semantik von IMP eine deterministische ist, ist der Zustand $s'=\evC\qb{c}(s)$,
sofern dieser existiert, eindeutig bestimmt; es gibt also keine weiteren Zustände,
an die wir $B$ fordern müssten. Daher ergibt sich
\[(\models [A]c [B]) \;\Leftrightarrow\; \forall I\in\mathcal I_0\colon\forall s\in S\colon
(I,s\models A)\Rightarrow\exists s'\in S\colon \evC\qb{c}(s)=s'\land (I,s'\models B).\]\pause
In Bezug auf die Modaloperation $\Diamond_c B$ bzw. $\langle c\rangle B$ mit der Semantik
\[(s\models\langle c\rangle B)\;:\Leftrightarrow\; \exists s'\in S\colon R_c(s,s')\land (s'\models B).\]
sind nun $[A]c[B]$ und $A\Rightarrow\langle c\rangle B$ semantisch äquivalent.

\parspace
{\footnotesize Außerdem bestehen die Äquivalenzen
$\langle c\rangle B \Leftrightarrow \lnot [c]\lnot B$
und $[c]B\Leftrightarrow\lnot\langle c\rangle\lnot B$.}
\end{frame}

\begin{frame}
Die Formalismen stehen im engen Bezug zum dijkstraschen wp-Kalkül.
Dijkstra notiert $\mathrm{wp}(c,B)$ für die schwächste Vorbedingung,
engl. \emph{weakest precondition}, unter der das Programm $c$ in einem
Zustand terminiert, in dem $B$ erfüllt ist. Für jede Vorbedingung $A$
gilt daher $A\Rightarrow\mathrm{wp}(c,B)$.\pause

\parspace
Analog steht $\mathrm{wlp}(c,B)$ für die schwächste liberale
Vorbedingung, die lediglich $B$ fordert, falls das Programm terminiert.
Demnach sind $[c]B$ und $\mathrm{wlp}(c,B)$ bedeutungsgleich.
Entsprechend drücken $\{A\}c\{B\}$ und $A\Rightarrow\mathrm{wlp}(c,B)$
dasselbe aus.\pause

\parspace
Aufgrund der deterministischen Natur von IMP sind des Weiteren
$\langle c\rangle B$ und $\mathrm{wp}(c,B)$ bedeutungsgleich.
Entsprechend drücken $[A]c[B]$ und $A\Rightarrow\mathrm{wp(c,B)}$
dasselbe aus.
\end{frame}

\begin{frame}[fragile]
Wir diskutieren nun die \strong{Schlussregeln} des Kalküls.\pause

\parspace
\begin{block}{Regel zur Zuweisung}
\[\dfrac{}{\vdash\{A[X:=a]\}X:=a\{A\}}\]
\end{block}
Eine Schlussregel ohne Prämissen. Mit $A[X:=a]$ ist hierbei die
Formel gemeint, die aus $A$ hervorgeht, indem jedes Vorkommen von
$X$ in $A$ durch den Term $a$ ersetzt wird.\pause

\parspace
Zum Beispiel erkennt man das Tripel
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\code{x}\ge 0\}$
x := x + 1
$\{\code{x}\ge 1\}$
\end{lstlisting}
unschwer als allgemeingültig. Dieses fällt unter die Fittiche der
Regel, indem $X:=\code{x}$, $a:=\code{x}+1$ und $A:=(\code{x}\ge 1)$
gesetzt wird. Damit ergibt sich $A[X:=a]$ zu $\code{x} + 1\ge 1$,
was logisch äquivalent zu $\code{x}\ge 0$ ist.
\end{frame}

\begin{frame}
Ob die Rechnung stimmt, prüft man so: Man betrachtet die Nachbedingung,
wendet auf diese die mit der Zuweisung übereinstimmende Substitution an,
und dies muss dann in der Vorbedingung resultieren.\pause

\parspace
\strong{Beweis der Gültigkeit der Regel.} Wir wollen
\[\models\{A[X:=a]\}X:=a\{A\}\]
zeigen.\pause{} Sei dazu $s$ fest, aber beliebig. Es gelte $s\models A[X:=a]$.
Des Weiteren gelte $\evC\qb{X:=a}(s)=s'$. Zu zeigen ist $s'\models A$.\pause

\parspace
Gemäß der denotationellen Semantik gilt $\evC\qb{X:=a}(s)=s[X:=a]$, womit
wir $s'=s[X:=a]$ haben. Schließlich folgt die Behauptung vermittels
der Äquivalenz
\[(s\models A[X:=a])\;\Leftrightarrow\; (s[X:=a]\models A),\]
die man unschwer als richtig erkennt oder pedantisch per struktureller
Induktion über den Aufbau von $A$ beweisen kann.\,\qedsymbol
\end{frame}

\begin{frame}
\begin{block}{Regel zum leeren Kommando}
\[\dfrac{}{\vdash\{A\}\kw{skip}\{A\}}\]
\end{block}\pause
\strong{Beweis ihrer Gültigkeit.}
Wir wollen $\models\{A\}\kw{skip}\{B\}$ zeigen.
Dazu sei $s$ fest, aber beliebig. Es gelte $s\models A$. Des Weiteren
gelte $\evC\qb{\kw{skip}}(s)=s'$. Zu zeigen ist $s'\models A$.\pause

\parspace
Gemäß der denotationellen Semantik gilt $\evC\qb{\kw{skip}}(s)=s$, womit
wir $s'=s$ und somit bereits die Behauptung haben.\,\qedsymbol
\end{frame}

\begin{frame}
\begin{block}{Regel zur Sequenz von Kommandos}
\[\dfrac{\vdash\{A\}c\{B\}\qquad \vdash\{B\}c'\{C\}}{\vdash\{A\}c; c'\{C\}}\]
\end{block}\pause
\strong{Beweis ihrer Gültigkeit.} Wir wollen $\models\{A\} c; c'\{C\}$ zeigen.
Dazu sei $s$ fest, aber beliebig. Es gelte $s\models A$. Des Weiteren
gelte $\evC\qb{c;c'}(s)=s''$. Zu zeigen ist $s''\models C$.\\
{\footnotesize Die letzten beiden C's stehen für Unterschiedliches; aber eine
Verwechslung ist ausgeschlossen, denke ich.}\pause

\parspace
Gemäß der denotationellen Semantik existiert $s'=\evC\qb{c}(s)$ mit
\[\evC\qb{c;c'}(s) = \evC\qb{c'}(s')=s''.\]
Aus $s\models A$ und $\models\{A\}c\{B\}$ folgt nun zunächst $s'\models B$.
Mit $\models\{B\}c'\{C\}$ folgt daraufhin $s''\models C$ aus
$s'\models B$.\,\qedsymbol
\end{frame}

\begin{frame}
\begin{block}{Regel zur Verzweigung}
\[\dfrac{\vdash\{A\land b\}c\{C\}\qquad\vdash\{A\land\lnot b\}c'\{C\}}{
\vdash\{A\}\text{\kw{if} $b$ \kw{then} $c$ \kw{else} $c'$ \kw{end}}\{C\}}\]
\end{block}\pause
\strong{Beweis ihrer Gültigkeit.} Sei $s$ fest, aber beliebig.
Es gelte $s\models A$. Des Weiteren gelte
\[\evC\qb{\text{\kw{if} $b$ \kw{then} $c$ \kw{else} $c'$ \kw{end}}}(s) = s'.\]
Zu zeigen ist $s'\models C$.\pause{} Fallunterscheidung. Im Fall
$\evB\qb{b}(s)=\kw{true}$ gilt $s\models b$, also $s\models A\land b$.
Außerdem ergibt sich in diesem Fall die Vereinfachung
\[\evC\qb{\text{\kw{if} $b$ \kw{then} $c$ \kw{else} $c'$ \kw{end}}}(s) = \evC\qb{c}(s).\]
Vermittels $\models\{A\land b\}c\{C\}$ erhalten wir somit $s'\models C$.
Die Argumentation im Fall $\evB\qb{b}(s)=\kw{false}$ verläuft analog.\,\qedsymbol
\end{frame}

\begin{frame}
\begin{block}{Regel zur Schleife}
\[\dfrac{\vdash\{A\land b\}c\{A\}}{
\vdash\{A\}\text{\kw{while} $b$ \kw{do} $c$ \kw{end}}\{A\land\lnot b\}}\]
\end{block}\pause
Sofern $A$ also sowohl vor der Schleife gilt, als auch vor und hinter
dem Schleifenrumpf, muss $A$ auch hinter der Schleife gelten. Man nennt
$A$ hierbei eine \emph{Schleifeninvariante}. Die Auffindung einer
zielführenden Invariante stellt eine wesentliche Schwierigkeit bei der
Programmverifikation dar.
\end{frame}

\begin{frame}
\strong{Beweis ihrer Gültigkeit.} Sei $s$ fest, aber beliebig.
Es gelte $s\models A$. Des Weiteren gelte
\[\evC\qb{\text{\kw{while} $b$ \kw{do} $c$ \kw{end}}}(s) = s''.\]
Zu zeigen ist $s''\models A\land\lnot b$.\pause{} Induktion über die
Anzahl der Durchläufe. Im Anfang findet kein Durchlauf statt. Das
geht aber nur, wenn $\evB\qb{b}(s)=\kw{false}$, also $s\models\lnot b$.
Da dem Zustand $s$ nach der Semantik der Schleife in diesem Fall keine Änderung
widerfährt, gilt $s=s''$. Demnach gilt $s''\models A$ und $s''\models\lnot b$,
also $s''\models A\land\lnot b$.\pause

\parspace
Zum Induktionsschritt. Da die Schleife durchlaufen wird, existiert
$s'$ mit $\evC\qb{c}(s)=s'$. Die restlichen null der mehr Schleifendurchläufe
führen dann zum Zustand $s''$, das heißt, $\varphi_{b,c}(s')=s''$.
Die Induktionsvoraussetzung ist, dass $s''\models A\land\lnot b$
aus $s'\models A$ folgt. Es verbleibt also $s'\models A$ zu zeigen.
Weil der erste Durchlauf stattfindet, muss des Weiteren $\evB\qb{b}(s)=\kw{true}$,
also $s\models b$ gelten, womit wir $s\models A\land b$ haben.
Vermittels $\models\{A\land b\}c\{A\}$, was ja Kraft der Prämisse der Regel
zur Verfügung steht, erhält man schließlich $s'\models A$.\,\qedsymbol
\end{frame}

\begin{frame}
\begin{block}{Regel zur Verstärkung der Vorbedingung}
\[\dfrac{\vdash A'\Rightarrow A\qquad\vdash\{A\}c\{B\}}{
\vdash\{A'\}c\{B\}}\]
\end{block}\pause
\strong{Beweis ihrer Gültigkeit.} Es gelte $s\models A'$.
Des Weiteren gelte $\evC\qb{c}(s)=s'$. Zu zeigen ist $s'\models B$.\pause{}
Mit $\models A'\Rightarrow A$ erhält man zunächst $s\models A$.
Mit $\models\{A\}c\{B\}$ daraufhin $s'\models B$.\,\qedsymbol
\end{frame}

\begin{frame}
\begin{block}{Regel zur Abschwächung der Nachbedingung}
\[\dfrac{\vdash\{A\}c\{B\}\qquad\vdash B\Rightarrow B'}{
\vdash\{A\}c\{B'\}}\]
\end{block}\pause
\strong{Beweis ihrer Gültigkeit.} Es gelte $s\models A$.
Des Weiteren gelte $\evC\qb{c}(s)=s'$. Zu zeigen ist $s'\models B'$.\pause{}
Mit $\models\{A\}c\{B\}$ erhält man zunächst $s'\models B$. Mit
$\models B\Rightarrow B'$ erhält man daraufhin $s'\models B'$.\,\qedsymbol.
\end{frame}

\begin{frame}
\begin{block}{Ersetzungsregeln}
\[\dfrac{\vdash A\Leftrightarrow A'\qquad\vdash\{A\}c\{B\}}{
  \vdash\{A'\}c\{B\}},\qquad
\dfrac{\vdash B\Leftrightarrow B'\qquad\vdash\{A\}c\{B\}}{
  \vdash\{A\}c\{B'\}}\]
\end{block}\pause
\strong{Beweis.} Folgt unmittelbar aus der Regel zur Verstärkung der
Vorbedingung bzw. Abschwächung der Nachbedingung.\,\qedsymbol
\end{frame}

\begin{frame}
\centerheadline{Verifikation des ersten Programms}
\end{frame}

\begin{frame}[fragile]
Gesucht ist ein Beweis des Tripels:
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt n\ge 0\}$
y := 1; k := n;
while not k = 0 do
   y := y*x;
   k := k - 1
end
$\{\mathtt{y = x^n}\}$
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Vermittels der Regel zur Zuweisung -- zuzüglich Reflexivität der
Gleichheit und der Ersetzungsregel -- ergibt sich erst einmal die Ableitung:
\[\begin{prooftree}
  \infer0{\vdash \mathtt n\ge 0\,\Leftrightarrow\,\mathtt n\ge 0\land 1 = 1}
  \infer0{\vdash\{\mathtt n\ge 0\land 1 = 1\}\;\code{y := 1}\;\{\mathtt n\ge 0\land\mathtt y = 1\}}
\infer2{\vdash\{\mathtt n\ge 0\}\;\code{y := 1}\;\{\mathtt n\ge 0\land\mathtt y = 1\}}
\end{prooftree}\]\pause
Wir fügen bereits ermittelte Zusicherungen in den Quelltext ein:
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt n\ge 0\}$
y := 1; k := n;
$\{\mathtt k\ge 0\land\mathtt y = 1\}$
while not k = 0 do
   y := y*x;
   k := k - 1
end
$\color{gray}\{\mathtt{y = x^n}\}?$
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Die Zielführende Schleifeninvariante ist hier $\mathtt{y =
x^{n-k}}$. Vor der Schleife gilt ja $\mathtt{n=k}$.
Mit $\mathtt{x}^0 = 1$ kommt man somit auf $\mathtt y = 1$.
{\footnotesize Bezüglich $0^0:=1$ gilt dies auch im Fall $\code{x}=0$.}\pause{}

\parspace
Wir durchziehen das Programm nun gemäß den Regeln sukzessive mit
Zusicherungen und gelangen daraufhin zum Abschluss der Verifikation:
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt n\ge 0\}$
y := 1; k := n;
$\{\mathtt{k\ge \mathrm 0\land y = \mathrm 1\land y = x^{n-k}}\}$
while not k = 0 do
   $\{\mathtt{y = x^{n-k}}\}$
   $\{\mathtt{y\cdot x = x^{n-k}\cdot x}\}$
   y := y*x;
   $\{\mathtt{y = x^{n-k}\cdot x = x^{n-(k - 1)}}\}$
   k := k - 1
   $\{\mathtt{y = x^{n-k}}\}$
end
$\{\mathtt{y = x^{n-k}\land k=\mathrm 0}\}$
$\{\mathtt{y = x^n}\}$
\end{lstlisting}
\end{frame}

\begin{frame}
\centerheadline{Verifikation des zweiten Programms}
\end{frame}

\begin{frame}[fragile]
Gesucht ist der Beweis von:
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt n\ge 0\}$
y := 1; a := x; k := n;
while 2 <= k do
   q := k/2; r := k - 2*q;
   if r = 1 then y := y*a else skip end;
   k := q; a := a*a
end;
if k = 1 then y := y*a else skip end
$\{\mathtt{y = x^n}\}$
\end{lstlisting}\pause

Wir betrachten das Programm zunächst vom Ende aus. Dort findet sich das Tripel
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt{(y = x^n\land k = \mathrm 0)\lor (y\cdot a = x^n\land k = \mathrm 1)}\}$
if k = 1 then y := y*a else skip end
$\{\mathtt{y = x^n}\}.$
\end{lstlisting}
Nimmt man bei der Vorbedingung nämlich die Fallunterscheidung in die
beiden Seiten der Disjunktion vor, gelangt man in beiden Fällen
zur Nachbedingung.
\end{frame}

\begin{frame}[fragile]
Am Anfang der Schleife gilt $\mathtt{a^k = x^n}$, was etwas mit der
Schleifeninvariante zu tun haben könnte. Ist diese Gleichung so
modifizierbar, dass unter ihr die Zusicherung
\[\mathtt{(y = x^n\land k = \mathrm 0)\lor (y\cdot a = x^n\land k = \mathrm 1)}\]
gilt?\pause{} Ja, nämlich zu $\mathtt{y\cdot a^k = x^n}$, denn
\begin{gather*}
\text{im Fall $\mathtt k=0$ gilt $\mathtt{y\cdot a^k = y}$},\\
\text{im Fall $\mathtt k=1$ gilt $\mathtt{y\cdot a^k = y\cdot a}$}.
\end{gather*}\pause
Die Gleichung $\mathtt{y\cdot a^k = x^n}$ gilt ebenfalls vor der
Schleife, da dort $\mathtt y = 1$ ist. Tatsächlich stellt sie eine
zielführende Schleifeninvariante dar. Es verbleibt also zu bestätigen,
dass sie auch am Ende des Schleifenrumpfs gilt.\pause

\parspace
Zunächst ergibt sich
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt{y\cdot a^k = x^n}\}$
q := k/2; r := k - 2*q
$\{\mathtt{y\cdot a^k = x^n\land q = \big\lfloor\frac{k}{\mathrm 2}\big\rfloor
\land r = k - \mathrm{2}q}\}.$
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Wegen $r\in\{0,1\}$ findet sich bei der Verzweigung nun
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt{y\cdot a^k = x^n\land q = \big\lfloor\frac{k}{2}\big\rfloor
\land r = k - \mathrm 2q}\}$
if r = 1 then y := y*a else skip end
$\{\mathtt{((y\cdot a^{k-\mathrm 1} = x^n\land r = \mathrm 1)\lor
(y\cdot a^k = x^n\land r = \mathrm 0))
\land r = k - \mathrm 2q}\}.$
\end{lstlisting}\pause
Die lange Nachbedingung kann man kompakter fassen als
\[\mathtt{y\cdot a^{k - r} = x^n\land r = k - \mathrm 2q},\]
wobei sich des Weiteren $\mathtt{k - r = \mathrm 2q}$ ergibt.\pause

\parspace
Zum Rest des Schleifenrumpfs findet sich somit schließlich
\begin{lstlisting}[language=IMP, xleftmargin=\mathindent, mathescape]
$\{\mathtt{y\cdot a^{\mathrm 2q} = x^n}\}$
k := q
$\{\mathtt{y\cdot a^{\mathrm 2k} = x^n}\}$
a := a*a
$\{\mathtt{y\cdot a^k = x^n}\}.$
\end{lstlisting}
Quod erat demonstrandum.
\end{frame}

\begin{frame}
\centerheadline{Maschinengestützte Formalisierung des Kalküls}
\end{frame}

\begin{frame}
Im Anschluss will ich noch eine Formalisierung der Überlegungen in Coq
ausführen. Dies setzt allerdings Grundwissen über die Sprache Gallina
voraus, und wie logisches Schließen vermittels Taktiken abläuft.

\parspace
Der vollständige Quelltext findet sich im Anhang. Um den Ablauf der
Beweise zu betrachten, muss CoqIDE genutzt werden.
\end{frame}

\begin{frame}[fragile]
Wir indizieren die Programmvariablen durch die natürlichen Zahlen.\\
Hierbei steht \code{loc 0}, \code{loc 1}, \code{loc 2} usw. für
$\mathtt{x}_0,\mathtt{x}_1,\mathtt{x}_2$ usw.

\parspace
Ein Zustand stellt sich daher schlicht als Funktion $s\colon\N\to\mathrm{Int}$
dar. Für die ganzen Zahlen $\mathrm{Int}$ verwenden wir hierbei den Typ
\code{Z} aus \code{ZArith}.

\parspace
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Require Import ZArith.ZArith.
Require Import Bool.Bool.

Definition Loc := nat.
Definition State := Loc -> Z.
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Als nächstes erfolgt die Erklärung der Sprache IMP vermittels
induktiver Tyen.\\
{\footnotesize Die Division will ich der Prägnanz halber erst einmal
entfallen lassen. Wir können sie später ggf. nachtragen.}

\begin{tabular}{@{\hspace{\mathindent}}l@{\qquad\qquad}l@{}}
\vtop{\null\hbox{
\begin{lstlisting}[language=Coq]
Inductive Aexpr :=
| int (n: Z)
| loc (X: Loc)
| add (a1 a2: Aexpr)
| sub (a1 a2: Aexpr)
| mul (a1 a2: Aexpr).

Inductive Bexpr :=
| btrue
| bfalse
| beq (a1 a2: Aexpr)
| ble (a1 a2: Aexpr)
| bnot (b: Bexpr)
| band (b1 b2: Bexpr)
| bor (b1 b2: Bexpr).
\end{lstlisting}
}}
&
\vtop{\null\hbox{
\begin{lstlisting}[language=Coq]
Inductive Com :=
| Skip
| Assign (X: Loc) (a: Aexpr)
| Seq (c1 c2: Com)
| If (b: Bexpr) (c1 c2: Com)
| While (b: Bexpr) (c: Com).
\end{lstlisting}
}}
\end{tabular}
\end{frame}

\begin{frame}[fragile]
Nun die Auswertungsfunktionen $A$, $B$. Für die Werte von $B$ nehmen wir
\code{bool} statt \code{Bexpr}, weil dieses bereits Funktionalität zum
Argumentieren mit sich bringt.

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Fixpoint evA (a: Aexpr) (s: State): Z :=
  match a with
  | int n => n
  | loc X => s X
  | add a1 a2 => evA a1 s + evA a2 s
  | sub a1 a2 => evA a1 s - evA a2 s
  | mul a1 a2 => evA a1 s * evA a2 s
  end.

Fixpoint evB (b: Bexpr) (s: State): bool :=
  match b with
  | btrue => true
  | bfalse => false
  | beq a1 a2 => Z.eqb (evA a1 s) (evA a2 s)
  | ble a1 a2 => Z.leb (evA a1 s) (evA a2 s)
  | bnot b => negb (evB b s)
  | band b1 b2 => andb (evB b1 s) (evB b2 s)
  | bor b1 b2 => orb (evB b1 s) (evB b2 s)
  end.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}[fragile]
Es wäre nun denkbar, die Terme und Formeln der Zusicherungssprache
ebenfalls vermittels induktiver Typen zu erklären. Dies führt allerdings
zu einem Rattenschwanz von Umständlichkeiten, da es zu einer
sogenannten \emph{tiefen Einbettung} des logischen Systems führt.
Wir müssten, wie für jede neue logische Sprache, einen Kalkül des natürlichen
Schließens formulieren und streng genommen auch noch dessen Korrektheit
beweisen.\pause

\parspace
Wir unternehmen stattdessen den Ansatz, die Zusicherungen als
Prädikate darzustellen, die Zustände als Argument bekommen. Eine
Zusicherung $A$ sei also eine Funktion
\[A\colon\texttt{State}\to\texttt{Prop}.\]\pause
Die Variante des Zustandes $s$ wird auf die übliche Weise erklärt.
Im Folgenden steht \code{variant s X n} also für $s[X:=n]$ bzw. $s[n/X]$.

\parspace
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Definition variant (s: State) (X: Loc) (n: Z): State :=
  fun Y => if Nat.eqb X Y then n else s Y.
\end{lstlisting}
\end{frame}

\begin{frame}
Die Übergangsfunktion $\evC$ ist wie gesagt eine partielle. Als Folge
dessen tut sich das Problem auf, dass ihre Implementierung unmöglich
wird, da in der Typentheorie nur solche Rekursionen fassbar
sind, deren Terminierung geklärt ist.

\parspace
Wir lösen dieses Problem in zwei Schritten. Erstens wird die partielle
Funktion $\evC$ als Relation formuliert. Statt $\evC\qb{c}(s)=s'$ notieren
wir also $\evC\qb{c}(s)(s')$ bzw. \code{evC c s s\ttq}. Zweitens beschränken
wir die rekursive Auswertung der Schleife über eine rekursive
Konstruktion \code{iter} auf eine maximale Tiefe $N$. Da nicht klar
ist, wie groß $N$ bei
\[\evC\qb{\kw{while}\; b\; \kw{do}\; c\; \kw{end}}(s)(s')\]
mindestens sein muss, wird lediglich die Existenz von $N$ gefordert.
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Fixpoint iter (ev: State -> State -> Prop)
(N: nat) (b: Bexpr) (s s1: State): Prop :=
  match N with
  | 0 => False
  | S N => if evB b s then
      exists s0, ev s s0 /\ iter ev N b s0 s1
    else s1 = s
  end.

Fixpoint evC (c: Com) (s s1: State): Prop :=
  match c with
  | Skip => s1 = s
  | Assign X a => s1 = variant s X (evA a s)
  | Seq c1 c2 => exists s0, evC c1 s s0 /\ evC c2 s0 s1
  | If b c1 c2 => if evB b s then evC c1 s s1 else evC c2 s s1
  | While b c => exists N, iter (evC c) N b s s1
  end.
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Nun kommen die Erklärungen zur Gültigkeit von Zusicherungen.

\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Definition Assertion := State -> Prop.
Definition sat (s: State) (A: Assertion): Prop := A s.

Definition valid (A: Assertion) (c: Com) (B: Assertion) :=
  forall s, sat s A -> forall s1, evC c s s1 -> sat s1 B.

Definition subst (A: Assertion) (X: Loc) (a: Aexpr): Assertion :=
  fun s => A (variant s X (evA a s)).
\end{lstlisting}

Diese Festlegungen sind folgendermaßen zu verstehen:
\begin{itemize}
\item Es steht \code{sat s A} für die Erfüllung $s\models A$.
\item Es steht \code{valid A c B} für die Gültigkeit des Tripels $\{A\}c\{B\}$.
\item Es steht \code{subst A X a} für die Substitution $A[X:=a]$, die direkt
als $s\mapsto A(s[X:=\evA\qb{a}(s)])$ definiert wird, insofern die Formel
von $A$ verborgen bleibt und das Substitutionslemma somit entfallen muss.
{\footnotesize Die beiden $A$ sind von unterschiedlicher Bedeutung --
das zweite steht für \code{evA}, siehe oben.}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
Die Formalisierung des Beweises der Gültigkeit der jeweiligen Schlussregel
kann nun unternommen werden.

\parspace
Zum leeren Kommando findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem skip_intro_is_valid A:
  valid A Skip A.
Proof.
  unfold valid. intros s hs. intros s1 hs1.
  simpl evC in hs1. rewrite hs1. exact hs.
Qed.
\end{lstlisting}
\end{small}

Zur Zuweisung findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem assign_intro_is_valid A X a:
  valid (subst A X a) (Assign X a) A.
Proof.
  unfold valid. intros s hs. intros s1 hs1.
  simpl evC in hs1.
  unfold sat in hs. unfold subst in hs.
  rewrite hs1. exact hs.
Qed.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}[fragile]
Zur Sequenz von Kommandos findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem seq_intro_is_valid A B C c1 c2:
  valid A c1 B -> valid B c2 C -> valid A (Seq c1 c2) C.
Proof.
  intros h1 h2. unfold valid. intros s hs. intros s2 hs2.
  simpl evC in hs2.
  destruct hs2 as (s1, (h11, h12)).
  unfold valid in h1. unfold valid in h2.
  assert (h1 := h1 s hs s1 h11).
  exact (h2 s1 h1 s2 h12).
Qed.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}[fragile]
Zur Verzweigung findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Definition Conj (A: Assertion) (b: Bexpr) :=
  fun s => sat s A /\ evB b s = true.

Theorem if_intro_is_valid A b C c1 c2:
  valid (Conj A b) c1 C -> valid (Conj A (bnot b)) c2 C ->
  valid A (If b c1 c2) C.
Proof.
  intros h1 h2. unfold valid. intros s hs s1 hs1.
  simpl evC in hs1.
  destruct (evB b s) eqn:heq.
  * unfold valid in h1. apply (h1 s).
    - unfold sat. unfold Conj. rewrite heq.
      exact (conj hs (eq_refl true)).
    - exact hs1.
  * unfold valid in h2. apply (h2 s).
    - unfold sat. unfold Conj.
      simpl evB. rewrite heq. simpl.
      exact (conj hs (eq_refl true)).
    - exact hs1.
Qed.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}[fragile]
Zur Schleife findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem while_intro_is_valid A b c:
  valid (Conj A b) c A -> valid A (While b c) (Conj A (bnot b)).
Proof.
  intro h. unfold valid. intros s hs. intros s2 hs2.
  simpl evC in hs2. destruct hs2 as (N, hiter).
  revert s s2 hs hiter.
  induction N as [| N ih].
  * intros s s2 hs hiter. simpl iter in hiter.
    exfalso. exact hiter.
  * intros s s2 hs hiter. simpl iter in hiter.
    destruct (evB b s) eqn:heq.
    - destruct hiter as (s1, (h11, h12)).
      apply (ih s1 s2). clear ih.
      -- unfold valid in h. apply (h s). clear h.
         --- unfold sat. unfold Conj. exact (conj hs heq).
         --- exact h11.
      -- exact h12.
    - rewrite hiter. unfold sat. unfold Conj. split.
      -- exact hs.
      -- simpl evB. rewrite heq. simpl. reflexivity.
Qed.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}[fragile]
Zur Verstärkung der Vorbedingung findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem strengthen_precondition_is_valid {A1 A2 B c}:
  (forall s, A2 s -> A1 s) -> valid A1 c B -> valid A2 c B.
Proof.
  intros h1 h2. unfold valid. intros s hs s1 hs1.
  unfold sat in hs. apply (h1 s) in hs. clear h1.
  unfold valid in h2. apply (h2 s).
  * unfold sat. exact hs.
  * exact hs1.
Qed.
\end{lstlisting}
\end{small}

Zur Abschwächung der Nachbedingung findet sich:

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem weaken_postcondition_is_valid {A B1 B2 c}:
  (forall s, B1 s -> B2 s) -> valid A c B1 -> valid A c B2.
Proof.
  intros h1 h2. unfold valid. intros s hs s1 hs1.
  unfold sat. apply (h1 s1). clear h1.
  fold (sat s1 B1). unfold valid in h2. apply (h2 s).
  * exact hs.
  * exact hs1.
Qed.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}[fragile]
\strong{Kurzes Anwendungsbeispiel}

\parspace
Beweis der Gültigkeit des Tripels
$\{\mathtt x = 0\}\; \code{x := x + 1}\; \{\mathtt x = 1\}$.\pause

\begin{small}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Module Example1.
  Open Scope Z_scope.
  Definition x: nat := 0.

  Goal valid
    (fun s => s x = 0)
    (Assign x (add (loc x) (int 1)))
    (fun s => s x = 1).
  Proof.
    assert (h1 := assign_intro_is_valid
      (fun s => s x = 1) x (add (loc x) (int 1))).
    unfold subst in h1. unfold variant in h1. simpl in h1.
    assert (h2: forall s, s x = 0 -> s x + 1 = 1). {
      intros s heq. rewrite <- (Z.add_cancel_r _ _ 1) in heq.
      simpl in heq. exact heq.
    }
    exact (strengthen_precondition_is_valid h2 h1).
  Qed.
End Example1.
\end{lstlisting}
\end{small}
\end{frame}

\begin{frame}
\strong{Literatur}
\begin{itemize}
\item Glynn Winskel:
  \emph{The Formal Semantics of Programming Languages: An Introduction}.
  The MIT Press, 1993.
\item Krzysztof R. Apt, Ernst-Rüdiger Olderog:
  \emph{Fifty years of Hoare’s logic}.\\
  In: \emph{Formal Aspects of Computing}.
  Band 31, Nr. 6, 2019, S. 751--807.\\
  \href{https://doi.org/10.1007/s00165-019-00501-3}{doi:10.1007/s00165-019-00501-3}.
\item Edsger W. Dijkstra:
  \emph{A Discipline of Programming}. Prentice Hall, 1976.
\item Benjamin C. Pierce u.\,a.:
  \href{https://softwarefoundations.cis.upenn.edu/}{\emph{Software Foundations}}.
\item Nicolas Troquard, Philippe Balbiani:
  \href{https://plato.stanford.edu/entries/logic-dynamic/}{\emph{Propositional Dynamic Logic}}.
  In: \emph{The Stanford Encyclopedia of Philosophy}.
\item David Harel, Dexter Kozen, Jerzy Tiuryn:
  \emph{Dynamic Logic}. The MIT Press, 2000.
\end{itemize}
\end{frame}

\begin{frame}
\strong{Anlagen}

\begin{itemize}
\item\href{https://github.com/JohnBSmith/misc/tree/master/cs/imp}{%
IMP-Interpreter} -- Führt ein IMP-Programm gemäß der denotationellen
Semantik aus. In Python verfasst, in unter 300 Zeilen Quelltext.

\item\href{https://github.com/JohnBSmith/misc/tree/master/cs/imp/proofs}{%
Quelltext der formalisierten Beweise}.
\end{itemize}
\end{frame}

\begin{frame}
Ende.
\vfill\hfill\modest{Januar 2025}\\
\hfill\modest{Creative Commons CC0 1.0}
\end{frame}

\end{document}
