<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Makros</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Makros</h1>
<h2 id="toc">Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Literale">Literale</a>
</ol>

<h2 id="Literale">Literale</h2>
<p>Makros können genutzt werden, um Datentypen mit Literalen
auszustatten, welche zur Initialisierung der Datenstrukturen
genutzt werden.

<p>Literal für ein dynamisches Feld von Zeichenketten:
<pre class="rust indent">
macro_rules! vec_string {
    ( $( $x:expr ),* ) =&gt; {{
        let mut temp_vec = Vec::new();
        $(temp_vec.push($x.to_string());)*
        temp_vec
    }}
}

fn main() {
    let v: Vec&lt;String&gt; = vec_string![
        "Ahorn", "Eiche", "Erle", "Esche"
    ];
    println!("{:?}",v);
}
</pre>

<p>Literal für ein assoziatives Feld:
<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $( [$key:expr]: $value:expr ),* ) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($key.to_string(),$value.to_string());)*
        temp_map
    }}
}

fn main() {
    let m: HashMap&lt;String,String&gt; = map!{
        ["Ahorn"]: "Acer",
        ["Eiche"]: "Quercus",
        ["Erle" ]: "Alnus",
        ["Esche"]: "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<p>Die eckigen Klammern um die Schlüssel sind etwas umständlich.
Sie sind vorhanden weil nach <code>$key:expr</code> kein Doppelpunkt
folgen darf, die erlaubten Zeichen sind "<code>=&gt; , ;</code>"
und schließende Klammern. Das <code>expr</code> zeigt uns
hier, dass es sich um einen Ausdruck handelt. Tatsächlich können
wir aber mit <code>tt</code> (single token tree) sagen, dass es
sich um ein Atom handeln soll, wobei auch ein geklammerter Ausdruck
als Atom zugelassen ist. Nach leichter Modifikation ergibt sich
also:

<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $( $key:tt: $value:expr ),* ) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($key.to_string(),$value.to_string());)*
        temp_map
    }}
}

fn main() {
    let m: HashMap&lt;String,String&gt; = map!{
        "Ahorn": "Acer",
        "Eiche": "Quercus",
        "Erle" : "Alnus",
        "Esche": "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<p>Das Makro ist bis jetzt auf den Typ
<code>HashMap&lt;String,String&gt;</code> begrenzt.
Mit der Trait-Methode <code>into</code> lässt es sich
aber auf andere Typen verallgemeinern:

<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $( $key:tt: $value:expr ),* ) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($key.into(),$value.into());)*
        temp_map
    }}
}

fn main() {
    let m: HashMap&lt;String,String&gt; = map!{
        "Ahorn": "Acer",
        "Eiche": "Quercus",
        "Erle" : "Alnus",
        "Esche": "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<p>Etwas allgemeiner lassen sich beliebige Transformationen
<code>tk</code> und <code>tv</code> anwenden:

<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $tk:expr, $tv:expr; $( $key:tt: $value:expr ),*) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($tk($key),$tv($value));)*
        temp_map
    }}
}

fn main() {
    let m = map!{String::from,String::from;
        "Ahorn": "Acer",
        "Eiche": "Quercus",
        "Erle" : "Alnus",
        "Esche": "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

</body>
</html>

