<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Makros</h1>
<h2 id="toc">Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Literale">Literale</a>
<li><a href="#Komprehensionen">Komprehensionen</a>
<li><a href="#TT-muncher">TT muncher</a>
</ol>

<h2 id="Literale">Literale</h2>
<p>Makros können genutzt werden, um Datentypen mit Literalen
auszustatten, welche zur Initialisierung der Datenstrukturen
genutzt werden.

<p>Die Standardbibliothek enthält zwar schon ein Makro für
dynamische Felder, jedoch kann dies etwas umständlich sein:
<pre class="rust indent">
let v: Vec&lt;String&gt; = vec![
    "Ahorn".to_string(),
    "Eiche".to_string(),
    "Erle" .to_string(),
    "Esche".to_string()
];
</pre>

<p>Ein Literal für ein dynamisches Feld von Zeichenketten
erlaubt die gewünschte Verkürzung:
<pre class="rust indent">
macro_rules! vec_string {
    ( $( $x:expr ),* ) =&gt; {{
        let mut temp_vec = Vec::new();
        $(temp_vec.push($x.to_string());)*
        temp_vec
    }}
}

fn main() {
    let v: Vec&lt;String&gt; = vec_string![
        "Ahorn", "Eiche", "Erle", "Esche"
    ];
    println!("{:?}",v);
}
</pre>

<p>Mit den Verbesserungen geht es aber noch weiter voran. Der Ausdruck
<code>s.to_string()</code> lässt sich auch ersetzen gegen
<code>s.into()</code>, mit dem Vorteil typgenerisch zu sein.
Außerdem kann man das Literal auch auf <code>vec![]</code> zurückführen,
welches effizienter implementiert ist. Beides kombiniert ergibt
folgendes Makro:

<pre class="rust indent">
macro_rules! vec_from {
    ($($item:expr),* $(,)?) =&gt; {vec![$($item.into(),)*]}
}
</pre>

<p>Literal für ein assoziatives Feld:
<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $( [$key:expr]: $value:expr ),* ) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($key.to_string(),$value.to_string());)*
        temp_map
    }}
}

fn main() {
    let m: HashMap&lt;String,String&gt; = map!{
        ["Ahorn"]: "Acer",
        ["Eiche"]: "Quercus",
        ["Erle" ]: "Alnus",
        ["Esche"]: "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<p>Die eckigen Klammern um die Schlüssel sind etwas umständlich.
Sie sind vorhanden weil nach <code>$key:expr</code> kein Doppelpunkt
folgen darf, die erlaubten Zeichen sind "<code>=&gt; , ;</code>"
und schließende Klammern. Das <code>expr</code> zeigt uns
hier, dass es sich um einen Ausdruck handelt. Tatsächlich können
wir aber mit <code>tt</code> (single token tree) sagen, dass es
sich um ein Atom handeln soll, wobei auch ein geklammerter Ausdruck
als Atom zugelassen ist. Nach leichter Modifikation ergibt sich
also:

<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $( $key:tt: $value:expr ),* ) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($key.to_string(),$value.to_string());)*
        temp_map
    }}
}

fn main() {
    let m: HashMap&lt;String,String&gt; = map!{
        "Ahorn": "Acer",
        "Eiche": "Quercus",
        "Erle" : "Alnus",
        "Esche": "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<p>Das Makro ist bis jetzt auf den Typ
<code>HashMap&lt;String,String&gt;</code> begrenzt.
Mit der Trait-Methode <code>into</code> lässt es sich
aber auf andere Typen verallgemeinern:

<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $( $key:tt: $value:expr ),* ) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($key.into(),$value.into());)*
        temp_map
    }}
}

fn main() {
    let m: HashMap&lt;String,String&gt; = map!{
        "Ahorn": "Acer",
        "Eiche": "Quercus",
        "Erle" : "Alnus",
        "Esche": "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<p>Etwas allgemeiner lassen sich beliebige Transformationen
<code>tk</code> und <code>tv</code> anwenden:

<pre class="rust indent">
use std::collections::HashMap;

macro_rules! map {
    ( $tk:expr, $tv:expr; $( $key:tt: $value:expr ),*) =&gt; {{
        let mut temp_map = HashMap::new();
        $(temp_map.insert($tk($key),$tv($value));)*
        temp_map
    }}
}

fn main() {
    let m = map!{String::from,String::from;
        "Ahorn": "Acer",
        "Eiche": "Quercus",
        "Erle" : "Alnus",
        "Esche": "Fraxinus excelsior"
    };
    println!("{:?}",m);
}
</pre>

<h2 id="Komprehensionen">Komprehensionen</h2>

<p>For-Audrücke, auch Listen-Komprehension oder Iterator-Komprehension
genannt, gibt es Rust nicht. Da Rust aber Ausdruck-orientiert ist,
lassen sich diese mithilfe von Makros selbst programmieren.

<pre class="rust indent">
macro_rules! list {
    ($expr:expr; for $x:tt in $range:expr) =&gt; {{
        let mut _a = Vec::new();
        for $x in $range {_a.push($expr);}
        _a
    }};
}

fn main() {
    let a = list![2*x; for x in 0..10];
    println!("{:?}",a);
}
</pre>

<p>Die Anzahl der notwendigen Reallokationen lässt sich durch
Ausnutzen von <code>size_hint</code> erheblich reduzieren:

<pre class="rust indent">
macro_rules! list {
    ($expr:expr; for $x:tt in $range:expr) =&gt; {{
        let _r = $range;
        let mut _a = Vec::with_capacity(_r.size_hint().0);
        for $x in _r {_a.push($expr);}
        _a
    }};
}
</pre>

<p>Mit mehrstufigen for-Ausdrücken bekommt man kartesische
Produkte als Definitionsbereich. Diese for-Ausdrücke kann man jeweils
separat bis zu einer maximalen Anzahl implementieren:

<pre class="rust indent">
macro_rules! list {
    ($expr:expr; for $x:tt in $range:expr) =&gt; {{
        let mut _a = Vec::new();
        for $x in $range {_a.push($expr);}
        _a
    }};
    ($expr:expr; for $x:tt in $xrange:expr;
        for $y:tt in $yrange:expr
    ) => {{
        let mut _a = Vec::new();
        for $x in $xrange {
            for $y in $yrange {_a.push($expr);}
        }
        _a
    }};
}

fn main() {
    let a = list![x*y; for x in 0..2; for y in 0..2];
    println!("{:?}",a);
}
</pre>


<h2 id="TT-muncher">TT muncher</h2>

<p>Das Makro für die for-Ausdrücke lässt sich aber auch variadisch
programmieren. Zur Umsetzung ist ein Verfahren gewinnbringend,
das sich »TT muncher« nennt. Hierbei wird das zu parsende Muster
in einen Anfang und einen Rest <code>$tail</code> zerlegt.
Mit einem weiteren Makro-Aufruf geschieht dann das Parsen von
<code>$tail</code>, was sich auch rekursiv formulieren lässt.

<pre class="rust indent">
macro_rules! expand_tail {
    ($expr:tt; $v:tt; for $x:tt in $range:expr) =&gt; {
        for $x in $range {$v.push($expr);}
    };
    ($expr:tt; $v:tt; for $x:tt in $range:expr; $($tail:tt)*) =&gt; {
        for $x in $range {expand_tail!($expr; $v; $($tail)*)}
    };
}

macro_rules! list {
    ($expr:expr; $($tail:tt)*) =&gt; {{
        let mut _a = Vec::new();
        expand_tail!{$expr; _a; $($tail)*}
        _a
    }};
}

fn main() {
    let a = list![[x,y,z];
        for x in 0..2; for y in 0..2; for z in 0..2];
    println!("{:?}",arr);
}
</pre>

<p>Bei for-Ausdrücken sind auch Bedingungen erlaubt, mit denen
sich Elemente ausfiltern lassen. Diese können wir nun auch
noch einbauen. Als einfaches Beispiel ist die Auflistung
von pythagoräischen Tripeln angegeben.

<pre class="rust indent">
macro_rules! expand_tail {
    ($expr:tt; $v:tt; for $x:tt in $range:expr) =&gt; {
        for $x in $range {$v.push($expr);}
    };
    ($expr:tt; $v:tt; for $x:tt in $range:expr; if $cond:expr) =&gt; {
        for $x in $range {if $cond {$v.push($expr);}}
    };
    ($expr:tt; $v:tt; for $x:tt in $range:expr;
        if $cond:expr; $($tail:tt)*
    ) =&gt; {
        for $x in $range {
            if $cond {expand_tail!($expr; $v; $($tail)*)}
        }
    };
    ($expr:tt; $v:tt; for $x:tt in $range:expr; $($tail:tt)*) =&gt; {
        for $x in $range {expand_tail!($expr; $v; $($tail)*)}
    };
}

macro_rules! list {
    ($expr:expr; $($tail:tt)*) =&gt; {{
        let mut _a = Vec::new();
        expand_tail!{$expr; _a; $($tail)*}
        _a
    }};
}

fn main() {
    let a = list![[x,y,z];
        for x in 1..100; for y in 1..100; for z in 1..100;
        if x&lt;y &amp;&amp; x*x+y*y == z*z];
    println!("{:?}",a);
}
</pre>

</body>
</html>

