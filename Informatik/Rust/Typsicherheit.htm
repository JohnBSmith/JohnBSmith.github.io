<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Typsicherheit</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Validierung">Validierung</a>
<li><a href="#ADT">Abstrakte Datentypen</a>
<li><a href="#Read-only">Schreibgeschützte Komponenten</a>
<li><a href="#Contracts">Vertragsbasierte Programmierung</a>
</ol>

<h2 id="Validierung">Validierung</h2>

<p>Angenommen, wir erhalten über eine Schnittstelle eine
Zeichenkette die aus genau vier dezimalen Ziffern bestehen soll.
Diese Zeichenkette wird später in eine Zahl umgewandelt und für
einen Datenbankindex verwendet. Nun ist es aber so, dass diese
Zeichenkette von einem Client zu einem Server kommt. Das Client-Programm
übergibt jedoch eine Zeichenkette die eine falsche Zahl von Ziffern
besitzt oder Buchstaben enthält. Dies führt dazu dass das Datenbanksystem
in einen invaliden Zustand gerät und ein über Monate lang umbemerktes
Datenleck entsteht.

<p>Das Problem hier ist, dass einer der Programmier
vielleicht nicht gewusst hat, dass die Daten vor der Benutzung hätten
validiert werden müssen.

<p>In Rust kann eine solche Validierung vom Typsystem erzwungen
werden, indem für die validierten Daten ein eigener Datentyp definiert
wird, nennen wir ihn <code>Datenbankindex</code>. Die Idee dabei ist,
dass erstens die betroffenen Unterprogramme nur Werte vom Typ
<code>Datenbankindex</code> entgegennehmen und zweitens
ein solcher Wert nur über eine Validierung erzeugt werden kann.

<pre class="rust indent">
mod db{
    #[derive(Clone,Copy)]
    pub struct Datenbankindex{
        index: u16
    }
    fn is_digit(c: char) -&gt; bool {
        48&lt;=(c as u32) &amp;&amp; (c as u32)&lt;=57
    }
    impl Datenbankindex{
        pub fn new(s: &amp;str) -&gt; Option&lt;Self&gt; {
            let a: Vec&lt;char&gt; = s.chars().collect();
            if a.len()==4 &amp;&amp;
                is_digit(a[0]) &amp;&amp; is_digit(a[1]) &amp;&amp;
                is_digit(a[2]) &amp;&amp; is_digit(a[3])
            {
                return Some(Datenbankindex{
                    index: s.parse::&lt;u16&gt;().unwrap()
                });
            }else{
                return None;
            }
        }
        pub fn get(&amp;self) -&gt; u16 {
            self.index
        }
    }
}

use std::io;
use std::io::Write;

fn main(){
    loop {
        print!("Index: ");
        if io::stdout().flush().is_err() {println!();}
        let mut s = String::new();
        io::stdin().read_line(&amp;mut s).unwrap();
        s.pop();
        match db::Datenbankindex::new(&amp;s) {
            Some(index) =&gt; {
                DatenbankZugriff(index)
            },
            None =&gt; {
                println!("Fehler: ungültiger Datenbankindex.");
                continue;
            }
        };
    }
}

#[allow(non_snake_case)]
fn DatenbankZugriff(index: db::Datenbankindex){
    println!("Validierter Index: {}",index.get());
}
</pre>

<p>Hierzu ist zu bemerken, dass das Feld <code>index</code>
von <code>Datenbankindex</code> privat ist. Daher besteht der Zugang
zu Werten vom Typ <code>Datenbankindex</code> nur über die öffentlichen
Funktionen <code>new</code> und <code>get</code>.

<p>Die Idee ist nun, die Steuerung der Datenbank von ihrem Kernel zu
abstrahieren. Bei der Ansteuerung der Datenbank sollte es nie
zu einem invaliden Zustand kommen. Lediglich im Kernel besteht Zugriff
auf die private Funktionalität, bei der das System auch zerstört
werden kann, wenn man nicht vorsichtig ist.

<p>In Verbindung hiermit kann gesagt werden, dass die Maxime eine
möglichst strenge Typisierung der gesamten Datenverarbeitung sein
sollte.

<h2 id="ADT">Abstrakte Datentypen</h2>
<p>Ein abstrakter Datentyp, kurz ADT, ist ein Datentyp mit Operationen,
bei dem die interne Struktur und die interne Implementation der
Operationen vor der Öffentlichkeit verschwiegen wird. Bei einem
abstrakten Datentyp kann es sich um einen einfachen Datentyp oder
auch um eine komplizierte Datenstruktur handeln. Wichtig ist nur,
dass nur solche Operationen öffentlich sind, die eine Schnittstelle
zur Außenwelt repräsentieren.

<p>Es ist möglich dass ein abstrakter Datentyp eine vollkommen
typsichere Schnittstelle besitzt, obwohl dem bei der internen
Implementation nicht so ist. Man spricht von einer
<i>sicheren Kapselung</i> oder <i>sicheren Abstraktion</i>.

<p>Rust bietet die Mittel zur Darstellung von abstrakten Datentypen,
indem Variablen und Funktionen per Vorgabe zunächst privat sind.
Möchte man etwas zur öffentlichen Schnittstelle hinzufügen, so muss es
mit dem Schlüsselwort <code>pub</code> als <i>public</i> deklariert werden.

<p>Rust bietet außerdem Zero-Cost-Abstractions, die eine
Spezialisierung von allgemeinen abstrakten Datentypen zu spezielleren
ermöglichen, ohne dass es dabei zu Laufzeiteinbußen kommt.
Zur Umsetzung wird die Inline-Ersetzung von Funktionsaufrufen genutzt.

<p>Als einfachstes Beispiel soll ein Stapelspeicher formuliert
werden, der nur die Operationen <code>push</code> und <code>pop</code>
unterstützt.

<pre class="rust indent">
mod stack {
    pub struct Stack&lt;T&gt; {
        v: Vec&lt;T&gt;
    }
    impl&lt;T&gt; Stack&lt;T&gt; {
        pub fn new() -&gt; Self {
            Stack{v: Vec::new()}
        }
        pub fn push(&amp;mut self, x: T) {
            self.v.push(x);
        }
        pub fn pop(&amp;mut self) -&gt; T {
            match self.v.pop() {Some(x)=&gt;x, None=&gt;panic!()}
        }
    }
}

use stack::Stack;

fn main() {
    let mut a: Stack&lt;i32&gt; = Stack::new();
    a.push(1);
    a.push(2);
    println!("{}",a.pop());
    println!("{}",a.pop());
}
</pre>

<p>Der Konstruktor <code>new</code> und die Methoden
<code>push</code> und <code>pop</code> können mit
<code>#[inline(always)]</code> annotiert werden, um Inline-Ersetzung
zu erzwingen. Die Funktionen sind aber so kurz, dass der Compiler
das in aller Wahrscheinlichkeit automatisch macht, sofern die
Optimierungen eingeschaltet werden.

<p>Das Konzept der Schnittstelle lässt sich aber auch noch
schärfer umsetzen. Spezifiziert man die Schnittstelle durch einen
Trait, dann lassen sich abstrakte Programme schreiben,
welche nur noch auf die Schnittstelle zugreifen, aber nicht
mehr auf konkrete Datentypen.

<pre class="rust indent">
mod stack {
    pub trait Stack&lt;T&gt; {
        fn new() -&gt; Self;
        fn push(&amp;mut self, x: T);
        fn pop(&amp;mut self) -&gt; T;
    }

    pub struct VecStack&lt;T&gt; {
        v: Vec&lt;T&gt;
    }
    impl&lt;T&gt; Stack&lt;T&gt; for VecStack&lt;T&gt; {
        fn new() -&gt; Self {
            VecStack{v: Vec::new()}
        }
        fn push(&amp;mut self, x: T) {
            self.v.push(x);
        }
        fn pop(&amp;mut self) -&gt; T {
            match self.v.pop() {Some(x)=&gt;x, None=&gt;panic!()}
        }
    }
}

use stack::{Stack,VecStack};

fn routine&lt;S: Stack&lt;i32&gt;&gt;() {
    let mut a: S = S::new();
    a.push(1);
    a.push(2);
    println!("{}",a.pop());
    println!("{}",a.pop());
}

fn main() {
    routine::&lt;VecStack&lt;i32&gt;&gt;();
}
</pre>

<h2 id="Read-only">Schreibgeschützte Komponenten</h2>

<p>Oft möchte man bei Datenstrukturen von außen nur Lesezugriff
auf Komponenten zulassen. Ein solcher Schreibschutz gehört neben
Privatheit zum Konzept der Kapselung. Würde man eine Schnittstelle
zulassen, die Manipulation interner Variablen erlaubt, ließe sich damit
die Integrität der Datenstruktur zerstören. Mit dem Schreibschutz
können wir eine konforme Benutzung der Datenstruktur erzwingen.

<p>Als Beispiel wählen wir eine Datenstruktur, welche eine Liste von
Obst in verschiedenen Sorten und ihr Gesamtgewicht speichert. Sowohl
die Liste als auch das Gesamtgewicht müssen von außen schreibgeschützt
sein.

<p>Der Grundaufbau der Obstkiste sieht so aus:

<pre class="rust indent">
struct Fruit {kind: String, weight: u32}
struct FruitCrate {list: Vec&lt;Fruit&gt;, total_weight: u32}
</pre>

<p>Die Zahlen speichern sinnvollerweise die Masse in Gramm.
Die Datenstruktur wird nun eingekapselt. Die problematischen
Komponenten &ndash; das sind hier sämtliche &ndash; lassen wir
privat. Ausgelesen werden die Komponenten stattdessen mit Methoden,
wobei man der Methode auch den gleichen Bezeichner wie der
Komponente geben kann.

<pre class="rust indent">
pub mod fruit_crate {
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        list: Vec&lt;Fruit&gt;,
        total_mass: u32
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{list: Vec::new(), total_mass: 0}
        }
        pub fn push(&amp;mut self, kind: &amp;str, mass: u32) {
            self.list.push(Fruit{kind: kind.to_string(), mass});
            self.total_mass += mass;
        }
        pub fn total_mass(&amp;self) -&gt; u32 {self.total_mass}
        pub fn list(&amp;self) -> &amp;Vec&lt;Fruit&gt; {&amp;self.list}
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    println!("Die Obstkiste wiegt {}g.",fc.total_mass());
}
</pre>

<p>In Rust gestaltet sich dazu nun noch eine kleine technische
Schwierigkeit. Nämlich wird mit dem Methodenaufruf <code>list</code>
die gesamte Datenstruktur ausgeborgt. Gäbe es noch eine frei
beschreibbare Komponente, könnte man auf diese während des ausborgens
nicht mehr zugreifen. Als Beispiel sei der Obstkiste eine boolesche
Variable hinzugefügt, die angibt ob die Kiste geöffnet ist.

<pre class="rust indent">
pub mod fruit_crate {
    #[derive(Debug)]
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        list: Vec&lt;Fruit&gt;,
        total_mass: u32,
        pub open: bool
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{list: Vec::new(), total_mass: 0, open: true}
        }
        /* Der Rest wie zuvor */
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    let a = fc.list();
    fc.open = false;
    println!("{:?}",a);
}
</pre>

<p>Der Kompiler würgt das ab, da <code>open</code> nicht überschrieben
werden kann während <code>fc</code> ausgeborgt ist. Es gibt nun
zwei Ansätze, wie sich dieses Problem lösen ließe.

<p>Natürlich ließe sich hier auch <code>Cell&lt;bool&gt;</code> benutzen.
Für allgemeineres müsste man dann aber <code>RefCell</code> heranziehen,
was weniger effizient ist.

<p>Der erste Ansatz besteht darin, das Ausborgen mit einer Methode
aufzuteilen. Hierbei werden Teil-borrows als Tupel oder Struktur
zurückgeben. Zu <code>FruitCrate</code> müssen wir lediglich die
folgende Methode hinzufügen:

<pre class="rust indent">
pub fn borrow_parts(&amp;mut self) -&gt; (&amp;mut bool, &amp;Vec&lt;Fruit&gt;) {
    (&amp;mut self.open, &amp;self.list)
}
</pre>

<p>So wird es vom Compiler akzeptiert:
<pre class="rust indent">
fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    let (open,list) = fc.borrow_parts();
    *open = false;
    println!("{:?}",list);
}
</pre>

<p>Beim zweiten Ansatz hüllt man die schreibgeschützten
Komponenten in eine Struktur <code>ReadOnly</code> ein.

<pre class="rust indent">
pub mod fruit_crate {
    pub struct ReadOnly&lt;T&gt;(T);

    impl&lt;T&gt; std::ops::Deref for ReadOnly&lt;T&gt; {
        type Target = T;
        fn deref(&amp;self) -&gt; &amp;T {&amp;self.0}
    }

    #[derive(Debug)]
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        pub list: ReadOnly&lt;Vec&lt;Fruit&gt;&gt;,
        pub total_mass: ReadOnly&lt;u32&gt;,
        pub open: bool
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{
                list: ReadOnly(Vec::new()),
                total_mass: ReadOnly(0),
                open: true
            }
        }
        pub fn push(&amp;mut self, kind: &amp;str, mass: u32) {
            self.list.0.push(Fruit{kind: kind.to_string(), mass});
            self.total_mass.0 += mass;
        }
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    let list = &amp;*fc.list;
    fc.open = false;
    println!("{:?}",list);
}
</pre>

<p>Da <code>ReadOnly</code> nicht aus dem Modul heraus genommen
werden kann, definiert man dafür am besten ein Makro:
<pre class="rust indent">
macro_rules! define_read_only {
    () =&gt; {
        pub struct ReadOnly&lt;T&gt;(T);
        
        impl&lt;T&gt; std::ops::Deref for ReadOnly&lt;T&gt; {
            type Target = T;
            fn deref(&amp;self) -&gt; &amp;T {&amp;self.0}
        }
    }
}
</pre>

<h2 id="Contracts">Vertragsbasierte Programmierung</h2>

<p>Bei der vertragsbasierten Programmierung, engl. contract programming,
sichern Laufzeitprüfungen das korrekte Arbeiten von Algorithmen ab.
Die Prüfungen haben eine strukturierte Form, sie kommen als Prüfung von
<i>Vorbedingungen</i>, <i>Nachbedingungen</i> und <i>Invarianten</i>
vor.

<p>Nehmen wir als Beispiel eine Funktion <code>zip</code>, welche
zwei Arrays <code>a,b</code> entgegennimmt und ein Array
von Paaren <code>(a<sub>k</sub>,b<sub>k</sub>)</code> zurückgibt.
Die Vorbedingung ist, dass beide Arrays die gleiche Länge haben
müssen, die Nachbedingung dass das Ergebnis auch diese Länge besitzt.

<p>Die Vor- und Nachbedingung kann man mittels assert-Anweisungen
formulieren.

<pre class="rust indent">
fn zip&lt;X: Clone, Y: Clone&gt;(a: &amp;[X], b: &amp;[Y]) -&gt; Vec&lt;(X,Y)&gt; {
    let n = a.len();
    
    // Precondition
    assert!(n == b.len());

    let mut v = Vec::with_capacity(n);
    for k in 0..n {
        v.push((a[k].clone(),b[k].clone()));
    }

    // Postcondition
    assert!(n == v.len());

    return v;
}

fn main() {
    let a = vec![1,2,3,4];
    let b = vec!["a","b","c","d"];
    let c = zip(&amp;a,&amp;b);
    println!("{:?}",c);
}
</pre>

<p>Ein Nachteil bei dieser Formulierung von Nachbedingungen ist,
dass return-Anweisungen in einer solchen Funktion nicht erlaubt sind.
Um dies zu erzwingen bräuchte man ein zusätzliches Werkzeug, welches
sich als prozedurales Makro formulieren ließe.

</body>
</html>

