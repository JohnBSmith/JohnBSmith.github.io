<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Typsicherheit</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Validierung">Validierung</a>
<li><a href="#ADT">Abstrakte Datentypen</a>
<li><a href="#Read-only">Schreibgeschützte Komponenten</a>
<li><a href="#Typzustaende">Typzustände</a>
<li><a href="#Einheiten">Einheiten</a>
<li><a href="#Contracts">Vertragsbasierte Programmierung</a>
</ol>

<h2 id="Validierung">Validierung</h2>

<p>Angenommen, wir erhalten über eine Schnittstelle eine
Zeichenkette die aus genau vier dezimalen Ziffern bestehen soll.
Diese Zeichenkette wird später in eine Zahl umgewandelt und für
einen Datenbankindex verwendet. Nun ist es aber so, dass diese
Zeichenkette von einem Client zu einem Server kommt. Das Client-Programm
übergibt jedoch eine Zeichenkette die eine falsche Zahl von Ziffern
besitzt oder Buchstaben enthält. Dies führt dazu dass das Datenbanksystem
in einen invaliden Zustand gerät und ein über Monate lang unbemerktes
Datenleck entsteht.

<p>Das Problem hier ist, dass einer der Programmierer
vielleicht nicht gewusst hat, dass die Daten vor der Benutzung hätten
validiert werden müssen.

<p>In Rust kann eine solche Validierung vom Typsystem erzwungen
werden, indem für die validierten Daten ein eigener Datentyp definiert
wird, nennen wir ihn <code>Datenbankindex</code>. Die Idee dabei ist,
dass erstens die betroffenen Unterprogramme nur Werte vom Typ
<code>Datenbankindex</code> entgegennehmen und zweitens
ein solcher Wert nur über eine Validierung erzeugt werden kann.

<pre class="rust indent">
mod db{
    #[derive(Clone,Copy)]
    pub struct Datenbankindex{
        index: u16
    }
    fn is_digit(c: char) -&gt; bool {
        48&lt;=(c as u32) &amp;&amp; (c as u32)&lt;=57
    }
    impl Datenbankindex{
        pub fn new(s: &amp;str) -&gt; Option&lt;Self&gt; {
            let a: Vec&lt;char&gt; = s.chars().collect();
            if a.len()==4 &amp;&amp;
                is_digit(a[0]) &amp;&amp; is_digit(a[1]) &amp;&amp;
                is_digit(a[2]) &amp;&amp; is_digit(a[3])
            {
                return Some(Datenbankindex{
                    index: s.parse::&lt;u16&gt;().unwrap()
                });
            }else{
                return None;
            }
        }
        pub fn get(&amp;self) -&gt; u16 {
            self.index
        }
    }
}

use std::io;
use std::io::Write;

fn main(){
    loop {
        print!("Index: ");
        if io::stdout().flush().is_err() {println!();}
        let mut s = String::new();
        io::stdin().read_line(&amp;mut s).unwrap();
        s.pop();
        match db::Datenbankindex::new(&amp;s) {
            Some(index) =&gt; {
                DatenbankZugriff(index)
            },
            None =&gt; {
                println!("Fehler: ungültiger Datenbankindex.");
                continue;
            }
        };
    }
}

#[allow(non_snake_case)]
fn DatenbankZugriff(index: db::Datenbankindex){
    println!("Validierter Index: {}",index.get());
}
</pre>

<p>Hierzu ist zu bemerken, dass das Feld <code>index</code>
von <code>Datenbankindex</code> privat ist. Daher besteht der Zugang
zu Werten vom Typ <code>Datenbankindex</code> nur über die öffentlichen
Funktionen <code>new</code> und <code>get</code>.

<p>Die Idee ist nun, die Steuerung der Datenbank von ihrem Kernel zu
abstrahieren. Bei der Ansteuerung der Datenbank sollte es nie
zu einem invaliden Zustand kommen. Lediglich im Kernel besteht Zugriff
auf die private Funktionalität, bei der das System auch zerstört
werden kann, wenn man nicht vorsichtig ist.

<p>In Verbindung hiermit kann gesagt werden, dass die Maxime eine
möglichst strenge Typisierung der gesamten Datenverarbeitung sein
sollte.

<h2 id="ADT">Abstrakte Datentypen</h2>
<p>Ein abstrakter Datentyp, kurz ADT, ist ein Datentyp mit Operationen,
bei dem die interne Struktur und die interne Implementation der
Operationen vor der Öffentlichkeit verschwiegen wird. Bei einem
abstrakten Datentyp kann es sich um einen einfachen Datentyp oder
auch um eine komplizierte Datenstruktur handeln. Wichtig ist nur,
dass nur solche Operationen öffentlich sind, die eine Schnittstelle
zur Außenwelt repräsentieren.

<p>Es ist möglich dass ein abstrakter Datentyp eine vollkommen
typsichere Schnittstelle besitzt, obwohl dem bei der internen
Implementation nicht so ist. Man spricht von einer
<i>sicheren Kapselung</i> oder <i>sicheren Abstraktion</i>.

<p>Rust bietet die Mittel zur Darstellung von abstrakten Datentypen,
indem Variablen und Funktionen per Vorgabe zunächst privat sind.
Möchte man etwas zur öffentlichen Schnittstelle hinzufügen, so muss es
mit dem Schlüsselwort <code>pub</code> als <i>public</i> deklariert werden.

<p>Rust bietet außerdem Zero-Cost-Abstractions, die eine
Spezialisierung von allgemeinen abstrakten Datentypen zu spezielleren
ermöglichen, ohne dass es dabei zu Laufzeiteinbußen kommt.
Zur Umsetzung wird die Inline-Ersetzung von Funktionsaufrufen genutzt.

<p>Als einfachstes Beispiel soll ein Stapelspeicher formuliert
werden, der nur die Operationen <code>push</code> und <code>pop</code>
unterstützt.

<pre class="rust indent">
mod stack {
    pub struct Stack&lt;T&gt; {
        v: Vec&lt;T&gt;
    }
    impl&lt;T&gt; Stack&lt;T&gt; {
        pub fn new() -&gt; Self {
            Stack{v: Vec::new()}
        }
        pub fn push(&amp;mut self, x: T) {
            self.v.push(x);
        }
        pub fn pop(&amp;mut self) -&gt; T {
            match self.v.pop() {Some(x)=&gt;x, None=&gt;panic!()}
        }
    }
}

use stack::Stack;

fn main() {
    let mut a: Stack&lt;i32&gt; = Stack::new();
    a.push(1);
    a.push(2);
    println!("{}",a.pop());
    println!("{}",a.pop());
}
</pre>

<p>Der Konstruktor <code>new</code> und die Methoden
<code>push</code> und <code>pop</code> können mit
<code>#[inline(always)]</code> annotiert werden, um Inline-Ersetzung
zu erzwingen. Die Funktionen sind aber so kurz, dass der Compiler
das in aller Wahrscheinlichkeit automatisch macht, sofern die
Optimierungen eingeschaltet werden.

<p>Das Konzept der Schnittstelle lässt sich aber auch noch
schärfer umsetzen. Spezifiziert man die Schnittstelle durch einen
Trait, dann lassen sich abstrakte Programme schreiben,
welche nur noch auf die Schnittstelle zugreifen, aber nicht
mehr auf konkrete Datentypen.

<pre class="rust indent">
mod stack {
    pub trait Stack&lt;T&gt; {
        fn new() -&gt; Self;
        fn push(&amp;mut self, x: T);
        fn pop(&amp;mut self) -&gt; T;
    }

    pub struct VecStack&lt;T&gt; {
        v: Vec&lt;T&gt;
    }
    impl&lt;T&gt; Stack&lt;T&gt; for VecStack&lt;T&gt; {
        fn new() -&gt; Self {
            VecStack{v: Vec::new()}
        }
        fn push(&amp;mut self, x: T) {
            self.v.push(x);
        }
        fn pop(&amp;mut self) -&gt; T {
            match self.v.pop() {Some(x)=&gt;x, None=&gt;panic!()}
        }
    }
}

use stack::{Stack,VecStack};

fn routine&lt;S: Stack&lt;i32&gt;&gt;() {
    let mut a: S = S::new();
    a.push(1);
    a.push(2);
    println!("{}",a.pop());
    println!("{}",a.pop());
}

fn main() {
    routine::&lt;VecStack&lt;i32&gt;&gt;();
}
</pre>

<h2 id="Read-only">Schreibgeschützte Komponenten</h2>

<p>Oft möchte man bei Datenstrukturen von außen nur Lesezugriff
auf Komponenten zulassen. Ein solcher Schreibschutz gehört neben
Privatheit zum Konzept der Kapselung. Würde man eine Schnittstelle
zulassen, die Manipulation interner Variablen erlaubt, ließe sich damit
die Integrität der Datenstruktur zerstören. Mit dem Schreibschutz
können wir eine konforme Benutzung der Datenstruktur erzwingen.

<p>Als Beispiel wählen wir eine Datenstruktur, welche eine Liste von
Obst in verschiedenen Sorten und ihr Gesamtgewicht speichert. Sowohl
die Liste als auch das Gesamtgewicht müssen von außen schreibgeschützt
sein.

<p>Der Grundaufbau der Obstkiste sieht so aus:

<pre class="rust indent">
struct Fruit {kind: String, weight: u32}
struct FruitCrate {list: Vec&lt;Fruit&gt;, total_weight: u32}
</pre>

<p>Die Zahlen speichern sinnvollerweise die Masse in Gramm.
Die Datenstruktur wird nun eingekapselt. Die problematischen
Komponenten &ndash; das sind hier sämtliche &ndash; lassen wir
privat. Ausgelesen werden die Komponenten stattdessen mit Methoden,
wobei man der Methode auch den gleichen Bezeichner wie der
Komponente geben kann.

<pre class="rust indent">
pub mod fruit_crate {
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        list: Vec&lt;Fruit&gt;,
        total_mass: u32
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{list: Vec::new(), total_mass: 0}
        }
        pub fn push(&amp;mut self, kind: &amp;str, mass: u32) {
            self.list.push(Fruit{kind: kind.to_string(), mass});
            self.total_mass += mass;
        }
        pub fn total_mass(&amp;self) -&gt; u32 {self.total_mass}
        pub fn list(&amp;self) -> &amp;Vec&lt;Fruit&gt; {&amp;self.list}
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    println!("Die Obstkiste wiegt {}g.",fc.total_mass());
}
</pre>

<p>In Rust gestaltet sich dazu nun noch eine kleine technische
Schwierigkeit. Nämlich wird mit dem Methodenaufruf <code>list</code>
die gesamte Datenstruktur ausgeborgt. Gäbe es noch eine frei
beschreibbare Komponente, könnte man auf diese während des Ausborgens
nicht mehr zugreifen. Als Beispiel sei der Obstkiste eine boolesche
Variable hinzugefügt, die angibt ob die Kiste geöffnet ist.

<pre class="rust indent">
pub mod fruit_crate {
    #[derive(Debug)]
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        list: Vec&lt;Fruit&gt;,
        total_mass: u32,
        pub open: bool
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{list: Vec::new(), total_mass: 0, open: true}
        }
        /* Der Rest wie zuvor */
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    let a = fc.list();
    fc.open = false;
    println!("{:?}",a);
}
</pre>

<p>Der Compiler würgt das ab, da <code>open</code> nicht überschrieben
werden kann während <code>fc</code> ausgeborgt ist. Es gibt nun
zwei Ansätze, wie sich dieses Problem lösen ließe.

<p>Natürlich ließe sich hier auch <code>Cell&lt;bool&gt;</code> benutzen.
Für allgemeineres müsste man dann aber <code>RefCell</code> heranziehen,
was weniger effizient ist.

<p>Der erste Ansatz besteht darin, das Ausborgen mit einer Methode
aufzuteilen. Hierbei werden Teil-borrows als Tupel oder Struktur
zurückgeben. Zu <code>FruitCrate</code> müssen wir lediglich die
folgende Methode hinzufügen:

<pre class="rust indent">
pub fn borrow_parts(&amp;mut self) -&gt; (&amp;mut bool, &amp;Vec&lt;Fruit&gt;) {
    (&amp;mut self.open, &amp;self.list)
}
</pre>

<p>So wird es vom Compiler akzeptiert:
<pre class="rust indent">
fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    let (open,list) = fc.borrow_parts();
    *open = false;
    println!("{:?}",list);
}
</pre>

<p>Beim zweiten Ansatz hüllt man die schreibgeschützten
Komponenten in eine Struktur <code>ReadOnly</code> ein.

<pre class="rust indent">
pub mod fruit_crate {
    pub struct ReadOnly&lt;T&gt;(T);

    impl&lt;T&gt; std::ops::Deref for ReadOnly&lt;T&gt; {
        type Target = T;
        fn deref(&amp;self) -&gt; &amp;T {&amp;self.0}
    }

    #[derive(Debug)]
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        pub list: ReadOnly&lt;Vec&lt;Fruit&gt;&gt;,
        pub total_mass: ReadOnly&lt;u32&gt;,
        pub open: bool
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{
                list: ReadOnly(Vec::new()),
                total_mass: ReadOnly(0),
                open: true
            }
        }
        pub fn push(&amp;mut self, kind: &amp;str, mass: u32) {
            self.list.0.push(Fruit{kind: kind.to_string(), mass});
            self.total_mass.0 += mass;
        }
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel",1000);
    fc.push("Birnen",1000);
    let list = &amp;*fc.list;
    fc.open = false;
    println!("{:?}",list);
}
</pre>

<p>Da <code>ReadOnly</code> nicht aus dem Modul heraus genommen
werden kann, definiert man dafür am besten ein Makro:
<pre class="rust indent">
macro_rules! define_read_only {
    () =&gt; {
        pub struct ReadOnly&lt;T&gt;(T);
        
        impl&lt;T&gt; std::ops::Deref for ReadOnly&lt;T&gt; {
            type Target = T;
            fn deref(&amp;self) -&gt; &amp;T {&amp;self.0}
        }
    }
}
</pre>

<h2 id="Typzustaende">Typzustände</h2>

<p>Manchmal müssen Methoden in einer bestimmten Reihenfolge aufgerufen
werden. Dass die Reihenfolge schon zur Kompilierzeit bekannt ist,
weist darauf hin, dass sich ein entsprechender Formalismus mittels
des Typsystems formulieren lassen müsste. Man spricht von
<i>Typzuständen</i>, engl. <i>typestates</i>. Rust bietet mit seinem
affinen Typsystem (Move-Semantik) die Möglichkeit, Typzustände bis
zu einem gewissen Ausmaß zu modellieren.

<p>Ohne affines Typsystem sind Typzustände nicht möglich, da die
fehlende Move-Semantik dazu führt, dass sich Variablen noch nach dem
Methodenaufruf benutzen lassen bis sie out of scope sind. Der
springende Punkt ist aber, dass die Methode die Variable »aufessen«
soll.

<p>Ein einfaches Beispiel. Angenommen, es gibt einen Typ <code>A</code>
mit den Methoden <code>f1</code>, <code>f2a</code>, <code>f2b</code>
und <code>f3</code>. Wir würden nun gern haben, dass <code>f2x</code>
nur nach <code>f1</code> aufgerufen werden kann und <code>f3</code>
nur nach <code>f2x</code>.

<p>Zur Umsetzung werden drei Typzustände <code>A</code>, <code>A2</code>
und <code>A3</code> definiert. Die Daten der Typzustände bleiben
privat, damit sich die Objekte ausschließlich über Methoden konstruieren
lassen. Jeder Typzustand bekommt jeweils seine erlaubten Methoden.

<pre class="rust indent">
pub mod a_state {
    pub struct A{data: ()}
    impl A {
        pub fn new() -&gt; A {A{data: ()}}
        pub fn f1(self) -&gt; A2 {A2{data: self.data}}
    }
    
    pub struct A2{data: ()}
    impl A2 {
        pub fn f2a(self) -&gt; A3 {A3{data: self.data}}
        pub fn f2b(self) -&gt; A3 {A3{data: self.data}}
    }
    
    pub struct A3{data: ()}
    impl A3 {
        pub fn f3(self) {let _ = self.data;}
    }
}

use crate::a_state::A;

fn main() {
    let a = A::new();
    let a = a.f1();
    let a = a.f2a();
    a.f3();
}
</pre>

<p>Als Nebeneffekt sind hier syntaktisch angenehme Methodenketten
erlaubt:

<pre class="rust indent">
A::new().f1().f2a().f3();
</pre>

<p>Dass jeder Typzustand ein eigenständiger Datentyp ist, kann
unpraktisch sein, etwa wenn Methoden für einige oder alle Typzustände
gültig sein sollen. Tatsächlich können wir die Typzustände
zusammenfassen, indem der Zustand als Typparameter kodiert wird.
Die Zustände sollen hierbei keinerlei Daten tragen, weswegen wir
<code>PhantomData</code> heranziehen.

<pre class="rust indent">
pub mod a_state {
    use std::marker::PhantomData as Ph;

    pub trait State {}
    pub struct A1; impl State for A1 {}
    pub struct A2; impl State for A2 {}
    pub struct A3; impl State for A3 {}

    pub struct A&lt;S: State&gt; {
        data: (), marker: Ph&lt;S&gt;
    }
    pub fn new_a() -&gt; A&lt;A1&gt; {A{data: (), marker: Ph}}
    impl A&lt;A1&gt; {
        pub fn f1(self) -&gt; A&lt;A2&gt; {A{data: self.data, marker: Ph}}
    }
    impl A&lt;A2&gt; {
        pub fn f2a(self) -&gt; A&lt;A3&gt; {A{data: self.data, marker: Ph}}
        pub fn f2b(self) -&gt; A&lt;A3&gt; {A{data: self.data, marker: Ph}}
    }
    impl A&lt;A3&gt; {
        pub fn f3(self) {}
    }
}

use a_state::new_a;

fn main() {
    new_a().f1().f2a().f3();
}
</pre>

<h2 id="Einheiten">Einheiten</h2>

<p>Einheiten beugen bei technischen oder physikalischen Rechnungen
gegen Missverständnisse vor. Zur Schaffung einer erhöhten Sicherheit
würden wir dieses Konzept nun auch gerne in die Programmierung
einbringen.

<p>Zunächst ließe sich mehr Klarheit schaffen durch Definition der
Einheiten als Konstanten:

<pre class="rust indent">
pub mod unit {
    #![allow(non_upper_case_globals)]
    pub const km: f64 = 1000.0;
    pub const  m: f64 = 1.0;
    pub const cm: f64 = 0.01;
    pub const mm: f64 = 0.001;
}

use unit::{cm,mm};
use std::f64::consts::PI;

fn circumference(radius: f64) -&gt; f64 {
    2.0*PI*radius
}

fn main() {
    let r = 4.0*cm + 2.0*mm;
    println!("{} m",circumference(r));
}
</pre>

<p>Hierbei verbleibt aber das Problem, dass sich Größen
verschiedener Einheit beliebig addieren und multiplizieren lassen.
Das würde man jedoch gerne auf erlaubte Operationen beschränken.
Hierzu muss für Größen offenbar ein Datentyp definiert werden.

<p>Man könnte nun für alle möglichen Einheiten einen separaten
Datentyp definieren. Wesentlich günstiger ist aber die Definition
der Dimension als Datentyp. Die Einheiten normalisieren den Zahlenwert
dann bloß, dergestalt dass dieser nur in kohärenter Einheit
gespeichert wird.

<p>Weiterhin könnte man nun für alle möglichen Größenarten einen
separaten Datentyp definieren bzw. diese mit ihrer Dimension
zusammenfallen lassen. Jedoch ließen sich die Implementationen
wiederkehrender Operationen dann nicht faktorisieren. Daher macht
man die Dimension am besten zu einem Typargument der Größe. Da die
Dimension lediglich zur Kompilierzeit existieren soll, nutzt man
<code>PhantomData</code>. Eine Größe besteht nun aus einem Zahlenwert
<code>value</code> (in kohärenter Einheit) und einer dazugehörigen
Dimension <code>dim</code>.

<p>Wir gehen wie erläutert vor und definieren regelkonform die
Multiplikation einer Zahl mit einer Größe und die Addition von zwei
Größen gleicher Dimension. Die Einheiten modellieren wir einfach
als konstante Größen:

<pre class="rust indent">
pub mod quantities {
    use std::marker::PhantomData as Ph;
    use std::ops::{Mul,Add};
    use std::fmt;

    pub trait Dimension {}

    #[derive(Clone,Copy)]
    pub struct Quantity&lt;D: Dimension&gt; {
        value: f64, dim: Ph&lt;D&gt;
    }
    impl&lt;D: Dimension&gt; Mul&lt;Quantity&lt;D&gt;&gt; for f64 {
        type Output = Quantity&lt;D&gt;;
        fn mul(self, y: Quantity&lt;D&gt;) -&gt; Quantity&lt;D&gt; {
            Quantity{value: self*y.value, dim: Ph}
        }
    }
    impl&lt;D: Dimension&gt; Add&lt;Quantity&lt;D&gt;&gt; for Quantity&lt;D&gt; {
        type Output = Quantity&lt;D&gt;;
        fn add(self, y: Quantity&lt;D&gt;) -&gt; Quantity&lt;D&gt; {
            Quantity{value: self.value+y.value, dim: Ph}
        }
    }
    
    pub struct Length;
    impl Dimension for Length {}

    impl fmt::Display for Quantity&lt;Length&gt; {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "{} m", self.value)
        }
    }

    pub mod unit {
        #![allow(non_upper_case_globals)]
        use crate::quantities::{Quantity,Length};
        use std::marker::PhantomData as Ph;
        pub const km: Quantity&lt;Length&gt; = Quantity{value: 1.000, dim: Ph};
        pub const  m: Quantity&lt;Length&gt; = Quantity{value: 1.0, dim: Ph};
        pub const cm: Quantity&lt;Length&gt; = Quantity{value: 0.01, dim: Ph};
        pub const mm: Quantity&lt;Length&gt; = Quantity{value: 0.001, dim: Ph};
    }
}

use quantities::{Quantity,Length};
use quantities::unit::{cm,mm};
use std::f64::consts::PI;

fn circumference(radius: Quantity&lt;Length&gt;) -&gt; Quantity&lt;Length&gt; {
    2.0*PI*radius
}

fn main() {
    let r = 4.0*cm+2.0*mm;
    println!("{}",circumference(r));
}
</pre>


<h2 id="Contracts">Vertragsbasierte Programmierung</h2>

<p>Bei der vertragsbasierten Programmierung, engl. contract programming,
sichern Laufzeitprüfungen das korrekte Arbeiten von Algorithmen ab.
Die Prüfungen haben eine strukturierte Form, sie kommen als Prüfung von
<i>Vorbedingungen</i>, <i>Nachbedingungen</i> und <i>Invarianten</i>
vor.

<p>Nehmen wir als Beispiel eine Funktion <code>zip</code>, welche
zwei Arrays <code>a,b</code> entgegennimmt und ein Array
von Paaren <code>(a<sub>k</sub>,b<sub>k</sub>)</code> zurückgibt.
Die Vorbedingung ist, dass beide Arrays die gleiche Länge haben
müssen, die Nachbedingung dass das Ergebnis auch diese Länge besitzt.

<p>Die Vor- und Nachbedingung kann man mittels assert-Anweisungen
formulieren.

<pre class="rust indent">
fn zip&lt;X: Clone, Y: Clone&gt;(a: &amp;[X], b: &amp;[Y]) -&gt; Vec&lt;(X,Y)&gt; {
    let n = a.len();
    
    // Precondition
    assert!(n == b.len(), "zip(a,b): a.len() == b.len()");

    let mut v = Vec::with_capacity(n);
    for k in 0..n {
        v.push((a[k].clone(),b[k].clone()));
    }

    // Postcondition
    assert!(n == v.len());

    return v;
}

fn main() {
    let a = vec![1,2,3,4];
    let b = vec!["a","b","c","d"];
    let c = zip(&amp;a,&amp;b);
    println!("{:?}",c);
}
</pre>

<p>Ein Nachteil bei dieser Formulierung von Nachbedingungen ist,
dass return-Anweisungen in einer solchen Funktion nicht erlaubt sind.
Um dies zu erzwingen bräuchte man ein zusätzliches Werkzeug, welches
sich als prozedurales Makro formulieren ließe.

</body>
</html>

