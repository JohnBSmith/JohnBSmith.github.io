<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Zeichenketten</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Zeichen">Zeichen</a>
<li><a href="#Puffer">Puffer</a>
<li><a href="#Formatierung">Formatierung mit Schablonen</a>
<li><a href="#Komplexität">Eine gewisse Komplexität</a>
</ol>

<h2 id="Zeichen">Zeichen</h3>

<p>In Rust gibt es folgende Typen für einzelne Zeichen:
<table class="bt indent">
<tr>
<th>Typ
<th>Erklärung
<tr>
<td><code>u8</code>
<td>ein Byte
<tr>
<td><code>u16</code>
<td>ein UTF-16-Zeichen
<tr>
<td><code>char</code>
<td>ein UTF-32-Zeichen
</table>

<p>Ein UTF-32-Zeichen kann über einen expliziten Typcast in eine blanke
32-Bit-Zahl umgewandelt werden und umgekehrt:
<pre class="rust indent">
let x = 'a' as u32;
let c = 97 as char;
</pre>

<p>Warum es für ASCII und UTF-16 keine eigenen Datentypen gibt,
ist auch für mich unklar. Man kann sich die abstrakten Datentypen
aber grundsätzlich mit <code>struct</code> selbst definieren, wobei
inline-Funktionen eine Zero-Cost-Abstraktion ermöglichen.

<h2 id="Puffer">Puffer</h2>

<p>Zeichenketten sind in Rust dynamisch und lassen sich als
Puffer benutzen. Ein Puffer ist eine dynamische Zeichenkette,
an die beliebig viele Zeichenketten angehängt werden können.
<pre class="rust indent">
fn main() {
    let mut s = "".to_string();
    s += "Hier";
    s += " steht";
    s += " ein";
    s += " Text.";
    println!("{}",s);
}
</pre>

<p>Es folgt ein Beispiel wo ein Puffer mit zwei dynamischen Ketten
gefüttert wird.
<pre class="rust indent">
fn main() {
    let s1 = "Text1\n".to_string();
    let s2 = "Text2\n".to_string();

    let mut s = "".to_string();
    s += &amp;s1;
    s += &amp;s2;
    println!("{}",s);
}
</pre>

<p>Die Borrows sind notwendig, weil <code>s1</code> und <code>s2</code>
bei diesen Operationen nicht ihren Besitz verlieren.

<p>Die Ketten können auch von Unterprogrammen erzeugt worden sein.
<pre class="rust indent">
fn p1() -> String {
    return "Text1\n".to_string();
}

fn p2() -> String {
    return "Text2\n".to_string();
}

fn main() {
    let mut s = "".to_string();
    s += &amp;p1();
    s += &amp;p2();
    println!("{}",s);
}
</pre>

<h2 id="Formatierung">Formatierung mit Schablonen</h2>

<h3>Mit Schablonen geht es am kürzesten</h3>
<p>Ein Paar von Zahlen in eine Zeichenkette umwandeln ließe
sich so bewerkstelligen:
<pre class="rust indent">
fn pair_to_string(x: i32, y: i32) -&gt; String {
    let mut buffer = String::new();
    buffer.push_str("(");
    buffer.push_str(&amp;x.to_string());
    buffer.push_str(", ");
    buffer.push_str(&amp;y.to_string());
    buffer.push_str(")");
    return buffer;
}

fn main() {
    println!("{}",pair_to_string(1,2));
}
</pre>

<p>Etwas weniger umständlich geht es auch so:
<pre class="rust indent">
fn pair_to_string(x: i32, y: i32) -&gt; String {
    ["(", &amp;x.to_string(), ", ", &amp;y.to_string(), ")"].join("")
}
</pre>

<p>Formatierung mit Schablonen bietet aber eine kurze und prägnante
Formulierung dieser Funktion:
<pre class="rust indent">
fn pair_to_string(x: i32, y: i32) -&gt; String {
    format!("({}, {})",x,y)
}
</pre>

<p>Man kann die Funktion auch gleich polymorph schreiben:
<pre class="rust indent">
fn pair_to_string&lt;X,Y&gt;(x: X, y: Y) -&gt; String
where X: std::fmt::Display, Y: std::fmt::Display
{
    format!("({}, {})",x,y)
}
</pre>

<p>Das Makro <code>format!</code> setzt Argumente in eine Schablone
ein. Die Paare von geschweiften Klammern werden durch die Argumente
ersetzt und die dadurch entstandene Zeichenkette zurückgegeben.
Das kennen wir schon vom Makro <code>println!</code>, mit dem einzigen
Unterschied, dass die Zeichenkette dort in der Konsole ausgegeben
wird.

<h3>Formatierung von Ganzzahlen</h3>
<p>Die Schablonen für die Darstellung von Zahlen in Binärsystem,
Dezimalsystem und Hexadezimalsystem sind
<code>{:b}</code>, <code>{:o}</code>, <code>{:x}</code>:
<pre class="rust indent">
fn bin(n: u32) -&gt; String {format!("0b{:b}",n)}
fn oct(n: u32) -&gt; String {format!("0o{:o}",n)}
fn hex(n: u32) -&gt; String {format!("0x{:x}",n)}
</pre>

<h3>Ausrichtung</h3>
<p>Man kann Text in Freiraum ausrichten. Beispiele für 10 Zeichen
Freiraum:
<pre class="rust indent">
println!("|{:10}|","Text");  // Text linksbündig ausrichten
println!("|{:&lt;10}|","Text"); // Text linksbündig ausrichten
println!("|{:&gt;10}|","Text"); // Text rechtsbündig ausrichten
println!("|{:^10}|","Text"); // Text zentriert ausrichten

println!("|{:.&lt;10}|","Text"); // Punkte anstelle von Leerzeichen
println!("|{:.&gt;10}|","Text"); // Punkte anstelle von Leerzeichen
println!("|{:.^10}|","Text"); // Punkte anstelle von Leerzeichen

println!("|{:10}|",360);  // Zahl rechtsbündig ausrichten
println!("|{:&lt;10}|",360); // Zahl linksbündig ausrichten
println!("|{:&gt;10}|",360); // Zahl rechtsbündig ausrichten

println!("|{:010}|",360); // Zahl mit führenden Nullen
println!("|{:010}|",-360); // Klappt auch für negative Zahlen
</pre>

<p>Man beachte: Die Standard-Ausrichtung von Text ist linksbündig,
die von Zahlen jedoch rechtsbündig. Das ist natürlich dem Umstand
geschuldet, dass wir Zahlen im Dezimalsystem in »Big-Endian«
aufschreiben.

<h2 id="Komplexität">Eine gewisse Komplexität</h3>

<p>An dieser Stelle muss einmal gesagt werden, dass Rust eine Programmiersprache
mit einer gewissen Komplexität ist. Der Zeitpunkt ist günstig, dies
einfach mal an den Datentypen für Zeichenketten zu verdeutlichen.
In einer einfachen Programmiersprache gibt es einen Datentyp für
Zeichenketten, in Rust kann man sie streng genommen nicht mehr an
der Hand abzählen. Das klingt jetzt zunächst abschreckend, wäre da
nicht das Prinzip der Orthogonalität.

<table class="bt">
<tr>
<th>Typ
<th>Erklärung
<tr>
<td><code>&amp;'static str</code>
<td>unveränderbare UTF-8-Kette, statisch in der Binärdatei
<tr>
<td><code>&amp;'a str</code>
<td>unveränderbare UTF-8-Kette mit Lebenszeit a
<tr>
<td><code>&amp;str</code>
<td>unveränderbare UTF-8-Kette
<tr>
<td><code>String</code>
<td>Besitz einer dynamischen UTF-8-Kette
<tr>
<td><code>&amp;String</code>
<td>Referenz auf eine unveränderbare dynamische UTF-8-Kette
<tr>
<td><code>&amp;mut String</code>
<td>Referenz auf eine veränderbare dynamische UTF-8-Kette
<tr>
<td><code>Box&lt;str&gt;</code>
<td>Besitz einer UTF-8-Kette fixer Länge
<tr>
<td><code>Rc&lt;str&gt;</code>
<td>gemeinschaftlicher Besitz unveränderbaren UTF-8-Kette
<tr>
<td><code>Rc&lt;RefCell&lt;String&gt;&gt;</code>
<td>gemeinschaftlicher Besitz einer dynamischen UTF-8-Kette
<tr>
<td><code>&amp;'static [char]</Code>
<td>unveränderbare UTF-32-Kette, statisch in der Binärdatei
<tr>
<td><code>&amp;[char]</Code>
<td>unveränderbare UTF-32-Kette
<tr>
<td><code>&amp;mut [char]</Code>
<td>veränderbare UTF-32-Kette fester Länge
<tr>
<td><code>Box&lt;[char]&gt;</Code>
<td>Besitz einer UTF-32-Kette fester Länge
<tr>
<td><code>Vec&lt;char&gt;</Code>
<td>Besitz einer dynamischen UTF-32-Kette
<tr>
<td><code>Rc&lt;[char]&gt;</code>
<td>gemeinschaftlicher Besitz, unveränderbar
<tr>
<td><code>Rc&lt;RefCell&lt;[char]&gt;&gt;</code>
<td>gemeinschaftlicher Besitz, veränderbar, feste Länge
<tr>
<td><code>Rc&lt;RefCell&lt;Vec&lt;char&gt;&gt;&gt;</code>
<td>gemeinschaftlicher Besitz einer dynamischen UTF-32-Kette
<tr>
<td><code>&amp;[u8]</code>
<td>unveränderbare Byte-Kette
<tr>
<td><code>&amp;mut [u8]</code>
<td>veränderbare Byte-Kette fester Länge
<tr>
<td><code>Vec&lt;u8&gt;</code>
<td>Besitz einer dynamischen Byte-Kette
<tr>
<td><code>&amp;[u16]</code>
<td>unveränderbare UTF-16-Kette
<tr>
<td><code>&amp;mut [u16]</code>
<td>veränderbare UTF-16-Kette fester Länge
<tr>
<td><code>Vec&lt;u16&gt;</code>
<td>Besitz einer dynamischen UTF-16-Kette
<tr>
<td><code>&amp;CStr</Code>
<td>unveränderbare nullterminierte Kette
<tr>
<td><code>CString</Code>
<td>Besitz einer nullterminierten dynamischen Kette
<tr>
<td><code>&amp;OsStr</code>
<td>unveränderbare Kette, von plattformabhängiger Gestalt
<tr>
<td><code>OsString</code>
<td>Besitz einer Kette von plattformabhängiger Gestalt
</table>

<p>Die Typen <code>&amp;mut str</code> und
<code>Rc&lt;RefCell&lt;str&gt;&gt;</code> dürfen nicht auf normale
Art verwendet werden, da UTF-8-Zeichenketten nicht allgemein
manipuliert werden können, ohne deren Länge zu ändern. Für solche
Aufgaben sollte der Typ <code>&amp;mut str</code> in den Typ
<code>&amp;mut [u8]</code> transmutiert werden. Bei der Transmutation
von <code>&amp;[u8]</code> nach <code>&amp;str</code>
muss man Vorsicht walten lassen, da das UTF-8 invalide sein könnte.
Hierfür ist die Funktion <code>from_utf8</code> vorgesehen, die
eine Überprüfung vornimmt. Man sollte diese Funktion auch bitte
benutzen, sofern man nicht Experte ist.

</body>
</html>

