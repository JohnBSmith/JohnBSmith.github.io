<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Trait-Objekte</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Laufzeit-Polymorphie">Laufzeit-Polymorphie</a>
  <ol>
  <li><a href="#Heterogene-Felder">Heterogene Felder</a>
  <li><a href="#Downcasts">Downcasts</a>
  </ol>
<li><a href="#Technik">Teschnische Aspekte</a>
</ol>

<h2 id="Laufzeit-Polymorphie">Laufzeit-Polymorphie</h2>

<h3 id="Heterogene-Felder">Heterogene Felder</h3>

<p>In dynamischen Programmiersprachen wie Python sind
Felder so wie alle Datenstrukturen heterogen.
Damit ist gemeint, dass jedes Feld-Element einen
unterschiedlichen Typ besitzen darf. Bei der schnellen Zusammenstellung
von kleineren Programmen kann diese Flexibilität ausgesprochen
praktisch sein. Für jemanden, der nur dynamische Sprachen gewohnt ist,
mag das ganz natürlich erscheinen, in Rust müssen wir eine solche
Funktionalität jedoch erst konstruieren.

<p>Man könnte nun darauf kommen, den Einwand vorzubringen dass
es mit den Tupeln schon heterogene Felder gäbe. Das ist zwar richtig,
führt aber am Ziel vorbei, weil zwei Tupel von unterschiedlichem
Typ sind, sobald die Element-Typen oder die Längen nicht mehr
übereinstimmen. Stattdessen wollen wir haben, dass zu einem Index
des gleichen Feldes Werte unterschiedlichen Typs gespeichert
werden können.

<h4>Realisierung mit Enumerationen</h4>

<p>Grundsätzlich wird Heterogenität durch Konstruktion von Element-Typen
erreicht, die mehrere Typen zusammenfassen. Dieser Ansatz erlaubt
es, die gewöhnlichen vorhandenen generischen Datenstrukturen
weiterhin zu benutzen.

<p>Ein Ansatz zur Zusammenfassung sind, wie schon bekannt, die
Enumerationen. Nachteilig ist hierbei jedoch, dass die in Frage
kommenden Element-Typen schon im Voraus bekannt sein müssen.

<pre class="rust ibox">
enum Object {
    Int(i32),
    String(String)
}

impl Object {
    fn to_string(&amp;self) -&gt; String {
        match self {
            Object::Int(x) =&gt; format!("{}", x),
            Object::String(x) =&gt; x.clone()
        }
    }
}

fn main() {
    let v = vec![
        Object::String(String::from("Boot")),
        Object::Int(12)
    ];
    for object in &amp;v {
        println!("{}", object.to_string());
    }
}
</pre>

<h4>Realisierung mit Trait-Objekten</h4>

<p>Was wir bräuchten, wäre eine Art Enumeration von allen beliebigen
Typen. Weil die Speichergröße von Typen unbeschränkt hoch sein kann,
muss dies ein Typ dynamischer Größe sein. Werte eines solchen Typs
sind nur über Zeiger ansprechbar.

<p>Zudem muss eine Schnittstelle der Operationen vorhanden sein,
die alle Typen gemeinsam haben. In diesem Beispiel ist das die
Methode <code>to_string</code>. Was <code>to_string</code> tut, ist
für jeden Typ unterschiedlich, nur die Schnittstelle bleibt gleich.
Um dies zu erreichen, bekommt jeder Typ zur Laufzeit eine eigene
Dispatch-Tabelle. Diese Tabelle enthält Funktionenzeiger
auf die gewünschten Operationen. Zum Zugriff auf die Tabelle bekommt
der Wert-Zeiger den Zeiger auf die Dispatch-Tabelle nachgestellt.

<p>Der Compiler macht dies alles automatisch für uns. Die Schnittstelle
wird als Trait definiert, nennen wir ihn <code>Object</code>.
Der durch das Schlüsselwort <code>dyn</code> eingeleitete Operator
ordnet dem Trait den zugehörigen opaken Typ mit dieser Schnittstelle
zu. Weil <code>dyn Object</code> wie gesagt ein Typ dynamischer
Größe ist, sind die Werte nur über Zeigertypen wie
<code>&amp;dyn Object</code> oder <code>Box&lt;dyn Object&gt;</code>
ansprechbar. Die Zeiger dieser Typen sind wie gesagt Paare von
Zeigern auf Wert und Dispatch-Tabelle.

<pre class="rust ibox">
trait Object {
    fn to_string(&amp;self) -&gt; String;
}

impl Object for i32 {
    fn to_string(&amp;self) -&gt; String {format!("{}",self)}
}

impl Object for String {
    fn to_string(&amp;self) -&gt; String {self.clone()}
}

fn main() {
    let v: Vec&lt;Box&lt;dyn Object&gt;&gt; = vec![
        Box::new(String::from("Boot")),
        Box::new(12)
    ];
    for object in &amp;v {
        println!("{}", object.to_string());
    }
}
</pre>

<h4>Gemischte Realisierung</h4>

<p>Es ist nicht besonders effizient, Werte von kleinen Typen wie
<code>i32</code> über Zeiger anzusprechen, geschweige denn, deren
Speicherplätze über <code>Box</code> auf dem Haldenspeicher zu
allozieren. Ein Ansatz zur Vermeidung von solchen Zeiger-Indirektionen
ist eine Zusammenfügung aus Enumeration und Trait-Objekt.
Das Trait-Objekt wird hierbei als residuale Variante der Enumeration
betrachtet.

<pre class="rust ibox">
trait Interface {
    fn to_string(&amp;self) -&gt; String;
}

enum Object {
    Int(i32),
    Ref(Box&lt;dyn Interface&gt;)
}

impl Object {
    fn to_string(&amp;self) -&gt; String {
         match self {
             Object::Int(x) =&gt; format!("{}", x),
             Object::Ref(ref x) =&gt; x.to_string()
         }
    }
}

impl Interface for String {
    fn to_string(&amp;self) -&gt; String {self.clone()}
}

fn main() {
    let v: Vec&lt;Object&gt; = vec![
        Object::Ref(Box::new(String::from("Boot"))),
        Object::Int(12)
    ];
    for object in &amp;v {
        println!("{}", object.to_string());
    }
}
</pre>

<h3 id="Downcasts">Downcasts</h3>

<h4>Der Trait Any</h4>

<p>Die Standardbibliothek stellt den Trait <code>Any</code> zur
Verfügung und implementiert diesen bereits für alle Typen. Genau
genommen liegt die Implementation nur für Typen ohne Lebenszeiten
außer <code>'static</code> vor, aber das ist jetzt erst einmal
nicht so wichtig. Der Zweck von <code>Any</code> ist die
Typ-Identifikation zur Laufzeit.

<p>Die opaken Zeigertypen wie <code>&amp;dyn Any</code>
und <code>Box&lt;dyn Any&gt;</code> dürfen daher auf Werte
beliebigen Typs zeigen. Man kann dies als sicheres Äquivalent
zu den aus der Programmiersprache&nbsp;C bekannten void-Zeigern
sehen. Anders als bei void-Zeigern gewährleistet die Typ-Identifikation
einen sicheren Downcast. Ein Downcast vermittelt, von einem allgemeinen
Typ wieder zu einem speziellen zu kommen. Man darf sich das als
Analogon zum Matching einer Enum-Variante vorstellen.

<pre class="rust ibox">
use std::any::Any;

struct Duck {name: String}

fn main() {
    let object: &amp;dyn Any = &amp;Duck{name: "Donald".into()};

    assert!(object.is::&lt;Duck&gt;());

    if let Some(duck) = object.downcast_ref::&lt;Duck&gt;() {
        println!("{} ist eine Ente.", duck.name);
    }
}
</pre>

<p>Naive Benutzung von <code>Any</code> befähigt uns zur Kaputtbrechung
des Typsystems. Zwar wird dadurch die Typsicherheit nicht beschädigt,
da die Typ-Identifikation diese erhält, allerdings ist das Resultat
ein zur Kompilierzeit teilweise  untypisiertes Programm. Bspw. könnten
wir das heterogene Feld letztendlich auch wie folgt konstruieren.

<pre class="rust ibox">
use std::any::Any;

fn object_to_string(x: &amp;dyn Any) -&gt; String {
    if let Some(s) = x.downcast_ref::&lt;String&gt;() {
        s.clone()
    } else if let Some(n) = x.downcast_ref::&lt;i32&gt;() {
        format!("{}", n)
    } else {
        unimplemented!()
    }
}

fn main() {
    let v: Vec&lt;Box&lt;dyn Any&gt;&gt; = vec![
        Box::new(String::from("Boot")),
        Box::new(12)
    ];
    for object in &amp;v {
        println!("{}", object_to_string(object.as_ref()));
    }
}
</pre>

<p>Die Konvertierung <code>object.as_ref()</code> ist hier aus einem
subtilen Grund notwendig. Nämlich besitzt
<code>Box&lt;dyn Any&gt;</code> selbst den <code>Any</code>-Trait.
Die Variable <code>object</code> bezieht sich auf diesen Typ,
und somit auch <code>x</code>. Folgendes Programm zeigt ausführlich
die Unterschiede:

<pre class="rust ibox">
use std::any::Any;

struct Duck {}

fn main() {
    let object: Box&lt;dyn Any&gt; = Box::new(Duck{});
    let object = &amp;object;

    let x: &amp;dyn Any = object;
    assert!(x.is::&lt;Box&lt;dyn Any&gt;&gt;());

    let x: &amp;dyn Any = object.as_ref();
    assert!(x.is::&lt;Duck&gt;());

    let x: &amp;dyn Any = &amp;**object;
    assert!(x.is::&lt;Duck&gt;());
}
</pre>

<h4>Benutzung von Any für Downcasts</h3>

<p>Einen Downcast möchte man nun für beliebige Trait-Objekte
zur Verfügung haben, nicht bloß für <code>dyn Any</code>.
Um dies zu erreichen, macht man sich genau den durch <code>Any</code>
zur Verfügung gestellten Mechanismus zunutze. Hierfür bedarf es
lediglich eines weiteren Upcasts nach <code>dyn Any</code>.
Der direkte Upcast von Trait-Objekt-Typ zu Trait-Objekt-Typ
ist allerdings nicht möglich. Um dennoch zum Ziel zu gelangen,
müssen wir einen kleinen Umweg gehen. Bei Trait-Methoden besitzt
das self-Argument jeweils den ursprünglichen Typ. Daher dürfen wir
eine Methode zum Upcast schreiben, nennen wir sie <code>as_any</code>.

<p>Dies wollen wir erreichen:
<div class="indent">
<img src="img/Downcast.png">
</div>

<p>Diesen Umweg müssen wir gehen:
<div class="indent">
<img src="img/as-any.png">
</div>

<p>Die Implementation gestaltet sich so:
<pre class="rust ibox">
use std::any::Any;

trait Object {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
}

struct Duck {name: String}

impl Object for Duck {
    fn as_any(&amp;self) -&gt; &amp;dyn Any {self}
}

fn main() {
    let object: &amp;dyn Object = &amp;Duck{name: "Donald".into()};

    assert!(object.as_any().is::&lt;Duck&gt;());

    if let Some(duck) = object.as_any().downcast_ref::&lt;Duck&gt;() {
        println!("{} ist eine Ente.", duck.name);
    }
}
</pre>

<p>Man kann <code>as_any</code> auch gleich für alle Typen mit Trait
<code>Any</code> implementieren:

<pre class="rust ibox">
use std::any::Any;

trait AsAny {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
}
impl&lt;T: Any&gt; AsAny for T {
    fn as_any(&amp;self) -&gt; &amp;dyn Any {self}
}

trait Object: AsAny {}

struct Duck {name: String}

impl Object for Duck {}

fn main() {
    let object: Box&lt;dyn Object&gt; = Box::new(Duck{
        name: "Donald".into()
    });

    assert!((&amp;*object).as_any().is::&lt;Duck&gt;());

    if let Some(duck) = (&amp;*object).as_any().downcast_ref::&lt;Duck&gt;() {
        println!("{} ist eine Ente.", duck.name);
    }
}
</pre>

<p>Hier muss man allerdings vorsichtig sein, denn nun ist zwingend
<code>(&amp;*object).as_any()</code> anstelle von <code>object.as_any()</code>
zu schreiben. Das muss man machen, weil <code>as_any</code>
als Nebeneffekt nun auch für <code>Box&lt;dyn Object&gt;</code>
vorliegt. Um diese Problematik aufzuzeigen, wurde <code>Box</code>
in das Beispiel eingebracht.

<p>Dieses Problem besteht aber nur, solange <code>AsAny</code>
eingebunden ist. Das wissen wir zu verhindern, indem
<code>AsAny</code> durch ein Modul verhüllt wird:

<pre class="rust ibox">
mod as_any {
    use std::any::Any;
    
    pub trait AsAny {
        fn as_any(&amp;self) -&gt; &amp;dyn Any;
    }
    impl&lt;T: Any&gt; AsAny for T {
        fn as_any(&amp;self) -&gt; &amp;dyn Any {self}
    }
}

trait Object: as_any::AsAny {}
</pre>


<h2 id="Technik">Technische Aspekte</h2>

<p>In Rust dient das Trait-System auch dem Zweck der Verwirklichung
von Laufzeit-Polymorphie. Zum Beispiel ist es möglich ein Feld
zu konstruieren, dessen Elemente jeweils einen unterschiedlichen
Typ besitzen.

<h3>Summentypen</h3>
<p>Zunächst kommt man auf die Idee eine solche
Konstruktion als Summentyp (<code>enum</code>)
zu verwirklichen:

<pre class="rust ibox">
enum Item {
    Int(i32),
    String(String)
}

impl Item {
    pub fn items_to_string(a: &amp;[Item]) -&gt; String {
        let mut s = "[".to_string();
        let mut first = true;
        for x in a {
            if first {first=false;} else {s.push_str(", ");}
            s.push_str(&amp;match *x {
                Item::Int(i)=&gt;format!("{}",i),
                Item::String(ref s)=&gt;format!("{}",s)
            });
        }
        s.push_str("]");
        return s;
    }
}

fn main() {
    let v = vec![
        Item::String("Boot".to_string()),
        Item::Int(12)
    ];
    println!("{}",Item::items_to_string(&amp;v));
}
</pre>

<p>Ein solcher Ansatz ist für große Felder mit vielen kleinen
Elementen effizienter als Konstruktionen mit Referenz-Strukturen.
Referenz-Strukturen müssen auf der Halde (oder auf einer Arena)
alloziert werden. Außerdem kann man die Überlegung aufstellen, ob die
Referenz-Strukturen durch die Indirektion zu fragmentiertem Speicher
zu schlechterer Cache-Lokalität führen können. Fragmentierung kann unter
bestimmten Voraussetzungen natürlich durch einen vernünftigen
Arena-Allokator vermieden werden.

<h3>Dispatch-Tabellen</h3>
<p>Eine allgemeine Polymorphie ergibt sich bei einfachen Summentypen
aber nicht, da die verfügbaren Varianten im Vorhinein bekannt sein
müssen. Zur Aufhebung dieser Beschränkung wird die Grundkonstruktion
der objektorientierten Programmierung herangezogen: eine
Dispatch-Tabelle, auch »Tabelle virtueller Methoden«
genannt.

<p>Jedes Objekt bekommt einen Zeiger auf eine Dispatch-Tabelle,
die eine untrennbare Verbindung von Methoden zu ihrem Objekt
ermöglicht. Jede Methode eines Objektes wird dann über diese
Dispatch-Tabelle aufgerufen. Die Polymorphie ergibt sich nun dadurch,
dass für jeden Datentyp eine separate Dispatch-Tabelle vorhanden ist.

<p>In Rust ist es nun so, dass der Zeiger auf die Dispatch-Tabelle
nicht in der Struktur des Objektes gespeichert ist, sondern dem
Objekt-Zeiger nachgestellt wird. Man spricht von einem
<i>Fat-Pointer</i>, das ist einfach ein Tupel aus den beiden Zeigern.

<p>Ein Datentyp <code>T</code> soll nun den Trait <code>A</code>
implementieren. Hierbei werden die (Methodenzeiger auf die)
Implementationen der Methoden von <code>A</code> zur Dispatch-Tabelle
von <code>T</code> hinzugefügt. Man kann auch von den »realen«
Implementationen der »virtuellen« Methoden von <code>A</code> sprechen,
womit ausgerückt wird dass der Trait <code>A</code> für sich allein
nur ein Interface ist.

<p>Bei einem Upcast von <code>T</code> zu <code>Box&lt;A&gt;</code>
wird automatisch ein Fat-Pointer erstellt. Bei <code>Box&lt;T&gt;</code>
ist das offensichtlich nicht notwendig, da die Methode hier bereits zur
Kompilierzeit angegeben werden kann. Ein Objekt vom Typ
<code>Box&lt;A&gt;</code> wird Trait-Objekt genannt. Auch die Borrows
vom Typ <code>&amp;A</code> und <code>&amp;mut A</code>
sind Fat-Pointer.

<p>Der polymorphe Ansatz gestaltet sich wie folgt:
<pre class="rust ibox">
trait Item {
    fn to_string(&amp;self) -&gt; String;
}

impl Item for i32 {
    fn to_string(&amp;self) -&gt; String {
        format!("{}",self)
    }
}

impl Item for String {
    fn to_string(&amp;self) -&gt; String {
        self.clone()
    }
}

fn items_to_string(a: &amp;[Box&lt;Item&gt;]) -&gt; String {
    let mut s = "[".to_string();
    let mut first = true;
    for x in a {
        if first {first=false;} else {s.push_str(", ");}
        s.push_str(&amp;x.to_string());
    }
    s.push_str("]");
    return s;
}

fn main() {
    let v: Vec&lt;Box&lt;Item&gt;&gt; = vec![
        Box::new("Boot".to_string()),
        Box::new(12)
    ];
    println!("{}",items_to_string(&amp;v));
}
</pre>
<p>Durch Hinzufügen von <code>impl Item for T</code> für eine
unbeschränkte Anzahl von weiteren, erst in speziellen Situationen
bekannten Typen <code>T</code> lässt die polymorphe Funktion
<code>items_to_string</code> für alle diese Typen nutzen.
Die Funktion <code>items_to_string</code> liegt dabei tatsächlich
polymorph im Maschinencode vor.


<p>Zufälligerweise enthält der Trait <code>ToString</code>
aus der Standardbibliothek bereits die Methode <code>to_string</code>,
einschließlich der Implementationen für die grundlegenden Datentypen.
Hätten wir <code>to_representation</code> genommen, die
Anführungszeichen um Zeichenketten zeigen soll, wäre das nicht der Fall.

<p>Rust besitzt <i>Trait-Vererbung</i>. Hierbei werden einfach die
Methoden aus anderen Traits automatisch zum Trait hinzugefügt.
Für jeden implementierten Typ wird dabei zur Kompilierzeit eine
Dispatch-Tabelle erzeugt, bei der automatisch die Methodenzeiger der
anderen Trait-Implementationen hinzugefügt werden. Die Angabe der Methode
<code>to_string</code> wird überflüssig:

<pre class="rust ibox">
use std::string::ToString;
trait Item: ToString {}
impl Item for i32 {}
impl Item for String {}
</pre>

<h3>Dispatch-Tabellen bei Vererbung</h3>

<p>Wir wollen uns kurz anschauen, wie eine mögliche Implementation
von Dispatch-Tabellen bei Vererbung aussehen kann.

<p>Angenommen wir haben die folgende Situation:
<pre class="rust ibox">
trait A {fn f(); fn g();}
trait B {fn h();}
trait S: A,B {fn s();}
</pre>

<p>Für jeden Typ <code>T</code> mit Trait-Implementationen zu
<code>A,B,S</code> werden nun die folgenden
Dispatch-Tabellen erzeugt:
<pre class="rust ibox">
(S for T).vtable = (T::f, T::g, T::h, T::s);
(A for T).vtable = (T::f, T::g);
(B for T).vtable = (T::h);
</pre>

<p>Da hier eine Einbettung vorliegt, können die Bestandteile
der größten Dispatch-Tabelle gemeinsam genutzt werden:
<pre class="rust ibox">
(S for T).vtable = (T::f, T::g, T::h, T::s);
(A for T).vtable = (S for T).vtable[0..2];
(B for T).vtable = (S for T).vtable[2..3];
</pre>

<p>Der Methodenaufruf geschieht nun wie folgt:
<pre class="rust ibox">
let x: Box&lt;S&gt; = Box::new(T);
let (pdata,pvtable): (&amp;T,&amp;(S for T)) = x;

x.f() == pvtable.0(),
x.g() == pvtable.1(),
x.h() == pvtable.2(),
x.s() == pvtable.3()
</pre>
<p>Bzw. wenn ein self-Argument vorliegt:
<pre class="rust ibox">
x.f() == pvtable.0(pdata)
</pre>

<h2>Fußnoten</h2>
<ol>
<li id="1">Siehe hierzu
  »<a href="https://stackoverflow.com/questions/33687447/how-to-get-a-struct-reference-from-a-boxed-trait"
  >How to get a struct reference from a boxed trait?</a>«. In: StackOverflow (rust, traits) (13. November 2015).
</ol>

</body>
</html>

