<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Elementare Datentypen</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Ganzzahlen">Ganzzahlen</a>
<li><a href="#Fliesskommazahlen">Fließkommazahlen</a>
<li><a href="#Typumwandlungen">Typumwandlungen</a>
</ol>

<h2 id="Ganzzahlen">Ganzzahlen</h2>

<p>Die vorzeichenlosen Ganzzahl-Datentypen in Rust sind
<code>u8</code>, <code>u16</code>, <code>u32</code> und <code>u64</code>.
Das <code>u</code> steht hierbei für <i>unsigned</i> (engl. vorzeichenlos)
und die Zahl dahinter ist die Anzahl der Bits. Ein Bit ist eine
binäre Ziffer. Eine Speicherzelle mit <var>n</var> Bits kann also die
2<sup><var>n</var></sup> Zahlen von 0 bis 2<sup><var>n</var></sup>&minus;1
speichern.

<p>Neben den vorzeichenlosen gibt es auch noch die vorzeichenbehafteten
Typen <code>i8</code>, <code>i16</code>, <code>i32</code> und <code>i64</code>.
Das <code>i</code> steht dabei für <i>integer</i>.
Das Vorzeichen wird hier nicht im ersten oder letzten Bit gespeichert.
Stattdessen liegen die Zahlen in der Zweier-Komplement-Darstellung vor.
Der Zahlenvorrat reicht hier von &minus;2<sup><var>n</var>&minus;1</sup>
bis 2<sup><var>n</var>&minus;1</sup>&minus;1.

<p>Außerdem gibt es noch die Typen <code>usize</code> und
<code>isize</code>. Der Typ <code>usize</code> ist ein Typ der intern
die Gestalt von <code>u32</code> oder <code>u64</code> besitzt, je
nachdem ob ein 32-Bit-Programm oder ein 64-Bit-Programm vorliegt.
Ein 64-Bit-Programm hat u.&nbsp;a. den Vorteil, dass es mehr als
4&nbsp;GB Arbeitsspeicher adressieren kann. Es gibt reine
<var>n</var>-Bit-Architekturen auf denen nur <var>n</var>-Bit-Programme
ausgeführt werden können. Auf eingeschränkten Mikrocontrollern
kann auch <var>n</var>=16 oder gar <var>n</var>=8 sein.
Die Typen <code>usize</code> und <code>isize</code> sind dafür da,
um mit Speicheradressen rechnen zu können, unabhängig davon ob eine
32-Bit oder 64-Bit-Architektur vorliegt.

<p>Wir wollen nun die Zahl 12 an den Bezeichner <code>x</code> binden.
Das geschieht wie folgt:

<pre class="rust indent">
let x: i32 = 12i32;
</pre>

<p>Hier muss man zunächst bemerken, dass der Rust-Compiler in der
Lage ist, den Typ von <code>x</code> aus dem Ausdruck auf der
rechten Seite vom Zuweisungszeichen »=« zu erkennen. Dieser Vorgang
nennt sich <i>Typ-Inferenz</i>. Man darf also kürzer schreiben:

<pre class="rust indent">
let x = 12i32;
</pre>

<p>Da aber <code>i32</code> der Standard-Ganzzahl-Datentyp ist,
wird dieser angenommen, falls kein Typ abgeleitet werden kann.
Man kann hier also kurz schreiben:

<pre class="rust indent">
let x = 12;
</pre>

<p>Angenommen wir benötigen nun einen Ganzzahltyp, der auf einem
Computer <code>u16</code> und auf dem anderen Computer <code>u32</code>
ist. Rust bietet diese Möglichkeit der Abstraktion, indem es uns einen
Typ-Alias definieren lässt, welcher ähnlich wie <code>usize</code>
verwendet wird:

<pre class="rust indent">
type uint = u32;
let x: uint = 12;
</pre>

<p>Hier ist <code>uint</code> ein Alias für <code>u32</code>.
Durch Änderung einer einzigen Zeile kann ein komplexes Computerprogramm
nun an eine andere Architektur angepasst werden. Auch die
Automatisierung dieser Änderung ist möglich. Durch Änderung
der Konfiguration in einer Datei ließe sich ein ganzes Softwaresystem
anpassen. Ein solcher Extremfall wäre z.&nbsp;B. <code>usize</code>,
wobei <code>usize</code> aber ein eigener abstrakter Datentyp ist.
Noch strenger lässt sich die Abstraktion formulieren, wenn man
wie bei <code>usize</code> einen dafür vorgesehen abstrakten
Datentyp formuliert. Eine genaue Erläuterung dazu folgt in einem
späteren Kapitel.

<p>Rust erlaubt die binäre, oktale und hexadezimale
Darstellung einer Zahl im Quelltext:

<pre class="rust indent">
let x: u32 = 0b00000000_00000000_00000000_00001100; // binär
let x: u32 = 0b1100; // binär, kurz
let x: u32 = 0x00_00_00_0c; // hexadezimal
let x: u32 = 0x0000000c; // hexadezimal ohne Trennzeichen
let x: u32 = 0xc; // hexadezimal, kurz
let x: u32 = 0o14; // oktal
</pre>

<p>Der Unterstrich darf an beliebigen Stellen eingefügt werden
und dient ausschließlich als Mittel um bessere Lesbarkeit
zu ermöglichen. Auch die Ausgabe in den unterschiedlichen
Darstellungen ist möglich:

<pre class="rust indent">
let x: u32 = 12;
println!("{}, 0b{:b}, 0x{:x}, 0o{:o}",x,x,x,x);

// Ausgabe:
// 12, 0b1100, 0xc, 0o14
</pre>

<h2 id="Fliesskommazahlen">Fließkommazahlen</h2>

<p>Die Datentypen <code>f32</code> und <code>f64</code> repräsentieren
Fließkommazahlen, wobei 32 bzw. 64 wieder für die Zahl der Bits
steht. Der Typ <code>f64</code> ist der Standarddatentyp für
Fließkommazahlen. Der Typ <code>f32</code> sollte nur in extrem
Laufzeit-kritischen Routinen verwendet werden, etwa in den
Grafik-Kernen von Computerspielen, da dort jede Verzögerung
schmerzlich ist.

<p>Wird keine weitere Typ-Annotation angegeben, die Zahl aber
mit einen Punkt dargestellt, dann wird <code>f64</code> angenommen:
<pre class="rust indent">
let x = 1.0; //  let x: f64 = 1.0;
</pre>

<p>Die elementaren Funktionen sind ohne weitere Einbindungen
verfügbar, müssen jedoch als Methodenaufruf geschrieben
werden:

<pre class="rust indent">
use std::f64::consts::PI;
const GRAD: f64 = PI/180.0;

let x = (2.0f64).sqrt();
let y = (90.0*GRAD).sin();
</pre>

<p>Neue Funktionen lassen sich ganz einfach definieren:

<pre class="rust indent">
fn f(x: f64) -&gt; f64 {
    return 1.0/(x.abs()+1.0);
}

fn main(){
    println!("{}",f(1.0))
}
</pre>

<h2 id="Typumwandlungen">Typumwandlungen</h2>

<h3>Sichere Typumwandlungen</h3>

<p>Für sichere Typumwandlungen steht die Funktion <code>from</code>
zur Verfügung:

<pre class="rust indent">
let x: u8 = 0;
let y: i32 = i32::from(x);
</pre>

<p>Normalerweise ist eine solche Umwandlung eine
umkehrbare Einbettung. Z.&nbsp;B. ist die Umwandlung von <code>u8</code>
nach <code>i32</code> eine Einbettung, da <code>u8</code> als Teilmenge
von <code>i32</code> betrachtet werden kann, und umkehrbar, da niemals
zwei <code>u8</code>-Zahlen zur selben <code>i32</code>-Zahl werden.

<p>In der Übersicht ergeben sich die folgenden Umwandlungen:
<pre class="indent">
u16::from(x: u8),
u32::from(x: u8), u32::from(x: u16),
u64::from(x: u8), u64::from(x: u16), u64::from(x: u32)

i16::from(x: u8),
i32::from(x: u8), i32::from(x: u16),
i64::from(x: u8), i64::from(x: u16), i64::from(x: u32)

i16::from(x: i8),
i32::from(x: i8), i32::from(x: i16),
i64::from(x: i8), i64::from(x: i16), i64::from(x: i32)
</pre>

<p>Nun stellt sich noch die Frage, wie Umwandlungen mit möglichem
Verlust gehandhabt werden sollen. Falls ein Verlust auftritt, würde
man das Verhalten dann gerne selbst festlegen. Dies erlaubt die Funktion
<code>try_from</code>. Wenn man bei Verlust auf den selben Wert
abbilden möchte, dann lässt sich dies wie folgt bewerkstelligen:

<pre class="rust indent">
use std::convert::TryFrom;

const VERLUST: u8 = 0;

fn main() {
    let x: u32 = 12;
    let y: u8 = match u8::try_from(x) {
        Ok(value) =&gt; value,
        Err(_) =&gt; VERLUST
    };
    println!("{}",y);
}
</pre>
<p>Wenn man aber von vornherein weiß, dass das Argument im Wertebereich
von <code>u8</code> liegt, sollte man stattdessen dies schreiben:

<pre class="rust indent">
let y: u8 = match u8::try_from(x) {
    Ok(value) =&gt; value,
    Err(_) =&gt; unreachable!()
};
</pre>

<h3>Verlustbehaftete Typumwandlungen</h3>

<p>Neben den sicheren Typumwandlungen gibt es in Rust noch die
nackten Typumwandlungen mit dem Schlüsselwort »<code>as</code>«.
Zwar stellen diese Umwandlungen keinen unsicheren Code dar, jedoch
erlauben sie stillschweigend Verlust und Transmutation, sind
daher also mit Vorsicht zu genießen.

<p>Man sollte solche nackten Typumwandlungen nur dann verwenden,
wenn sie mit nicht <code>from</code> möglich sind, beispielsweise
bei einer potentiell verlustbehafteten Umwandlung:

<pre class="rust indent">
let x: u32 = 12;
let y: u8 = x as u8;
</pre>

<p>Was passiert hierbei? Bei einer Umwandlung von <code>u32</code>
nach <code>u8</code> werden ganz einfach die drei höherwertigen
Nullbytes abgeschnitten:

<pre class="indent">
Vorher:  u32: 00000000 00000000 00000000 00001100
Nachher:  u8: 00001100
</pre>

<p>Die Operation »<code>x as u8</code>« ist demnach äquivalent zu:

<pre class="rust indent">
match u8::try_from(x &amp; 0xff) {
    Ok(value) =&gt; value,
    Err(_) =&gt; unreachable!()
}
</pre>

<h3>Transmutierende Typumwandlungen</h3>
<p>Bei transmutierenden Umwandlungen werden Daten einfach als
von anderem Typ interpretiert, ohne eine semantische Umwandlung
vorzunehmen. Aus einer puristischen Sichtweise heraus ist das
grundsätzlich problematisch, da durch die Offenlegung der internen
Repräsentation der Daten jegliche Abstraktion zerstört wird. Aus
diesem Grund sind Transmutationen charakteristisch für sehr
maschinennahe Programmierung.

<p>Betrachten wir z.&nbsp;B. die Umwandlung von <code>i32</code>
in <code>u32</code>:
<pre class="rust indent">
fn main() {
    let x: i32 = -1;
    println!("{}", x as u32);
}
</pre>

<p>Hierbei wird Zweierkomplement-Darstellung offengelegt, was
dazu führt, dass <code>-1</code> als <code>std::u32::MAX</code>
interpretiert wird. Wer noch nie von der Zweierkomplement-Darstellung
gehört hat, wird über das riesig große Ergebnis verblüfft sein.

</body>
</html>
