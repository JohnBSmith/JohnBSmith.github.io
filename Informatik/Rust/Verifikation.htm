<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Programmverifikation</h1>

<p>Programmverifikation mit dem Hoare-Kalkül.

<p>Letztendlich hilft uns die Verifikation im Hoare-Kalkül, einen
Algorithmus besser zu verstehen.

<h2>Schlussregeln</h2>

<pre class="indent">
 Prämisse
──────────
Konklusion
</pre>

<h2>Beispiel</h2>

<p>Betrachten wir nochmals die rekursive Definition der
Potenzierung. Für eine ganze Zahl <var>x</var> und eine
nichtnegative Zahl <var>n</var> ist die Potenz
<var>x</var><sup><var>n</var></sup> definiert gemäß

<p class="indent">
<var>x</var><sup>0</sup> := 1,<br>
<var>x</var><sup><var>n</var></sup>
:= <var>x</var>&sdot;<var>x</var><sup><var>n</var>&minus;1</sup>.

<p>Es wird nun gezeigt, wie man mit dem Hoare-Kalkül die partielle
Korrektheit des iterativen Berechnungsverfahrens
<pre class="rust ibox">
fn pow(x: i32, n: u32) -&gt; i32 {
    let mut y = 1;
    for _ in 0..n {y *= x;}
    return y;
}
</pre>

<p>zeigt. Zunächst müssen wir die for-Schleife in eine äquivalente
while-Schleife transformieren. Dies resultiert in:

<pre class="rust ibox">
fn pow(x: i32, n: u32) -&gt; i32 {
    let mut y = 1;
    let mut i = 0;
    while i != n {
        y = x*y;
        i = i+1;
    }
    return y;
}
</pre>

<p>Das Ende der Berechnung liegt direkt hinter der Schleife, womit
dort <code>i==n</code> ist. Außerdem soll dort <code>y</code> das
Ergebnis der Berechnung sein, d.&nbsp;h. <code>y==x<sup>n</sup></code>.
Demnach gilt dort <code>y==x<sup>i</sup></code>. Weil sich in der
Schleife sowohl <code>i</code> als auch <code>y</code> verändern,
können wir vermuten, dass es sich bei der letzten Gleichung um
eine Schleifeninvariante handelt. Wie sich herausstellt, ist diese
Vermutung richtig und zielführend.

<p>Nun werden zum Algorithmus die Zusicherungen annotiert.
<pre class="rust ibox">
fn pow(x: i32, n: u32) -&gt; i32 {
    let mut y = 1;
    let mut i = 0;
    // {y == 1 und i == 0}
    // {y == x<sup>i</sup>}
    while i != n {
        // {y == x<sup>i</sup>}
        y = x*y;
        // {y == x<sup>i+1</sup>}
        i = i+1;
        // {y == x<sup>i</sup>}
    }
    // {y == x<sup>i</sup> und nicht i != n}
    // {y == x<sup>n</sup>}
    return y;
}
</pre>

<p>Rechnen wir das durch. Die Invariante ist vor der Schleife
erfüllt, den laut der vorherigen Zusicherung darf <code>y==1</code>
und <code>i==0</code> in die Gleichung eingesetzt werden.
Das macht <code>1==x<sup>0</sup></code>, und laut Definition der
Potenzierung stimmt dies.

<p>Nun nehmen wir an, die Invariante sei innerhalb der Schleife
vor dem Schleifenkörper erfüllt. Nach der Zuweisung
<code>y := x*y;</code> gilt dann <code>y==x*x<sup>i</sup></code>,
und laut Definition der Potenzierung ist <code>x*x<sup>i</sup></code>
das Gleiche wie <code>x<sup>i+1</code>. Die Inkrementation
<code>i := i+1;</code> bewirkt dass <code>i</code> in der
Zusicherung dekrementiert werden muss. Formal ausgedrückt gilt

<pre class="indent">
{y == x<sup>i</sup>}[i := i+1] i := i+1; {y == x<sup>i</sup>}
</pre>

laut Zuweisungsaxiom, was nach Vereinfachung die gewünschte Form

<pre class="indent">
{y == x<sup>i+1</sup>} i := i+1; {y == x<sup>i</sup>}
</pre>

<p>annimmt. Daher ist die Invariante auch hinter dem Schleifenkörper
erfüllt. Laut der while-Regel gilt hinter der Schleife folglich
die Invariante und die Negation der Bedingung <code>i!=n</code>.
Die Negation von <code>i!=n</code> ist <code>i==n</code>.
Am Ende gilt hiermit schließlich
<code>y==x<sup>n</sup></code>, was zu beweisen war.

<p>Diese Technik ist bedeutungsschwer, &ndash; vergleichbar wichtig
wie das Verfahren der vollständigen Induktion. Wir können nun der
Reihe nach unsere Algorithmen beweisen. Zumindest erst einmal die,
deren Komplexität nicht zu hoch ist.

<p>Wohlgemerkt wurde nur die partielle Korrektheit gezeigt.
Die totale Korrektheit gilt ohnehin nicht, denn für zu große Argumente
kommt es zum Ganzzahl-Überlauf. Der Algorithmus divergiert hierbei
nicht deshalb, weil sich die Berechnung in einer Endlosschleife
verfängt, sondern weil eine der arithmetischen Operationen zu
<code>panic</code> führt. Dies gilt für die arithmetischen Operationen
zumindest im in dieser Hinsicht puristischen Debug-Modus. Das ist auch
dringend notwendig, denn andernfalls wäre nicht einmal die partielle
Korrektheit sicher.

<p>Die partielle Korrektheit genügt uns natürlich nicht. Jede partiell
korrekte Funktion, die sich nicht in einer Endlosschleife verfangen
kann, können wir zu einer total korrekten machen, indem die Funktion
und all ihre fehlbaren Teiloperationen monadisch verhüllt werden.
Wie das gemacht wird, wurde im Abschnitt
›<a href="Sicherheit.htm#Monaden">Sichere Programmierung: Monaden</a>‹
bereits beschrieben. Wir gelangen zum strikten Algorithmus:

<pre class="rust ibox">
fn pow(x: i32, n: u32) -&gt; Option&lt;i32&gt; {
    let mut y: i32 = 1;
    let mut i: u32 = 0;
    while i != n {
        y = y.checked_mul(x)?;
        i = i+1;
    }
    return Some(y);
}
</pre>

<p>Wie man sieht, bedarf es nur der Verhüllung der Ergebnisse.
Die Argumente dürfen nackt bleiben.

<p>Der Beweis zur Terminierung der Schleife ist recht evident.
Weil vor der Schleife <code>i&nbsp;&le;&nbsp;n</code> ist und
<code>i</code> in jedem Durchlauf inkrementiert wird, muss irgendwann
<code>i==n</code> gelten. Aus diesem Grund kommt es ferner nicht zum
Überlauf in der Operation <code>i+1</code>.


</body>
</html>

