<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Funktionale Programmierung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Funktionenzeiger">Funktionenzeiger</a>
<li><a href="#Closures">Closures</a>
<li><a href="#Higher-order">Funktionen höherer Ordnung</a>
</ol>

<h2 id="Funktionenzeiger">Funktionenzeiger</h2>

<p>Der klassische Kontrollfluss in der prozeduralen Programmierung
verläuft so: Ein Unterprogramm ruft ggf. ein weiteres Unterprogramm
auf, und dieses dann ggf. noch ein weiteres Unterprogramm
usw. Der Kontrollfluss besteht aus Verzweigungen, Schleifen und
Unterprogrammen.

<p>Den Unterprogrammen kommt hierbei eine besondere Bedeutung zu.
Diese modularisieren das Programm, indem sie wiederkehrende
Funktionalität zusammenfassen, die internen Details verbergen und über
ihre Signatur eine Schnittstelle zum Rest des Programms herstellen.

<p>Nun kann man sich eine Situation überlegen, in der es eine
Fallunterscheidung zwischen sehr vielen Unterprogrammen gibt.
Da dies noch handhabbar erscheint, will ich diese Überlegung
sogleich verschärfen. Was tut man denn, wenn das gewählte
Unterprogramm nicht im Vorhinein bekannt ist?

<p>Da ich mathematisch-technisch belastet bin, fallen mir dazu keine
besseren Beispiele als numerische Verfahren ein. Betrachten wir
das Newton-Verfahren zur Ermittlung von Nullstellen einer Funktion.
Man kann dieses Verfahren nun für eine bestimmte reelle Funktion
programmieren. Der Algorithmus setzt aber eigentlich keine spezielle
Funktion voraus. Für eine allgemeine Formulierung muss die Funktion
ein Argument des Verfahrens sein. Ermöglicht wird dies durch das
Speichern einer Referenz auf die Funktion in einer Variable, man
spricht auch von einem Funktionenzeiger.

<p>Das Newton-Verfahren benötigt die erste Ableitung der Funktion.
Diese lässt sich ebenfalls mit einem numerischen Verfahren
approximieren. Als Beispiel sei die Funktion <var>f</var>(<var>x</var>)
= <var>x</var><sup>2</sup>&nbsp;&minus;&nbsp;2 gewählt.
Die positive Nullstelle ist die Wurzel von zwei.

<pre class="rust indent">
fn diff(f: fn(f64)-&gt;f64, x: f64) -&gt; f64 {
    let h = 0.001;
    return (f(x+h)-f(x-h))/(2.0*h);
}

fn newton(f: fn(f64)-&gt;f64, x0: f64) -&gt; f64 {
    let mut x = x0;
    for _ in 0..20 {
        x = x-f(x)/diff(f,x);
    }
    return x;
}

fn main() {
    fn f(x: f64) -&gt; f64 {x*x-2.0}
    println!("{}",newton(f,1.0));
}
</pre>

<p>Der wesentliche Vorteil herbei ist, dass wir numerische Verfahren
nun in allgemeiner Form in Bibliotheken aufbewahren können. Das geht
nur, wenn das Verfahren nicht an eine feste Funktion gekoppelt ist.

<h2 id="Closures">Closures</h2>

<h3>Aufhebung einer Beschränkung</h3>

<p>Funktionenzeiger sind einer Beschränkung unterworfen, die ihre
Brauchbarkeit stark reduzieren. Zentral für die funktionale
Programmierung ist, dass sich Funktionen aus Daten erzeugen lassen.
Dies wird erreicht durch Bindung von Variablen aus der Umgebung
der Funktion, man spricht von einem <i>Closure</i>. Die Umgebung wird
auch <i>Erstellungskontext</i> genannt.

<p>Angenommen wir wollten mit dem Newton-Verfahren nun die
Quadratwurzel-Funktion <code>sqrt</code> implementieren. Die
Funktion ergäbe sich offenbar so:
<pre class="rust indent">
fn sqrt(a: f64) -&gt; f64 {
    fn f(x: f64) -&gt; f64 {x*x-a}
    return newton(f,1.0);
}
</pre>

<p>Diese Funktion würgt der Compiler jedoch ab, denn die innere
Funktion <code>f</code> vermag es nicht, den Wert der Variablen
<code>a</code> zu speichern. Diese Variable entstammt ja aus der
Umgebung der Funktion.

<p>Allerdings gestattet leichte Modifikation des Programms die
explizite Benutzung von Closures und Closurezeigern. In abstrakteren
Programmiersprachen sind Funktionen und Closures vereinheitlicht.
In Rust ist das etwas komplizierter, weil Closures zur effizienten
Programmierung mit den Eigenschaften des Typsystems verwoben sind.

<p>Die verallgemeinerten Schnittstellen bezüglich Closurezeigern
gestatten sowohl Funktionen als auch Closures als Argumente. Zwischen
Funktionen und Closures  besteht einen kleiner Unterschied in der
Syntax. Anstelle von
<pre class="rust indent">
fn f(x: f64) -&gt; f64 {x*x-2.0}
</pre>

<p>schreibt man:
<pre class="rust indent">
let f = |x: f64| -&gt; f64 {x*x-2.0};
</pre>

<p>oder mittels Typinferenz kurz:
<pre class="rust indent">
let f = |x| x*x-2.0;
</pre>

<p>Das gewünschte Programm:
<pre class="rust indent">
fn diff(f: &amp;dyn Fn(f64)-&gt;f64, x: f64) -&gt; f64 {
    let h = 0.001;
    return (f(x+h)-f(x-h))/(2.0*h);
}

fn newton(f: &amp;dyn Fn(f64)-&gt;f64, x0: f64) -&gt; f64 {
    let mut x = x0;
    for _ in 0..20 {
        x = x-f(x)/diff(f,x);
    }
    return x;
}

fn sqrt(a: f64) -&gt; f64 {
    let f = |x| x*x-a;
    return newton(&amp;f,1.0);
}

fn main() {
    println!("{}",sqrt(2.0));
}
</pre>

<h2 id="Higher-order">Funktionen höherer Ordnung</h2>

<h3>Map</h3>

<p>Die Funktion <code>map</code> wendet eine Funktion auf jedes
Element eines Arrays an.

<pre class="rust indent">
fn map&lt;X,Y&gt;(a: &amp;[X], f: &amp;dyn Fn(&amp;X)-&gt;Y) -&gt; Vec&lt;Y&gt; {
    let mut b = Vec::with_capacity(a.len());
    for x in a {
        b.push(f(x));
    }
    return b;
}

fn main() {
    let a = vec![1,2,3,4];
    let b = map(&amp;a,&amp;|x| x.to_string());
    println!("{:?}",b);
}
</pre>

<p>Alternativ ist hier auch die Signatur
<pre class="rust indent">
f: impl Fn(&amp;X)->Y
</pre>
<p>erlaubt, bzw. äquivalent:
<pre class="rust indent">
fn map&lt;X,Y,F&gt;(a: &amp;[X], f: F) -&gt; Vec&lt;Y&gt;
where F: Fn(&amp;X)-&gt;Y
</pre>
<p>Dies kann zu besser optimiertem Code führen, da die
Monomorphisierung mehr Inlining ermöglicht.

<p>Weitere Abstraktion erlaubt die Anwendung der Funktion auf
beliebige iterierbare Objekte:
<pre class="rust indent">
fn map&lt;X,Y,A,F&gt;(a: A, f: F) -&gt; Vec&lt;Y&gt;
where A: IntoIterator&lt;Item=X&gt;, F: Fn(&amp;X)-&gt;Y
{
    let it = a.into_iter();
    let mut b = Vec::with_capacity(it.size_hint().0);
    for x in it {
        b.push(f(&amp;x));
    }
    return b;
}

fn main() {
    let b = map(1..=4,|x| x.to_string());
    println!("{:?}",b);
}
</pre>

</body>
</html>

