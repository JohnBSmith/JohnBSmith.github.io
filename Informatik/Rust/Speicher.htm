<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Speicherverwaltung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Zeiger">Einfache Zeiger</a>
<li><a href="#Allokation">Allokation</a>
<li><a href="#Box">Zeiger vom Typ Box</a>
<li><a href="#Rc">Zeiger vom Typ Rc</a>
<li><a href="#Cell">Zellen vom Typ Cell</a>
<li><a href="#RefCell">Zellen vom Typ RefCell</a>
<li><a href="#DST">Typen dynamischer Größe</a>
<li><a href="#Ersetzung">Ersetzung von Werten</a>
<li><a href="#Vertauschung">Vertauschung von Werten</a>
<li><a href="#Cow">Zeiger vom Typ Cow</a>
<li><a href="#Freigabe">Freigabe des Speichers</a>
<li><a href="#Literatur">Literatur</a>
</ol>

<h2 id="Zeiger">Einfache Zeiger</h2>

<p>Ein Zeiger ist eine Variable, die die Speicheradresse einer
anderen Variable als Wert enthält.

<h3>Zeigerarithmetik</h3>

<p>Ein Array ist im Speicher als Sequenz seiner Elemente dargestellt.
Ein Zeiger auf das Array enthält die Speicheradresse des ersten
Elements. Addiert man zu der Adresse nun eine Zahl, ergibt sich
eine neue Adresse, die einen verschobenen Zeiger darstellt.

<p>Damit diese Verschiebung einwandfrei funktioniert, darf zur
Adresse immer nur ein ganzzahliges Vielfaches der Elementgröße
addiert werden. Erreicht wird dies, indem die Zahl vor der Addition
implizit mit der Elementgröße multipliziert wird.

<p>Die Arithmetik von Zeigern umfasst die folgenden Konzepte:

<ul>
<li>Zu einem Zeiger darf eine Zahl addiert werden. Das Ergebnis
ist ein um diese Zahl von Elementen verschobener Zeiger.
<li>Die Differenz zweier Zeiger darf gebildet werden. Das Ergebnis
ist eine Zahl von Elementen, die dem Vorzeichen-behafteten Abstand
der Zeiger entspricht.
<li>Zeiger dürfen auf Gleichheit geprüft werden.
<li>Für Zeiger ist eine Ordnungsrelation definiert.
Ein erster Zeiger ist kleiner als ein zweiter, wenn die
Speicheradresse des ersten kleiner als die des zweiten ist.
</ul>

<p>Eine Analogie aus der Mathematik sind Punkte und Vektoren.
Der Zeiger entspricht einem Punkt im euklidischen Raum, die Zahl
einem Vektor. So wie man zum Zeiger eine Zahl addieren
kann, kann man zum Punkt einen Vektor addieren, wodurch sich eine
Verschiebung des Punktes um diesen Vektor ergibt. Die
Ordnungsrelation ist nur auf einem eindimensionalen Raum definierbar.

<p>In Rust ist die Arithmetik für einfache Zeiger definiert.
Die folgende Tabelle listet die wesentlichen Operationen auf.

<table class="bt">
<tr>
<th>Operation
<th>Erklärung
<tr>
<td><code>p.add(i)</code>
<td>Verschiebt den Zeiger <code>p</code> um <code>i</code> Elemente.
<tr>
<td><code>p.offset(i)</code>
<td>Verschiebt <code>p</code> um <code>i</code> Elemente, wobei <code>i</code> auch negativ sein darf.
<tr>
<td><code>p1.offset_from(p2)</code>
<td>Vorzeichen-behafteter Abstand der Zeiger.
<tr>
<td><code>p1 == p2</code>
<td>Die beiden Zeiger zeigen auf dieselbe Speicherzelle.
<tr>
<td><code>p1 &lt; p2</code>
<td>Der zweite Zeiger zeigt auf eine spätere Speicherzelle.
</table>

<p>Die in Hochsprache formulierte Funktion

<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for x in a {
        println!("{}", x);
    }
}
</pre>

<p>nimmt nach Absenkung diese Gestalt an:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let p_end = unsafe {p.add(a.len())};
    while p != p_end {
        println!("{}", unsafe {*p});
        p = unsafe {p.add(1)};
    }
}
</pre>

<p>Oder alternativ:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let mut n = a.len();
    while n &gt; 0 {
        println!("{}", unsafe {*p});
        p = unsafe {p.add(1)};
        n -= 1;
    }
}
</pre>

<p>Die Formulierung
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for i in 0..a.len() {
        println!("{}", a[i]);
    }
}
</pre>

<p>entspricht
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let p = a.as_ptr();
    let n = a.len();
    let mut i = 0;
    while i &lt; n {
        println!("{}", unsafe {*p.add(i)});
        i += 1;
    }
}
</pre>

<p>Zeigerarithmetik ist ein auf einfache Zeiger beschränktes
Konzept. Weder Leihgaben noch Smart-Pointer unterstützen sie.
Das muss auch so sein, denn diese Typen besitzen keine
Möglichkeit zur Prüfung, ob das Ergebnis einer Verschiebung im
gültigen Bereich bleibt, womit per se keine Sicherheit
gewährleistet werden kann.

<p>Ausschnitt-Leihgaben bieten allerdings tatsächlich die Möglichkeit
einer Arithmetik, denn diese sind Paare aus Zeiger und Länge.
Durch Prüfung der Länge ist eine sichere Dereferenzierung
realisierbar. Die folgende Formulierung von <code>print_array</code>
verdeutlicht die Überlegung.

<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = &amp;a[..];
    while !p.is_empty() {
        println!("{}", p[0]);
        p = &amp;p[1..];
    }
}
</pre>

<p>Hier entspricht <code>p[0]</code> der Dereferenzierung
und <code>&amp;p[1..]</code> der Inkrementierung.

<h2 id="Allokation">Allokation</h2>

<p>Die Daten, die ein Programm verarbeitet, müssen notgedrungen auf
irgendeine Art im RAM-Speicher des Computers untergebracht werden.
Dafür gibt es zwei Verfahren:

<dl class="indent">
<dt><b>1. Stapelspeicher, engl. <i>stack</i></b>
<dd>Die Zuweisung von Speicher geschieht hier besonders
schnell, da dafür lediglich der Stapelzeiger, engl.
<i>stack pointer</i>, inkrementiert werden braucht. Allerdings muss
der Speicher aus diesem Grund auch in der umgekehrten Reihenfolge
freigegeben werden, wie er zugewiesen wurde. Weil dies nun gerade
der Verwaltung von lokalen Variablen beim Aufrufen und Verlassen von
Unterprogrammen entspricht, arbeiten die meisten Laufzeitsysteme
bevorzugt mit dem Stack.

<dt><b>2. Haldenspeicher, engl. <i>heap</i></b>
<dd>Bei diesem darf Speicher in beliebiger Reihenfolge zugewiesen
und freigegeben werden. Infolge ist der Heap vergleichsweise
kompliziert und langsam.
</dl>

<h2 id="Box">Zeiger vom Typ Box</h2>

<p>Die folgende Funktion <code>new_data</code> gibt ein Array
zurück, das bspw. Bilddaten eines Bildes mit Breite 480 Pixel
und Höhe 300 Pixel aufnehmen soll.

<pre class="rust ibox">
const DATA_LEN: usize = 480*300;

fn new_data() -&gt; [u32; DATA_LEN] {
    [0; DATA_LEN]
}
</pre>

<p>Nun ist der Stack in nativen Laufzeitsystemen begrenzt. Typische
Werte für die Begrenzung liegen bei 1 bis 10&nbsp;MB. Zwar lässt sich
dies ändern, bspw. indem das Hauptprogramm in einem neuen Thread
mit größerem Stack ausgeführt wird, nehmen wir aber zunächst an, dies
wäre uns nicht gegeben. Wollen wir nun ein größeres Array speichern,
oder ein Array von Arrays, ist der Stapel bald aufgebraucht.

<p>Für gewöhnlich wird für solche Datenmengen stattdessen
Haldenspeicher zugewiesen. Dafür zuständig ist die Funktion
<code>Box::new</code>, die einen Zeiger auf den zugewiesenen
Speicher zurückgibt. 

<pre class="rust ibox">
fn new_data() -&gt; Box&lt;[u32; DATA_LEN]&gt; {
    Box::new([0; DATA_LEN])
}
</pre>

<p>Bei einem Zeiger vom Typ <code>Box</code> handelt es sich um einen
sogenannten <i>Smart-Pointer</i>. Ein solcher zeichnet sich durch die
Eigenschaft aus, dass der Speicher automatisch wieder freigegeben wird,
sobald die Lebenszeit des Zeigerwertes endet.

<h2 id="Rc">Zeiger vom Typ Rc</h2>

<h3>Gemeinsamer Besitz</h3>

<p>Stellt man sich Zeiger als Speicheradressen vor, liegt der Gedanke
nicht fern, mehrere Zeiger auf den gleichen Wert zeigen zu lassen.
Der Typ <code>Box</code> schließt dies jedoch aus, weil ein Zeiger
dieses Typs der Besitzer des Wertes ist. Wir müssen uns hierzu
daran erinnern, dass die Unteilbarkeit von Besitzerschaft eine
entscheidende Eigenschaft des Typsystems ist.

<p>Was man ohne Frage tun kann, ist die Erstellung beliebig
vieler Zeiger vom Typ <code>&amp;Box&lt;T&gt;</code>, da diese
nur Leihgaben darstellen. Dies bringt jedoch eine Reihe von
Problemen mit sich:

<ul>
<li>Sobald es zu einer Leihgabe kommt, ist die den Wert tragende
Datenstruktur als zugrundeliegender Besitzer gefroren.
Andernfalls könnte man den Wert entfernen oder verschieben,
was zu Use after free führen würde.

<li>Denkbar sind Situationen, wo man Zeiger auf denselben Wert in zwei
oder mehreren Datenstrukturen speichern möchte, wo nicht bekannt ist,
welcher Zeiger von längerer Lebenszeit ist.
</ul>

<p>Eine Lösung für die Problematik bestünde in der Benutzung eines
sogenannten Arena-Allokators. Bei diesem dauert die Lebenszeit aller
erstellten Werte genau so lange an wie die des Allokators.
Das heißt, im Unterschied zu einem gewöhnlichen Allokator sind
Freigaben nicht zu beliebigen Zeitpunkten möglich. Eines Besitzers
bedarf es nicht mehr, weil die Arena der eigentliche Besitzer ist.
An dieser Stelle soll nicht näher auf dieses Konzept eingegangen werden.

<p>Eigentlich ist die Forderung nach Unteilbarkeit von Besitzerschaft
zu streng. Solange einem Wert keine Veränderung widerfährt, dürfte
es mehrere Zeiger auf diesen geben. Nur dann muss der Wert solange
erhalten bleiben, bis der letzte Zeiger verschwunden ist. Allerdings
wissen wir nicht immer, in welcher Reihenfolge die Zeiger kommen
und gehen. Diesem Umstand trägt die Benutzung eines Referenzzählers
Rechnung, der dem Wert hinzugefügt wird. Der Referenzzähler zählt die
Anzahl vorhandener Zeiger. Bei der Erstellung eines neuen Zeigers wird
dieser um eins erhöht, beim Verschwinden eines Zeigers um eins
erniedrigt.

<p>Der Mechanismus der Referenzzählung ist durch den Typ
<code>Rc</code> implementiert, das steht für <i>reference counted</i>.
So wie bei <code>Box</code> ist der Speicherplatz, auf den der
Zeiger zeigt, auf der Halde alloziert. Erstellt wird eine neue
Allokation mit <code>Rc::new</code> oder <code>Rc::from</code>.
Die Methode <code>Rc::clone</code> bewirkt gerade nicht eine
Kopie der Daten, sondern nur eine Kopie des Zeigers und entsprechend
eine Inkrementation des Referenzzählers.

<p>Ein Beispiel zur Benutzung von <code>Rc</code> bieten
Ausschnitte mit Besitzerschaft. Betrachten wir zunächst 
folgendes Programm.

<pre class="rust ibox">
fn main() {
    let slice: &amp;[u8] = &amp;[0, 0, 0, 0, 1, 1, 1, 1];
    let sub_slice = &amp;slice[4..8];
    println!("{:?}", sub_slice);
}
</pre>

<p>Die Ausschnitte bedingen hier Leihgaben der zugrunde liegenden
Bytesequenz. Stattdessen wollen wir nun Ausschnitte mit gemeinsamer
Besitzerschaft an der Bytesequenz haben. Um dies zu erreichen,
konstruieren wir für diese Ausschnitte den neuen Typ <code>Slice</code>,
dessen Eintrag <code>data</code> eine gezählte Referenz auf die
Bytesequenz ist.

<pre class="rust ibox">
use std::{fmt, rc::Rc, ops::Range};

struct Slice {
    data: Rc&lt;[u8]&gt;,
    start: usize,
    len: usize
}
impl Slice {
    fn new(data: Rc&lt;[u8]&gt;) -&gt; Self {
        let len = data.len();
        Self {data, start: 0, len}
    }
    fn slice(&amp;self, r: Range&lt;usize&gt;) -&gt; Self {
        let start = self.start + r.start;
        let len = r.end - r.start;
        Self {data: self.data.clone(), start, len}    
    }
}

impl fmt::Debug for Slice {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let start = self.start;
        write!(f, "{:?}", &amp;self.data[start..start+self.len])
    }
}

fn main() {
    let data: Rc&lt;[u8]&gt; = Rc::from([0, 0, 0, 0, 1, 1, 1, 1]);
    let slice = Slice::new(data);
    let sub_slice = slice.slice(4..8);
    println!("{:?}", sub_slice);
}
</pre>

<p>Wir müssen näher darauf blicken, was hier gemacht wurde. Der Typ
<code>&amp;[u8]</code> ist eigentlich über Lebenszeiten
parametrisiert, die Notation unterdrückt dies bloß. Bei der Definition
eines Aliastypen tritt die Abhängigkeit von der Lebenszeit
explizit hervor:

<pre class="rust ibox">
type BorrowSlice&lt;'a&gt; = &amp;'a [u8];
</pre>

<p>Im Typ <code>Slice</code> ist diese Parametrisierung verloren
gegangen. Der Typ <code>Slice</code> ist demnach nicht mehr von
der Lebenszeit eines anderen Datums abhängig.

<h3>Zur Laufzeit erzeugte Symbole</h3>

<p>Brauchbar ist <code>Rc</code> auch zur Erzeugung von Symbolen.
Unter einem Symbolvorrat wollen wir schlicht einen Wertebereich
verstehen, dessen Elemente schnell zu kopieren und zu vergleichen
sind. Ist der Symbolvorrat bereits zur Kompilierzeit bekannt, würde man
diesen als Enumeration darstellen. Ist der Vorrat allerdings erst
zur Laufzeit bekannt, muss man sich eine andere Darstellung überlegen.

<p>Eine Idee ist die Darstellung von Symbolen als Zeiger. Zwei
Symbole sind genau dann gleich, wenn die Zeiger auf dasselbe
Objekt zeigen. Demnach wird mit <code>Rc::new</code> einmalig ein
neues Symbol erzeugt, das irgendwo in der Laufzeitumgebung oder
einer zugänglichen Datenstruktur hinterlegt werden muss. Von diesem
lassen sich nun mit <code>Rc::clone</code> beliebig viele Kopien
anfertigen. Zum Vergleich zweier Symbole wird <code>Rc::ptr_eq</code>
genutzt.

<pre class="rust ibox">
use std::rc::Rc;

fn main() {
    let a = Rc::new(());
    let b = a.clone();
    assert!(Rc::ptr_eq(&amp;a, &amp;b));
}
</pre>

<p>Durchaus bestehen noch andere Wege zur Darstellung von Symbolen.
Effizient ist bspw. ein Zähler in der Laufzeitumgebung.
Zur Erzeugung eines neuen Symbols wird das Symbol als Zählerwert
dargestellt und der Zähler zudem inkrementiert, womit garantiert ist,
dass jedes mal ein neues, einmaliges &ndash; d.&nbsp;h. zu allen
anderen verschiedenes &ndash; Symbol geschaffen wird.

<p>Allerdings bietet <code>Rc</code> zusätzlich die Möglichkeit,
Symbole mit einem Namen zu versehen. Zu beachten ist hierbei,
dass unterschiedliche Symbole den gleichen Namen tragen
dürfen, was zur Verwirrung führen kann.

<pre class="rust ibox">
use std::rc::Rc;

fn main() {
    let a: Rc&lt;str&gt; = Rc::from("A");
    let b = a.clone();
    assert!(Rc::ptr_eq(&amp;a, &amp;b));
    println!("{}", a);
}
</pre>

<p>Zur Bemerkung sei noch erwähnt, dass <code>Rc::ptr_eq</code>
bei <code>Rc&lt;str&gt;</code> sowohl den Zeiger als auch die
Länge vergleicht. Effizienter ist für unseren Zweck der reine
Vergleich der Zeiger. Dies wird durch die folgende
Funktion <code>ptr_eq_plain</code> erreicht. 

<pre class="rust ibox">
fn ptr_eq_plain&lt;T: ?Sized&gt;(p: &amp;Rc&lt;T&gt;, q: &amp;Rc&lt;T&gt;) -&gt; bool {
    let p = &amp;**p as *const T as *const ();
    let q = &amp;**q as *const T as *const ();
    std::ptr::eq(p, q)
}
</pre>

<p>Wie man Symbole im Zusammenhang mit Hashtabellen benutzt,
wurde im Abschnitt ›<a href="Behaelter.htm#Eq-Zeiger"
>Behälter: Hashtabellen: Äquivalenz per Zeigervergleich</a>‹ schon
erläutert.

<h2 id="Cell">Zellen vom Typ Cell</h2>

<h3>Grundmechanismus</h3>

<p>Der Typ <code>Rc</code> gewährt nur gemeinsame Referenzen, womit
die Daten darunter unveränderlich bleiben. Infolge liegt die gesamte
Datenstruktur immerwährend fest wie ein Kristall. Einem gleichartigen
Problem steht man auch in anderen Situationen gegenüber, &ndash;
überall dort, wo man nur gemeinsame Referenzen bekommt. Dem Ziel
der Programmierung von dynamischen Datenstrukturen läuft diese
Einschränkung offensichtlich zuwider. Zur Auflösung dieser
Einschränkung stehen daher ausgeklügelte Mechanismen zur Verfügung.

<p>Erinnern wir uns daran, dass bei gemeinsamen Referenzen
Veränderungen an den Daten verboten sind, weil es sonst zu Aliasing
und Use after free kommen kann. Einen Teil der Daten unter einer
gemeinsamen Referenz wollen wir nun dennoch verändern dürfen.
Angenommen, wir verbieten Zeiger auf diesen Teil, womit dieser Teil nur
als Ganzes gelesen und geschrieben werden darf,
dann dürfte es niemals zu den genannten Problemen kommen.

<p>Mit der technischen Ausgestaltung dieser Idee ist der Typ
<code>Cell</code> entstanden. Einen Zeiger auf das Innere eines
Wertes dieses Typs kann man nicht bekommen. Lediglich ist es gestattet,
die Zelle mit der Methode <code>Cell::get</code> gänzlich zu
lesen oder mit <code>Cell:set</code> gänzlich zu schreiben.
Außerdem gibt es noch ein paar Hilfsmethoden zum flexibleren
Ausreizen der zugrundeliegenden Idee.

<p>Eine Anwendung von <code>Cell</code> zeigt die folgende
Implementierung eines Zählers, der sich auch dann verändern
darf, wenn man nur »veränderungslosen« Zugriff auf ihn hat.

<pre class="rust ibox">
use std::{rc::Rc, cell::Cell};

struct Counter {
    value: Cell&lt;u32&gt;
}
impl Counter {
    fn new() -&gt; Self {
        Self {value: Cell::new(0)}
    }
    fn next(&amp;self) -&gt; u32 {
        let value = self.value.get();
        self.value.set(value + 1);
        value
    }
}

fn main() {
    // Scheinbar absurd: Veränderung hinter einer
    // gemeinsamen Referenz.
    let counter = &amp;Counter::new();
    println!("{}", counter.next());
    println!("{}", counter.next());

    // Entsprechend erlaubt.
    let counter = Rc::new(Counter::new());
    println!("{}", counter.next());
    println!("{}", counter.next());
}
</pre>

<h3>Projektion von Ausschnitten</h3>

<p>Zu Produkttypen wie Strukturen, Tupeln und Feldern gehören
Projektionen auf ihre Elemente. Zum Zugriff über Leihgaben muss
hierbei auch die Projektion über Leihgaben formuliert sein.
Für Ausschnitte ist die Projektion so definiert:

<pre class="rust ibox">
fn proj&lt;T&gt;(a: &amp;[T], i: usize) -> &amp;T {
    &amp;a[i]
}
</pre>

<p>Entsprechend ist definiert:

<pre class="rust ibox">
fn proj_mut&lt;T&gt;(a: &amp;mut [T], i: usize) -> &amp;mut T {
    &amp;mut a[i]
}
</pre>

<p>Nun lässt sich zu jedem Typ <code>T</code> der Typ
<code>&amp;mut T</code> als in einer Subtyp-ähnlichen Beziehung zu
<code>&amp;Cell&lt;T&gt;</code> betrachten. Die Rolle des Upcasts
nimmt hierbei <code>Cell::from_mut</code> mit der Signatur

<pre class="rust indent">
fn from_mut(t: &amp;mut T) -> &amp;Cell&lt;T&gt;
</pre>

<p>ein. Speziell können wir <code>&amp;mut [T]</code> in
<code>&amp;Cell&lt;[T]&gt;</code> umwandeln. Nun würden wir den
Ausschnitt gerne indizieren. Das heißt, wir brauchen nicht den
Zugriff auf den Ausschnitt als Ganzes, sondern die Projektionen
auf dessen Elemente. Das notwendige Hilfsmittel dafür ist die Methode
<code>as_slice_of_cells</code>, die <code>&amp;Cell&lt;[T]&gt;</code>
weiter in <code>&amp;[Cell&lt;T&gt;]</code> umwandelt.

<p>Der Nutzen liegt darin, gleichzeitig <i>mit Zeigern</i> über ein
Feld iterieren zu können, während dessen Elemente modifiziert werden.
Betrachten wir bspw. die folgende Implementierung von Buble sort.

<pre class="rust ibox">
fn bubble_sort&lt;T: Ord&gt;(a: &amp;mut [T]) {
    let n = a.len();
    for _ in 0..n {
        for i in 1..n {
            if a[i] &lt; a[i-1] {a.swap(i, i-1);}
        }
    }
}
</pre>

<p>Bei der Indizierung tritt für gewöhnlich eine Bereichsprüfung
auf. Manchmal sieht sich der Compiler auch in der Lage, diese
während der Optimierung zu entfernen. Ein alternativer Weg
ist die Benutzung von Zeigern anstelle von Indizes. Wir würden
gerne schreiben:

<pre class="rust ibox">
fn bubble_sort&lt;T: Ord&gt;(a: &amp;mut [T]) {
    for _ in 0..a.len() {
        let mut y = &amp;mut a[0];
        for x in &amp;mut a[1..] {
            if x &lt; y {std::mem::swap(x, y);}
            y = x;
        }
    }
}
</pre>

<p>Jedoch ist dieses Programm nicht kompilierbar, weil zwei
alleinige Leihgaben des gleichen Ausschnitts verboten sind.
Der beschriebene Formalismus eröffnet nun eine Formulierung,
bei welcher stattdessen gemeinsame Leihgaben auftreten.

<pre class="rust ibox">
use std::cell::Cell;

fn bubble_sort&lt;T: Ord + Copy&gt;(a: &amp;mut [T]) {
    let a = Cell::from_mut(a).as_slice_of_cells();
    for _ in 0..a.len() {
        let mut y = &amp;a[0];
        for x in &amp;a[1..] {
            if x.get() &lt; y.get() {Cell::swap(x, y);}
            y = x;
        }
    }
}
</pre>

<p>Ein praktischeres Beispiel bietet die folgende Implementierung
von <code>Vec::retain</code>.<sup><a href="#1">1</a></sup>
Da das Prädikat für die Betrachtung nicht wesentlich ist,
sei es zur Vereinfachung auf <code>is_even</code> festgelegt.
Die Formulierung mit Indizierung:

<pre class="rust ibox">
fn retain_even(a: &amp;mut Vec&lt;i32&gt;) {
    let mut i = 0;
    for j in 0..a.len() {
        if is_even(a[j]) {
            a[i] = a[j];
            i += 1;
        }
    }
    a.truncate(i);
}
</pre>

<p>Die Formulierung mit einem Zeiger:
<pre class="rust ibox">
use std::cell::Cell;

fn retain_even(a: &amp;mut Vec&lt;i32&gt;) {
    let s = Cell::from_mut(&amp;mut a[..]).as_slice_of_cells();
    let mut i = 0;
    for x in s.iter().filter(|x| is_even(x.get())) {
        s[i].set(x.get());
        i += 1;
    }
    a.truncate(i);
}
</pre>

<h2 id="RefCell">Zellen vom Typ RefCell</h2>

<h3>Grundmechanismus</h3>
<p>Leider ist <code>Cell</code> nur für kleine Typen mit Trait
<code>Copy</code> effizient, womit <code>Cell</code> auf
spezielle Situationen beschränkt bleibt. Ein allgemeiner
Mechanismus liegt mit <code>RefCell</code> vor. So wie
<code>Cell</code> gewährt eine Zelle vom Typ <code>RefCell</code>
Veränderungen innerhalb von gemeinsamen Leihgaben. Im Unterschied
zu <code>Cell</code> erlaubt <code>RefCell</code> das 
eigentlich Verbotene &ndash; eine alleinige Leihgabe eines Teils
einer gemeinsamen Leihgabe.

<p>Wie kann das möglich sein? Der Compiler verhindert Aliasing
normalerweise, indem zur Kompilierzeit geprüft wird, dass für
Veränderungen immer nur eine einzige alleinige Leihgabe vorhanden ist.
Der Mechanismus von <code>RefCell</code> besteht nun gerade darin,
diese Prüfung stattdessen zur Laufzeit vorzunehmen, womit wir einen
großen Sprung an Flexibilität gewinnen. Zur Umsetzung fügt
<code>RefCell&lt;T&gt;</code> dem Wert des Typs <code>T</code>
einen Referenzzähler hinzu. Man kann dann mit <code>borrow</code>
beliebig viele gemeinsame Leihgaben bekommen, oder mit
<code>borrow_mut</code> eine alleinige Leihgabe. Die technische
Umsetzung kann man so konstruieren:

<ul>
<li>Mit <code>borrow</code> wird der Referenzzähler um eins
erhöht, aber nur falls er nicht-negativ ist. Andernfalls kommt
es zum Programmabbruch.
<li>Mit <code>borrow_mut</code> wird der Referenzzähler auf &minus;1
erniedrigt, aber nur falls er null war. Andernfalls kommt es
zum Programmabbruch.
</ul>

<p>Es folgt ein erstes einfaches Beispiel, &ndash; die Implementierung
des bereits zuvor beschriebenen Zählers <code>Counter</code>, aber
dieses Mal mit <code>RefCell</code> anstelle von <code>Cell</code>.

<pre class="rust ibox">
use std::cell::RefCell;

struct Counter {
    value: RefCell&lt;u32&gt;
}
impl Counter {
    fn new() -&gt; Self {
        Self {value: RefCell::new(0)}
    }
    fn next(&amp;self) -&gt; u32 {
        let mut p = self.value.borrow_mut();
        let value = *p;
        *p = value + 1;
        value
    }
}
</pre>

<h3>Fehlbares Ausleihen</h3>

<p>Die Methoden <code>borrow</code> und <code>borrow_mut</code>
besitzen die totalen Pendants <code>try_borrow</code> und
<code>try_borrow_mut</code>, die Rückgabe vom Typ <code>Result</code>
haben, anstelle mit <code>panic</code> den Programmabbruch
einzuleiten.

<p>Die folgende Anwendung zeigt eine Funktion, die bestimmt ob
ein Graph mindestens einen Zyklus enthält. Die Überlegung dazu
ist eigentlich recht einfach. Man schreibt naiv die rekursive
Traversierung des Graphen, als wäre es ein Baum oder ein gerichteter
azyklischer Graph. Ein Zyklus ist genau dann vorhanden, wenn das
Programm beim Traversieren auf einen bereits zuvor
ausgeliehenen Knoten trifft.

<pre class="rust ibox">
use std::{rc::Rc, cell::RefCell};

type RcNode = Rc&lt;RefCell&lt;Node&gt;&gt;;

struct Node {
    data: i32, links: Vec&lt;RcNode&gt;
}
impl Node {
    fn new(data: i32, links: Vec&lt;RcNode&gt;) -&gt; RcNode {
        Rc::new(RefCell::new(Node {data, links}))
    }
}

fn is_cyclic(graph: &amp;RcNode) -&gt; bool {
    if let Ok(node) = graph.try_borrow_mut() {
        for link in &amp;node.links {
            if is_cyclic(link) {return true}
        }
        false
    } else {
        true
    }
}
</pre>

<h3>RefCell als Ausweg</h3>

<p>Einige Algorithmen besitzen hinsichtlich alleinigen Leihgaben
eine gewissen Komplexität, so dass es sich schwierig gestalten
kann, eine Formulierung zu finden, die vom Leihgabe-Prüfer
durchgewunken wird. Weiß man sich nicht anders zu helfen,
kann man das Programm mit <code>RefCell</code> letztendlich
aus dieser Problematik entziehen.

<p>Betrachten wir dazu die folgende Implementierung eines
abstrakten Stapels.

<pre class="rust ibox">
use std::{rc::Rc, cell::RefCell};

fn new_stack&lt;T&gt;() -&gt; (impl Fn(T), impl Fn() -&gt; Option&lt;T&gt;) {
    let a = Rc::new(RefCell::new(vec![]));
    let b = a.clone();
    (move |x| a.borrow_mut().push(x), move || b.borrow_mut().pop())
}

fn main() {
    let (push, pop) = new_stack();
    push(1);
    push(2);
    println!("{:?}, {:?}, {:?}", pop(), pop(), pop());
}
</pre>

<p>Die Benutzung von <code>Rc</code> ist hierbei nicht wesentlich.
Eine Umformulierung, bei welcher der Speicher in einer extra Variable
gehalten wird, kommt auch ohne <code>Rc</code> aus.

<pre class="rust ibox">
use std::cell::RefCell;

struct Stack&lt;T&gt;(RefCell&lt;Vec&lt;T&gt;&gt;);

impl&lt;T&gt; Stack&lt;T&gt; {
    fn new() -&gt; Self {
        Stack(RefCell::new(vec![]))
    }
    fn methods&lt;'a&gt;(&amp;'a self)
    -&gt; (impl 'a + Fn(T), impl 'a + Fn()-&gt;Option&lt;T&gt;)
    {
        (move |x| self.0.borrow_mut().push(x),
         move ||  self.0.borrow_mut().pop())
    }
}

fn main() {
    let stack = Stack::new();
    let (push, pop) = stack.methods();
    push(1);
    push(2);
    println!("{:?}, {:?}, {:?}", pop(), pop(), pop());
}
</pre>

<p>In einem nicht-nebenläufigen Programm sind die Funktionsaufrufe
zudem sequenziell, so dass <code>push</code> und <code>pop</code>
niemals gleichzeitig auf den Stapel zugreifen. Allerdings sind alleinige
Leihgaben nicht kopierbar, womit uns die Erstellung beider Closures
ohne <code>RefCell</code> verwehrt bliebe. Um auszudrücken dass die
Leihgaben nur abwechselnd stattfinden, bliebe uns nichts anderes übrig,
als den Stapel aus dem Closure herauszunehmen und auf die übliche
Art als Argument an die Methoden zu übergeben.

<h2 id="DST">Typen dynamischer Größe</h2>

<p>Ein gewöhnlicher Typ besitzt eine feste Größe, d.&nbsp;h. dessen
Werte belegen im Speicher eine feste Zahl von Bytes. Zur
Ermittlung der Größe eines Typs steht die Funktion
<code>size_of</code> zur Verfügung.

<pre class="rust ibox">
use std::mem::size_of;

fn main() {
    println!("{}", size_of::&lt;u8&gt;());
}
</pre>

<p>Es gibt in Rust jedoch auch Typen ohne feste Größe.
Ein Beispiel dafür ist <code>[u8]</code>, bei dem die Abfrage

<pre class="rust ibox">
size_of::&lt;[u8]&gt;()
</pre>

<p>entsprechend verwehrt bleibt. Werte von solchen Typen sind nicht
direkt verwendbar, sondern erfordern Zeiger. Bspw. ist
<code>[u8]</code> als <code>&amp;[u8]</code> oder
<code>Box&lt;[u8]&gt;</code> verwendbar.

<p>Sei <code>DST</code> &ndash; das steht für <i>dynamically sized
type</i> &ndash; ein Typ dynamischer Größe. Man darf zu diesem
die folgenden Typen konstruieren, welche infolge ebenfalls von
dynamischer Größe sind:
<ul>
<li>Regel (1): Den Hülltyp <code>struct S(DST)</code>.
<li>Regel (2): Allgemeiner eine Struktur oder ein Tupel, wo einmalig ein
Eintrag vom Typ <code>DST</code> enthalten ist.
</ul>

<p>Die basalen Typen dynamischer Größe sind die folgenden:
<table class="bt">
<tr>
<th>Typ
<th>Erklärung
<tr>
<td><code>[T]</code>
<td> Ausschnitt eines Feldes vom Typ <code>T</code>
<tr>
<td><code>dyn Trait</code>
<td> Typ des Trait-Objektes vom Trait <code>Trait</code>
</table>

<p>Die Standardbibliothek enthält unter anderem die folgenden
Konstruktionen:
<table class="bt">
<tr>
<th>Typ
<th>Konstruktion
<tr><td><code>str</code>
<td>(1) von <code>[u8]</code> &mdash; wird allerdings als primitiver Typ gehandhabt
<tr><td><code>OsStr</code>
<td>(1) von <code>[u8]</code> &mdash; allerdings ein Implementationsdetail
<tr><td><code>Path</code>
<td>(1) von <code>OsStr</code>
<tr><td><code>RefCell&lt;DST&gt;
<td>(2) von <code>DST</code>
</table>

<p>Die folgenden Zeiger-Typen wandeln einen Typ dynamischer Größe
in einen Typ fester Größe um, wobei zu beachten ist, dass dabei ein
dicker Zeiger entsteht. Dicke Zeiger kommen in zwei Varianten vor.
Bei einem Ausschnitt entsteht ein Paar aus Zeiger und Länge, bei
Trait-Objekt-Typen ein Paar aus Zeiger und Zeiger auf die
Dispatch-Tabelle.

<table class="bt">
<tr><th>Typ<th>Kommentar
<tr><td><code>*const DST</code><td>einfacher Zeiger auf unveränderbare Daten
<tr><td><code>*mut DST</code><td>einfacher Zeiger auf veränderbare Daten
<tr><td><code>&amp;'a DST</code><td>gemeinsame Leihgabe
<tr><td><code>&amp;'a mut DST</code><td>alleinige Leihgabe
<tr><td><code>Box&lt;DST&gt;</code><td>besitzender Zeiger
<tr><td><code>Rc&lt;DST&gt;</code><td>Referenz-gezählter Zeiger
<tr><td><codE>Arc&lt;DST&gt;</code><td>atomar Referenz-gezählter Zeiger
</table>

<h2 id="Ersetzung">Ersetzung von Werten</h2>

<p>In einigen Situationen bekommt eine Prozedur lediglich eine
alleinige Leihgabe eines Eintrages oder Elementes, ohne den Besitz
darüber zu erlangen. Dennoch erreichbar ist vermittels Ersetzung die
Übertragung des Wertes an einen anderen Besitzer. Möglich gemacht
wird dies durch die Funktion <code>replace</code>, die einen anderen
Wert anstelle des ursprünglichen Wertes einsetzt. Notwendig ist
das, weil die Speicherzelle andernfalls ungültig wäre wie eine
uninitialisierte Variable es ist. Dieser Zustand darf nicht sein,
weil die Speichersicherheit in Konsequenz nicht mehr
gewährleistet wäre.

<p>Die Funktion hat die Signatur
<pre class="rust ibox">
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T.
</pre>

<p>Sie gibt den begehrten Wert von <code>dest</code>
(<i>destination</i>, dt. <i>Ziel</i>) zurück und fügt dafür den Wert
von <code>src</code> (<i>source</i>, dt. <i>Quelle</i>) in
<code>dest</code> ein.

<p>Einfaches Beispiel:

<pre class="rust ibox">
fn main() {
    let s1 = &amp;mut String::from("Tee");
    let s2 = std::mem::replace(s1, String::new());
    println!("s1 = '{}', s2 = '{}'", s1, s2);
}
</pre>

<p>Im Beispiel wurde der Wert von <code>s1</code> gegen einen
Dummy-Wert ersetzt, das ist oft eine leere Datenstruktur.
Bemerkenswert ist hierbei, dass die Erzeugung von leeren Dummy-Werten
wie <code>String::new()</code> oder <code>Vec::new()</code>
keiner Allokation von Haldenspeicher bedarf, womit
<code>replace</code> recht flott bleibt.

<p>Weil die Einsetzung von Dummy-Werten recht oft vorkommt, wurde
dafür extra die Komfort-Funktion <code>take</code> geschaffen.
Es ist so, dass <code>String::new()</code> der Vorgabewert
des Typs <code>String</code> ist. Man kann für jeden neuen
Typ durch Implementierung des Traits <code>Default</code> einen
frei wählbaren Vorgabewert erzeugen lassen. So wie
<code>replace</code> beschafft <code>take</code> den begehrten Wert,
fügt an dessen Stelle aber den Vorgabewert ein. Die Implementierung
von <code>take</code> ist denkbar einfach:

<pre class="rust ibox">
fn take&lt;T: Default&gt;(dest: &amp;mut T) -&gt; T {
    replace(dest, T::default())
}
</pre>

<p>Äquivalent zum dargestellten Beispiel ist daher:
<pre class="rust ibox">
fn main() {
    let s1 = &amp;mut String::from("Tee");
    let s2 = std::mem::take(s1);
    println!("s1 = '{}', s2 = '{}'", s1, s2);
}
</pre>

<p>Manchmal liegt ein Typ vor, für den es keinen Dummy-Wert gibt, oder
für den dessen Erzeugung zu Aufwändig wäre. Eine Notlösung besteht
dann darin, den Wert in einer <code>Option</code> einzuhüllen,
denn für <code>Option</code> ist immer der Wert <code>None</code>
als effizienter Dummy verfügbar. Erwartungsgemäß ist <code>None</code>
zudem der Vorgabewert von <code>Option</code>.

<p>Ersetzung macht es außerdem möglich, Typen ohne Trait
<code>Copy</code> in <code>Cell</code> einzuhüllen. Allerdings ist
dies verglichen mit <code>RefCell</code> nicht unbedingt vorteilhaft,
denn zur Modifikation müsste man den Wert erst raus- und dann wieder
reinschieben. Und nicht vergessen: Zudem braucht es dafür
einen effizient erzeugbaren Dummy.

<p>Spitzfindigen wird umgehend auffallen, dass bei
<code>Cell</code> eine separate Ausführung von <code>replace</code>
gebraucht wird. Nämlich um die Hülle abzustreifen, denn andernfalls
bräuchte man für <code>mem::replace</code> eine alleinige Leihgabe
des Inneren von <code>Cell</code>, die es ja nicht geben darf.

<pre class="rust ibox">
use std::cell::Cell;

fn main() {
    let s1 = Cell::new(String::from("Tee"));
    let s2 = s1.replace(String::new());
    println!("{}", s2);
}
</pre>

<p>Die Komfort-Funktion <code>take</code> ist auch mit dabei.
Anstelle <code>s1.replace(String::new())</code> darf man
<code>s1.take()</code> schreiben.

<h2 id="Vertauschung">Vertauschung von Werten</h2>

<p>Gelegentlich notwendig ist die Vertauschung von Werten,
bspw. bei Sortier-Algorithmen. Zwar ist die Vertauschung der
Ersetzung ähnlich, im Unterschied zu dieser kann sie jedoch auch
ohne Dummy-Werte vorgenommen werden. Hat man Besitz, könnte man eine
Vertauschung von Werten mit einer Hilfsvariable <code>h</code>
vornehmen. Betrachten wir dazu die Vertauschung der Komponenten
eines Paares:

<pre class="rust ibox">
fn main() {
    let mut t = (String::from("Tag"), String::from("Nacht"));
    let h = t.0;
    t.0 = t.1;
    t.1 = h;
    println!("{:?}", t);
}
</pre>

<p>In vielen Situationen hat man nun wieder keinen Besitz des Wertes,
sondern nur eine alleinige Leihgabe an diesem. Wir brauchen nur
die Zeile
<pre class="rust ibox">
let mut t = (String::from("Tag"), String::from("Nacht"));
</pre>
zu
<pre class="rust ibox">
let t = &amp;mut (String::from("Tag"), String::from("Nacht"));
</pre>

<p>abändern, und schon verweigert sich der Compiler. Eine Möglichkeit
zur Umgehung der Problematik ist <code>replace</code>. Wir gelangen
zu dieser Formulierung:

<pre class="rust ibox">
fn main() {
    let t = &amp;mut (String::from("Tag"), String::from("Nacht"));
    let h = std::mem::take(&amp;mut t.0);
    t.0 = std::mem::replace(&amp;mut t.1, h);
    println!("{:?}", t);
}
</pre>

<p>Lieber würden wir <code>take</code> vermeiden und

<pre class="rust ibox">
fn main() {
    let mut t = (String::from("Tag"), String::from("Nacht"));
    t.0 = std::mem::replace(&amp;mut t.1, t.0);
    println!("{:?}", t);
}
</pre>

<p>schreiben. Bei der Leihgabe geht das allerdings ebenfalls nicht.
Aufgrund der beschriebenen Problematik und zur Erhöhung der Effizienz
wurde daher die Funktion <code>swap</code> geschaffen, mit der wir
die vernünftige Formulierung

<pre class="rust ibox">
fn main() {
    let t = &amp;mut (String::from("Tag"), String::from("Nacht"));
    std::mem::swap(&amp;mut t.0, &amp;mut t.1);
    println!("{:?}", t);
}
</pre>

<p>erhalten.

<p>Die Funktion <code>swap</code> stellt sogar eine Verallgemeinerung
von <code>replace</code> dar, denn <code>replace</code> lässt
sich mit <code>swap</code> ausdrücken:

<pre class="rust ibox">
fn replace&lt;T&gt;(dest: &amp;mut T, mut src: T) -&gt; T {
    std::mem::swap(dest, &amp;mut src);
    src
}
</pre>

<h2 id="Cow">Zeiger vom Typ Cow</h2>

<p>Hin und wieder kommt eine Situation vor, wo bestimmte Werte
eines Definitionsbereichs auf andere abgebildet werden, ein Großteil
hingegen unverändert bleibt. Betrachten wir dazu die Funktion

<pre class="rust ibox">
fn replace_hyphen(s: &amp;str) -&gt; String {
    s.replace("-", "_")
}
</pre>

<p>die Bindestriche in Zeichenketten gegen Unterstriche ersetzt.
Bei der Anwendung dieser Funktion findet in jedem Fall eine
Speicherallokation und eine Kopie der Daten statt, auch dann wenn die
Kette keine Bindestriche enthält. Nun sind Allokationen und Kopien
ineffizient, und daher möglichst zu vermeiden. Es wäre also schön,
wenn die Funktion das unterlassen würde, solange es nicht notwendig
ist.

<p>Bewerkstelligen tut dies der Typ <code>Cow</code>, der den
Mechanismus <i>Copy-On-Write</i> implementiert, oder genau
genommen <i>Clone-On-Write</i>. Die erste ist die allgemeine
Bezeichnung, die zweite ein Rust-spezifischer Terminus, der
aus der Unterscheidung zwischen <code>Clone</code> und
<code>Copy</code> entspringt.

<p>Mit Hilfe von <code>Cow</code> gelingt die
gewünschte Adaptierung von <code>replace_hyphen</code>.

<pre class="rust ibox">
use std::borrow::Cow;

fn replace_hyphen(s: &amp;str) -&gt; Cow&lt;str&gt; {
    if let Some(_) = s.find('-') {
        Cow::from(s.replace("-", "_"))
    } else {
        Cow::from(s)
    }
}

fn cow_variant(s: &amp;Cow&lt;str&gt;) -&gt; &amp;'static str {
    if let Cow::Owned(_) = s {"Owned"} else {"Borrowed"}
}

fn main() {
    let a = ["Suppe", "Kartoffel-Brokkoli-Suppe"];
    for s in &amp;a {
        let s = replace_hyphen(s);
        println!("{} ({})", s, cow_variant(&amp;s));
    }
}
</pre>

<p>Die Ausgabe:

<pre class="ibox">
Suppe (Borrowed)
Kartoffel_Brokkoli_Suppe (Owned)
</pre>

<p>Der Mechanismus von <code>Cow</code> ist eigentlich kein
großes Geheimnis. Zur Unterscheidung von <code>Borrowed</code>
und <code>Owned</code> dient schlicht eine Enumeration, deren
Nachbildung ohne weitere Umstände machbar ist:

<pre class="rust ibox">
#[derive(Debug)]
enum CowStr&lt;'a&gt; {
    Borrowed(&amp;'a str),
    Owned(String)
}

fn replace_hyphen(s: &amp;str) -&gt; CowStr {
    if let Some(_) = s.find('-') {
        CowStr::Owned(s.replace("-", "_"))
    } else {
        CowStr::Borrowed(s)
    }
}

fn main() {
    let a = ["Suppe", "Kartoffel-Brokkoli-Suppe"];
    for s in &amp;a {
        let s = replace_hyphen(s);
        println!("{:?}", s);
    }
}
</pre>

<h2 id="Freigabe">Freigabe des Speichers</h2>

<p>Verliert ein Wert sämtliche seiner Besitzer, wird dieser schließlich
verworfen. Bei Smart-Pointern wie <code>Box</code> und <code>Rc</code>
wird der vom Wert belegte Speicher hierbei automatisch
freigegeben.

<p>Genau genommen ist jedem Typ je nach seiner Struktur ein
Destruktor zugeordnet. Zum Einen ist in diesem ein vom Compiler
automatisch erzeugter Code enthalten, welcher die entsprechenden
Destruktoren der Bestandteile aufruft. Zum Anderen kann man diesem
Code zusätzliche Funktionalität voranstellen, indem
der Trait <code>Drop</code> implementiert wird.

<p>Bei lokalen Variablen findet der Destruktor-Aufruf statt,
sobald die Variable out of scope geht, d.&nbsp;h. ihr lexikalischer
Bereich endet. Betrachten wir dazu dieses Programm:

<pre class="rust ibox">
struct Duck {name: String}

impl Duck {
    fn dive(&amp;self) {
        println!("{} taucht.", self.name);
    }
}

impl Drop for Duck {
    fn drop(&amp;mut self) {
        println!("{} fliegt davon!", self.name);
    }
}

fn main() {
    let duck = Duck {name: String::from("Donald")};
    duck.dive();
    println!("Programm endet.");
}
</pre>

<p>Die Ausgabe ist:

<pre class="ibox">
Donald taucht.
Programm endet.
Donald fliegt davon!
</pre>

<p>Man kann einen vorzeitigen Destruktor-Aufruf durch
Besitzübergabe an <code>mem::drop</code> erzwingen:

<pre class="rust ibox">
fn main() {
    let duck = Duck {name: String::from("Donald")};
    duck.dive();
    std::mem::drop(duck);
    println!("Programm endet.");
}
</pre>

<p>Oder durch Einschließung des Programmteils in einen kürzeren
Bereich:

<pre class="rust ibox">
fn main() {
    {
        let duck = Duck {name: String::from("Donald")};
        duck.dive();
    }
    println!("Programm endet.");
}
</pre>

<p>Die Ausgabe ist dann von dieser Reihenfolge:

<pre class="ibox">
Donald taucht.
Donald fliegt davon!
Programm endet.
</pre>

<p>Auch Smart-Pointer-Typen wie <code>Rc</code> besitzen einen
Destruktor. Bei <code>Rc</code> übernimmt <code>drop</code> die
Dekrementierung des Referenz-Zählers. Der Aufruf des Destruktors der
eigentlichen Daten findet hierbei erst dann statt, wenn der
Referenz-Zähler den Wert null erreicht.

<p>Die freistehende Funktion <code>mem::drop</code> ist streng von
der Methode <code>drop</code> zu unterscheiden. Während
<code>mem::drop</code> ihr Argument aufisst und dadurch den
vollen Destruktor ausführt, enthält die Methode
<code>drop</code> nur die zusätzliche Funktionalität, die lediglich
einen Teil des Destruktors darstellt.

<h2 id="Literatur">Literatur</h2>

<ol>
<li id="1">Alice Ryhl: »<a href="https://ryhl.io/blog/temporary-shared-mutation/"
  >Temporarily opt-in to shared mutation</a>«. (15. August 2020).
</ol>

</body>
</html>
