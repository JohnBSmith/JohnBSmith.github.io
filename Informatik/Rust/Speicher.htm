<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Speicherverwaltung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Zeiger">Zeiger</a>
<li><a href="#Allokation">Allokation</a>
<li><a href="#Box">Zeiger vom Typ Box</a>
<li><a href="#Rc">Zeiger vom Typ Rc</a>
<li><a href="#Cell">Zellen vom Typ Cell</a>
<li><a href="#RefCell">Zellen vom Typ RefCell</a>
<li><a href="#DST">Typen dynamischer Größe</a>
<li><a href="#Literatur">Literatur</a>
</ol>

<h2 id="Zeiger">Zeiger</h2>

<p>Ein Zeiger ist eine Variable, die die Speicheradresse einer
anderen Variable als Wert enthält.

<h3>Zeigerarithmetik</h3>

<p>Die in Hochsprache formulierte Funktion
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for x in a {
        println!("{}",x);
    }
}
</pre>

<p>nimmt nach Absenkung diese Gestalt an:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let p_end = unsafe{p.add(a.len())};
    while p != p_end {
        println!("{}",unsafe{*p});
        p = unsafe{p.add(1)};
    }
}
</pre>

<p>Oder alternativ:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let mut n = a.len();
    while n&gt;0 {
        println!("{}",unsafe{*p});
        p = unsafe{p.add(1)};
        n -= 1;
    }
}
</pre>

<p>Die Formulierung
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for i in 0..a.len() {
        println!("{}",a[i]);
    }
}
</pre>

<p>entspricht
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let p = a.as_ptr();
    let n = a.len();
    let mut i = 0;
    while i&lt;n {
        println!("{}",unsafe{*p.add(i)});
        i += 1;
    }
}
</pre>

<h2 id="Allokation">Allokation</h2>

<p>Die Daten, die ein Programm verarbeitet, müssen notgedrungen auf
irgendeine Art im RAM-Speicher des Computers untergebracht werden.
Dafür gibt es zwei Verfahren:

<dl class="indent">
<dt><b>1. Stapelspeicher, engl. <i>stack</i></b>
<dd>Die Zuweisung von Speicher geschieht hier besonders
schnell, da dafür lediglich der Stapelzeiger, engl.
<i>stack pointer</i>, inkrementiert werden braucht. Allerdings muss
der Speicher aus diesem Grund auch in der umgekehrten Reihenfolge
freigegeben werden, wie er zugewiesen wurde. Weil dies nun gerade
der Verwaltung von lokalen Variablen beim Aufrufen und Verlassen von
Unterprogrammen entspricht, arbeiten die meisten Laufzeitsysteme
bevorzugt mit dem Stack.

<dt><b>2. Haldenspeicher, engl. <i>heap</i></b>
<dd>Bei diesem darf Speicher in beliebiger Reihenfolge zugewiesen
und freigegeben werden. Infolge ist der Heap vergleichsweise
kompliziert und langsam.
</dl>

<h2 id="Box">Zeiger vom Typ Box</h2>

<p>Die folgende Funktion <code>new_data</code> gibt ein Array
zurück, das bspw. Bilddaten eines Bildes mit Breite 480 Pixel
und Höhe 300 Pixel aufnehmen soll.

<pre class="rust ibox">
const DATA_LEN: usize = 480*300;

fn new_data() -&gt; [u32; DATA_LEN] {
    [0; DATA_LEN]
}
</pre>

<p>Nun ist der Stack in nativen Laufzeitsystemen begrenzt. Typische
Werte für die Begrenzung liegen bei 1 bis 10&nbsp;MB. Zwar lässt sich
dies ändern, bspw. indem das Hauptprogramm in einem neuen Thread
mit größerem Stack ausgeführt wird, nehmen wir aber zunächst an, dies
wäre uns nicht gegeben. Wollen wir nun ein größeres Array speichern,
oder ein Array von Arrays, ist der Stapel bald aufgebraucht.

<p>Für gewöhnlich wird für solche Datenmengen stattdessen
Haldenspeicher zugewiesen. Dafür zuständig ist die Funktion
<code>Box::new</code>, die einen Zeiger auf den zugewiesenen
Speicher zurückgibt. 

<pre class="rust ibox">
fn new_data() -&gt; Box&lt;[u32; DATA_LEN]&gt; {
    Box::new([0; DATA_LEN])
}
</pre>

<p>Bei einem Zeiger vom Typ <code>Box</code> handelt es sich um einen
sogenannten <i>Smart-Pointer</i>. Ein solcher zeichnet sich durch die
Eigenschaft aus, dass der Speicher automatisch wieder freigegeben wird,
sobald die Lebenszeit des Zeigerwertes endet.

<h2 id="Rc">Zeiger vom Typ Rc</h2>

<h3>Gemeinsamer Besitz</h3>

<p>Stellt man sich Zeiger als Speicheradressen vor, liegt der Gedanke
nicht fern, mehrere Zeiger auf den gleichen Wert zeigen zu lassen.
Der Typ <code>Box</code> schließt dies jedoch aus, weil ein Zeiger
dieses Typs der Besitzer des Wertes ist. Wir müssen uns hierzu
daran erinnern, dass die Unteilbarkeit von Besitzerschaft eine
entscheidende Eigenschaft des Typsystems ist.

<p>Was man ohne Frage tun kann, ist die Erstellung beliebig
vieler Zeiger vom Typ <code>&amp;Box&lt;T&gt;</code>, da diese
nur Leihgaben darstellen. Dies bringt jedoch eine Reihe von
Problemen mit sich:

<ul>
<li>Sobald es zu einer Leihgabe kommt, ist die den Wert tragende
Datenstruktur als zugrundeliegender Besitzer gefroren.
Andernfalls könnte man den Wert entfernen oder verschieben,
was zu Use after free führen würde.

<li>Denkbar sind Situationen, wo man Zeiger auf denselben Wert in zwei
oder mehreren Datenstrukturen speichern möchte, wo nicht bekannt ist,
welcher Zeiger von längerer Lebenszeit ist.
</ul>

<p>Eine Lösung für die Problematik bestünde in der Benutzung eines
sogenannten Arena-Allokators. Bei diesem dauert die Lebenszeit aller
erstellten Werte genau so lange an wie die des Allokators.
Das heißt, im Unterschied zu einem gewöhnlichen Allokator sind
Freigaben nicht zu beliebigen Zeitpunkten möglich. Eines Besitzers
bedarf es nicht mehr, weil die Arena der eigentliche Besitzer ist.
An dieser Stelle soll nicht näher auf dieses Konzept eingegangen werden.

<p>Eigentlich ist die Forderung nach Unteilbarkeit von Besitzerschaft
zu streng. Solange einem Wert keine Veränderung widerfährt, dürfte
es mehrere Zeiger auf diesen geben. Nur dann muss der Wert solange
erhalten bleiben, bis der letzte Zeiger verschwunden ist. Allerdings
wissen wir nicht immer, in welcher Reihenfolge die Zeiger kommen
und gehen. Diesem Umstand trägt die Benutzung eines Referenzzählers
Rechnung, der dem Wert hinzugefügt wird. Der Referenzzähler zählt die
Anzahl vorhandener Zeiger. Bei der Erstellung eines neuen Zeigers wird
dieser um eins erhöht, beim Verschwinden eines Zeigers um eins
erniedrigt.

<p>Der Mechanismus der Referenzzählung ist durch den Typ
<code>Rc</code> implementiert, das steht für <i>reference counted</i>.
So wie bei <code>Box</code> ist der Speicherplatz, auf den der
Zeiger zeigt, auf der Halde alloziert. Erstellt wird eine neue
Allokation mit <code>Rc::new</code> oder <code>Rc::from</code>.
Die Methode <code>Rc::clone</code> bewirkt gerade nicht eine
Kopie der Daten, sondern nur eine Kopie des Zeigers und entsprechend
eine Inkrementation des Referenzzählers.

<p>Ein Beispiel zur Benutzung von <code>Rc</code> bieten
Ausschnitte mit Besitzerschaft. Betrachten wir zunächst 
folgendes Programm.

<pre class="rust ibox">
fn main() {
    let slice: &amp;[u8] = &amp;[0, 0, 0, 0, 1, 1, 1, 1];
    let sub_slice = &amp;slice[4..8];
    println!("{:?}", sub_slice);
}
</pre>

<p>Die Ausschnitte bedingen hier Leihgaben der zugrunde liegenden
Bytesequenz. Stattdessen wollen wir nun Ausschnitte mit gemeinsamer
Besitzerschaft an der Bytesequenz haben. Um dies zu erreichen,
konstruieren wir für diese Ausschnitte den neuen Typ <code>Slice</code>,
dessen Eintrag <code>data</code> eine gezählte Referenz auf die
Bytesequenz ist.

<pre class="rust ibox">
use std::{fmt, rc::Rc, ops::Range};

struct Slice {
    data: Rc&lt;[u8]&gt;,
    start: usize,
    len: usize
}
impl Slice {
    fn new(data: Rc&lt;[u8]&gt;) -&gt; Self {
        let len = data.len();
        Self{data, start: 0, len}
    }
    fn slice(&amp;self, r: Range&lt;usize&gt;) -&gt; Self {
        let start = self.start + r.start;
        let len = r.end - r.start;
        Self{data: self.data.clone(), start, len}    
    }
}

impl fmt::Debug for Slice {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let start = self.start;
        write!(f, "{:?}", &amp;self.data[start..start+self.len])
    }
}

fn main() {
    let data: Rc&lt;[u8]&gt; = Rc::from([0, 0, 0, 0, 1, 1, 1, 1]);
    let slice = Slice::new(data);
    let sub_slice = slice.slice(4..8);
    println!("{:?}", sub_slice);
}
</pre>

<p>Wir müssen näher darauf blicken, was hier gemacht wurde. Der Typ
<code>&amp;[u8]</code> ist eigentlich über Lebenszeiten
parametrisiert, die Notation unterdrückt dies bloß. Bei der Definition
eines Aliastypen tritt die Abhängigkeit von der Lebenszeit
explizit hervor:

<pre class="rust ibox">
type BorrowSlice&lt;'a&gt; = &amp;'a [u8];
</pre>

<p>Im Typ <code>Slice</code> ist diese Parametrisierung verloren
gegangen. Der Typ <code>Slice</code> ist demnach nicht mehr von
der Lebenszeit eines anderen Datums abhängig.

<h3>Zur Laufzeit erzeugte Symbole</h3>

<p>Brauchbar ist <code>Rc</code> auch zur Erzeugung von Symbolen.
Unter einem Symbolvorrat wollen wir schlicht einen Wertebereich
verstehen, dessen Elemente schnell zu kopieren und zu vergleichen
sind. Ist der Symbolvorrat bereits zur Kompilierzeit bekannt, würde man
diesen als Enumeration darstellen. Ist der Vorrat allerdings erst
zur Laufzeit bekannt, muss man sich eine andere Darstellung überlegen.

<p>Eine Idee ist die Darstellung von Symbolen als Zeiger. Zwei
Symbole sind genau dann gleich, wenn die Zeiger auf dasselbe
Objekt zeigen. Demnach wird mit <code>Rc::new</code> einmalig ein
neues Symbol erzeugt, das irgendwo in der Laufzeitumgebung oder
einer zugänglichen Datenstruktur hinterlegt werden muss. Von diesem
lassen sich nun mit <code>Rc::clone</code> beliebig viele Kopien
anfertigen. Zum Vergleich zweier Symbole wird <code>Rc::ptr_eq</code>
genutzt.

<pre class="rust ibox">
use std::rc::Rc;

fn main() {
    let a = Rc::new(());
    let b = a.clone();
    assert!(Rc::ptr_eq(&amp;a,&amp;b));
}
</pre>

<p>Durchaus bestehen noch andere Wege zur Darstellung von Symbolen.
Effizient ist bspw. ein Zähler in der Laufzeitumgebung.
Zur Erzeugung eines neuen Symbols wird das Symbol als Zählerwert
dargestellt und der Zähler zudem inkrementiert, womit garantiert ist,
dass jedes mal ein neues, einmaliges &ndash; d.&nbsp;h. zu allen
anderen verschiedenes &ndash; Symbol geschaffen wird.

<p>Allerdings bietet <code>Rc</code> zusätzlich die Möglichkeit,
Symbole mit einem Namen zu versehen. Zu beachten ist hierbei,
dass unterschiedliche Symbole den gleichen Namen tragen
dürfen, was zur Verwirrung führen kann.

<pre class="rust ibox">
use std::rc::Rc;

fn main() {
    let a: Rc&lt;str&gt; = Rc::from("A");
    let b = a.clone();
    assert!(Rc::ptr_eq(&amp;a,&amp;b));
    println!("{}", a);
}
</pre>

<p>Zur Bemerkung sei noch erwähnt, dass <code>Rc::ptr_eq</code>
bei <code>Rc&lt;str&gt;</code> sowohl den Zeiger als auch die
Länge vergleicht. Effizienter ist für unseren Zweck der reine
Vergleich der Zeiger. Dies wird durch die folgende
Funktion <code>ptr_eq_plain</code> erreicht. 

<pre class="rust ibox">
fn ptr_eq_plain&lt;T: ?Sized&gt;(p: &amp;Rc&lt;T&gt;, q: &amp;Rc&lt;T&gt;) -&gt; bool {
    let p = &amp;**p as *const T as *const ();
    let q = &amp;**q as *const T as *const ();
    std::ptr::eq(p,q)
}
</pre>

<p>Wie man Symbole im Zusammenhang mit Hashtabellen benutzt,
wurde im Abschnitt ›<a href="Behaelter.htm#Eq-Zeiger"
>Behälter: Hashtabellen: Äquivalenz per Zeigervergleich</a>‹ schon
erläutert.

<h2 id="Cell">Zellen vom Typ Cell</h2>

<h3>Grundmechanismus</h3>

<p>Der Typ <code>Rc</code> gewährt nur gemeinsame Referenzen, womit
die Daten darunter unveränderlich bleiben. Infolge liegt die gesamte
Datenstruktur immerwährend fest wie ein Kristall. Einem gleichartigen
Problem steht man auch in anderen Situationen gegenüber, &ndash;
überall dort, wo man nur gemeinsame Referenzen bekommt. Dem Ziel
der Programmierung von dynamischen Datenstrukturen läuft diese
Einschränkung offensichtlich zuwider. Zur Auflösung dieser
Einschränkung stehen daher ausgeklügelte Mechanismen zur Verfügung.

<p>Erinnern wir uns daran, dass bei gemeinsamen Referenzen
Veränderungen an den Daten verboten sind, weil es sonst zu Aliasing
und Use after free kommen kann. Einen Teil der Daten unter einer
gemeinsamen Referenz wollen wir nun dennoch verändern dürfen.
Angenommen, wir verbieten Zeiger auf diesen Teil, womit dieser Teil nur
als Ganzes gelesen und geschrieben werden darf,
dann dürfte es niemals zu den genannten Problemen kommen.

<p>Mit der technischen Ausgestaltung dieser Idee ist der Typ
<code>Cell</code> entstanden. Einen Zeiger auf das Innere eines
Wertes dieses Typs kann man nicht bekommen. Lediglich ist es gestattet,
die Zelle mit der Methode <code>Cell::get</code> gänzlich zu
lesen oder mit <code>Cell:set</code> gänzlich zu schreiben.
Außerdem gibt es noch ein paar Hilfsmethoden zum flexibleren
Ausreizen der zugrundeliegenden Idee.

<p>Eine Anwendung von <code>Cell</code> zeigt die folgende
Implementierung eines Zählers, der sich auch dann verändern
darf, wenn man nur »veränderungslosen« Zugriff auf ihn hat.

<pre class="rust ibox">
use std::{rc::Rc, cell::Cell};

struct Counter {
    value: Cell&lt;u32&gt;
}
impl Counter {
    fn new() -&gt; Self {
        Self{value: Cell::new(0)}
    }
    fn next(&amp;self) -&gt; u32 {
        let value = self.value.get();
        self.value.set(value + 1);
        value
    }
}

fn main() {
    // Scheinbar absurd: Veränderung hinter einer
    // gemeinsamen Referenz.
    let counter = &amp;Counter::new();
    println!("{}", counter.next());
    println!("{}", counter.next());

    // Entsprechend erlaubt.
    let counter = Rc::new(Counter::new());
    println!("{}", counter.next());
    println!("{}", counter.next());
}
</pre>

<h3>Projektion von Ausschnitten</h3>

<p>Zu Produkttypen wie Strukturen, Tupeln und Feldern gehören
Projektionen auf ihre Elemente. Zum Zugriff über Leihgaben muss
hierbei auch die Projektion über Leihgaben formuliert sein.
Für Ausschnitte ist die Projektion so definiert:

<pre class="rust ibox">
fn proj&lt;T&gt;(a: &amp;[T], i: usize) -> &amp;T {
    &amp;a[i]
}
</pre>

<p>Entsprechend ist definiert:

<pre class="rust ibox">
fn proj_mut&lt;T&gt;(a: &amp;mut [T], i: usize) -> &amp;mut T {
    &amp;mut a[i]
}
</pre>

<p>Nun lässt sich zu jedem Typ <code>T</code> der Typ
<code>&amp;mut T</code> als in einer Subtyp-ähnlichen Beziehung zu
<code>&amp;Cell&lt;T&gt;</code> betrachten. Die Rolle des Upcasts
nimmt hierbei <code>Cell::from_mut</code> mit der Signatur

<pre class="rust indent">
fn from_mut(t: &amp;mut T) -> &amp;Cell&lt;T&gt;
</pre>

<p>ein. Speziell können wir <code>&amp;mut [T]</code> in
<code>&amp;Cell&lt;[T]&gt;</code> umwandeln. Nun würden wir den
Ausschnitt gerne indizieren. Das heißt, wir brauchen nicht den
Zugriff auf den Ausschnitt als Ganzes, sondern die Projektionen
auf dessen Elemente. Das notwendige Hilfsmittel dafür ist die Methode
<code>as_slice_of_cells</code>, die <code>&amp;Cell&lt;[T]&gt;</code>
weiter in <code>&amp;[Cell&lt;T&gt;]</code> umwandelt.

<p>Der Nutzen liegt darin, gleichzeitig <i>mit Zeigern</i> über ein
Feld iterieren zu können, während dessen Elemente modifiziert werden.
Betrachten wir bspw. die folgende Implementierung von Buble sort.

<pre class="rust ibox">
fn bubble_sort&lt;T: Ord&gt;(a: &amp;mut [T]) {
    let n = a.len();
    for _ in 0..n {
        for i in 1..n {
            if a[i] &lt; a[i-1] {a.swap(i,i-1);}
        }
    }
}
</pre>

<p>Bei der Indizierung tritt für gewöhnlich eine Bereichsprüfung
auf. Manchmal sieht sich der Compiler auch in der Lage, diese
während der Optimierung zu entfernen. Ein alternativer Weg
ist die Benutzung von Zeigern anstelle von Indizes. Wir würden
gerne schreiben:

<pre class="rust ibox">
fn bubble_sort&lt;T: Ord&gt;(a: &amp;mut [T]) {
    for _ in 0..a.len() {
        let mut y = &amp;mut a[0];
        for x in &amp;mut a[1..] {
            if x &lt; y {std::mem::swap(x,y);}
            y = x;
        }
    }
}
</pre>

<p>Jedoch ist dieses Programm nicht kompilierbar, weil zwei
alleinige Leihgaben des gleichen Ausschnitts verboten sind.
Der beschriebene Formalismus eröffnet nun eine Formulierung,
bei welcher stattdessen gemeinsame Leihgaben auftreten.

<pre class="rust ibox">
use std::cell::Cell;

fn bubble_sort&lt;T: Ord + Copy&gt;(a: &amp;mut [T]) {
    let a = Cell::from_mut(a).as_slice_of_cells();
    for _ in 0..a.len() {
        let mut y = &amp;a[0];
        for x in &amp;a[1..] {
            if x.get() &lt; y.get() {Cell::swap(x,y);}
            y = x;
        }
    }
}
</pre>

<p>Ein praktischeres Beispiel bietet die folgende Implementierung
von <code>Vec::retain</code>.<sup><a href="#1">1</a></sup>
Da das Prädikat für die Betrachtung nicht wesentlich ist,
sei es zur Vereinfachung auf <code>is_even</code> festgelegt.
Die Formulierung mit Indizierung:

<pre class="rust ibox">
fn retain_even(a: &amp;mut Vec&lt;i32&gt;) {
    let mut i = 0;
    for j in 0..a.len() {
        if is_even(a[j]) {
            a[i] = a[j];
            i += 1;
        }
    }
    a.truncate(i);
}
</pre>

<p>Die Formulierung mit einem Zeiger:
<pre class="rust ibox">
use std::cell::Cell;

fn retain_even(a: &amp;mut Vec&lt;i32&gt;) {
    let s = Cell::from_mut(&amp;mut a[..]).as_slice_of_cells();
    let mut i = 0;
    for x in s.iter().filter(|x| is_even(x.get())) {
        s[i].set(x.get());
        i += 1;
    }
    a.truncate(i);
}
</pre>

<h2 id="RefCell">Zellen vom Typ RefCell</h2>

<h3>Grundmechanismus</h3>
<p>Leider ist <code>Cell</code> nur für kleine Typen mit Trait
<code>Copy</code> effizient, womit <code>Cell</code> auf
spezielle Situationen beschränkt bleibt. Ein allgemeiner
Mechanismus liegt mit <code>RefCell</code> vor. So wie
<code>Cell</code> gewährt eine Zelle vom Typ <code>RefCell</code>
Veränderungen innerhalb von gemeinsamen Leihgaben. Im Unterschied
zu <code>Cell</code> erlaubt <code>RefCell</code> das 
eigentlich Verbotene &ndash; eine alleinige Leihgabe eines Teils
einer gemeinsamen Leihgabe.

<p>Wie kann das möglich sein? Der Compiler verhindert Aliasing
normalerweise, indem zur Kompilierzeit geprüft wird, dass für
Veränderungen immer nur eine einzige alleinige Leihgabe vorhanden ist.
Der Mechanismus von <code>RefCell</code> besteht nun gerade darin,
diese Prüfung stattdessen zur Laufzeit vorzunehmen, womit wir einen
großen Sprung an Flexibilität gewinnen. Zur Umsetzung fügt
<code>RefCell&lt;T&gt;</code> dem Wert des Typs <code>T</code>
einen Referenzzähler hinzu. Man kann dann mit <code>borrow</code>
beliebig viele gemeinsame Leihgaben bekommen, oder mit
<code>borrow_mut</code> eine alleinige Leihgabe. Die technische
Umsetzung kann man so konstruieren:

<ul>
<li>Mit <code>borrow</code> wird der Referenzzähler um eins
erhöht, aber nur falls er nicht-negativ ist. Andernfalls kommt
es zum Programmabbruch.
<li>Mit <code>borrow_mut</code> wird der Referenzzähler auf &minus;1
erniedrigt, aber nur falls er null war. Andernfalls kommt es
zum Programmabbruch.
</ul>

<p>Es folgt ein erstes einfaches Beispiel, &ndash; die Implementierung
des bereits zuvor beschriebenen Zählers <code>Counter</code>, aber
dieses Mal mit <code>RefCell</code> anstelle von <code>Cell</code>.

<pre class="rust ibox">
use std::cell::RefCell;

struct Counter {
    value: RefCell&lt;u32&gt;
}
impl Counter {
    fn new() -&gt; Self {
        Self{value: RefCell::new(0)}
    }
    fn next(&amp;self) -&gt; u32 {
        let mut p = self.value.borrow_mut();
        let value = *p;
        *p = value + 1;
        value
    }
}
</pre>

<h3>Fehlbares Ausleihen</h3>

<p>Die Methoden <code>borrow</code> und <code>borrow_mut</code>
besitzen die totalen Pendants <code>try_borrow</code> und
<code>try_borrow_mut</code>, die Rückgabe vom Typ <code>Result</code>
haben, anstelle mit <code>panic</code> den Programmabbruch
einzuleiten.

<p>Die folgende Anwendung zeigt eine Funktion, die bestimmt ob
ein Graph mindestens einen Zyklus enthält. Die Überlegung dazu
ist eigentlich recht einfach. Man schreibt naiv die rekursive
Traversierung des Graphen, als wäre es ein Baum oder ein gerichteter
azyklischer Graph. Ein Zyklus ist genau dann vorhanden, wenn das
Programm beim Traversieren auf einen bereits zuvor
ausgeliehenen Knoten trifft.

<pre class="rust ibox">
use std::{rc::Rc, cell::RefCell};

type RcNode = Rc&lt;RefCell&lt;Node&gt;&gt;;

struct Node {
    data: i32, links: Vec&lt;RcNode&gt;
}
impl Node {
    fn new(data: i32, links: Vec&lt;RcNode&gt;) -&gt; RcNode {
        Rc::new(RefCell::new(Node{data, links}))
    }
}

fn is_cyclic(graph: &amp;RcNode) -&gt; bool {
    if let Ok(node) = graph.try_borrow_mut() {
        for link in &amp;node.links {
            if is_cyclic(link) {return true}
        }
        false
    } else {
        true
    }
}
</pre>

<h3>RefCell als Ausweg</h3>

<p>Einige Algorithmen besitzen hinsichtlich alleinigen Leihgaben
eine gewissen Komplexität, so dass es sich schwierig gestalten
kann, eine Formulierung zu finden, die vom Leihgabe-Prüfer
durchgewunken wird. Weiß man sich nicht anders zu helfen,
kann man das Programm mit <code>RefCell</code> letztendlich
aus dieser Problematik entziehen.

<p>Betrachten wir dazu die folgende Implementierung eines
abstrakten Stapels.

<pre class="rust ibox">
use std::{rc::Rc, cell::RefCell};

fn new_stack&lt;T&gt;() -&gt; (impl Fn(T), impl Fn() -&gt; Option&lt;T&gt;) {
    let a = Rc::new(RefCell::new(vec![]));
    let b = a.clone();
    (move |x| a.borrow_mut().push(x), move || b.borrow_mut().pop())
}

fn main() {
    let (push, pop) = new_stack();
    push(1);
    push(2);
    println!("{:?}, {:?}, {:?}", pop(), pop(), pop());
}
</pre>

<p>Die Benutzung von <code>Rc</code> ist hierbei nicht wesentlich.
Eine Umformulierung, bei welcher der Speicher in einer extra Variable
gehalten wird, kommt auch ohne <code>Rc</code> aus.

<pre class="rust ibox">
use std::cell::RefCell;

struct Stack&lt;T&gt;(RefCell&lt;Vec&lt;T&gt;&gt;);

impl&lt;T&gt; Stack&lt;T&gt; {
    fn new() -&gt; Self {
        Stack(RefCell::new(vec![]))
    }
    fn methods&lt;'a&gt;(&amp;'a self)
    -&gt; (impl 'a + Fn(T), impl 'a + Fn()-&gt;Option&lt;T&gt;)
    {
        (move |x| self.0.borrow_mut().push(x),
         move ||  self.0.borrow_mut().pop())
    }
}

fn main() {
    let stack = Stack::new();
    let (push, pop) = stack.methods();
    push(1);
    push(2);
    println!("{:?}, {:?}, {:?}", pop(), pop(), pop());
}
</pre>

<p>In einem nicht-nebenläufigen Programm sind die Funktionsaufrufe
zudem sequenziell, so dass <code>push</code> und <code>pop</code>
niemals gleichzeitig auf den Stapel zugreifen. Allerdings sind alleinige
Leihgaben nicht kopierbar, womit uns die Erstellung beider Closures
ohne <code>RefCell</code> verwehrt bliebe. Um auszudrücken dass die
Leihgaben nur abwechselnd stattfinden, bliebe uns nichts anderes übrig,
als den Stapel aus dem Closure herauszunehmen und auf die übliche
Art als Argument an die Methoden zu übergeben.

<h2 id="DST">Typen dynamischer Größe</h2>

<p>Ein gewöhnlicher Typ besitzt eine feste Größe, d.&nbsp;h. dessen
Werte belegen im Speicher eine feste Zahl von Bytes. Zur
Ermittlung der Größe eines Typs steht die Funktion
<code>size_of</code> zur Verfügung.

<pre class="rust ibox">
use std::mem::size_of;

fn main() {
    println!("{}", size_of::&lt;u8&gt;());
}
</pre>

<p>Es gibt in Rust jedoch auch Typen ohne feste Größe.
Ein Beispiel dafür ist <code>[u8]</code>, bei dem die Abfrage

<pre class="rust ibox">
size_of::&lt;[u8]&gt;()
</pre>

<p>entsprechend verwehrt bleibt. Werte von solchen Typen sind nicht
direkt verwendbar, sondern erfordern Zeiger. Bspw. ist
<code>[u8]</code> als <code>&amp;[u8]</code> oder
<code>Box&lt;[u8]&gt;</code> verwendbar.

<p>Sei <code>DST</code> &ndash; das steht für <i>dynamically sized
type</i> &ndash; ein Typ dynamischer Größe. Man darf zu diesem
die folgenden Typen konstruieren, welche infolge ebenfalls von
dynamischer Größe sind:
<ul>
<li>Regel (1): Den Hülltyp <code>struct S(DST)</code>.
<li>Regel (2): Allgemeiner eine Struktur oder ein Tupel, wo einmalig ein
Eintrag vom Typ <code>DST</code> enthalten ist.
</ul>

<p>Die basalen Typen dynamischer Größe sind die folgenden:
<table class="bt">
<tr>
<th>Typ
<th>Erklärung
<tr>
<td><code>[T]</code>
<td> Ausschnitt eines Feldes vom Typ <code>T</code>
<tr>
<td><code>dyn Trait</code>
<td> Typ des Trait-Objektes vom Trait <code>Trait</code>
</table>

<p>Die Standardbibliothek enthält unter anderem die folgenden
Konstruktionen:
<table class="bt">
<tr>
<th>Typ
<th>Konstruktion
<tr><td><code>str</code>
<td>(1) von <code>[u8]</code> &mdash; wird allerdings als primitiver Typ gehandhabt
<tr><td><code>OsStr</code>
<td>(1) von <code>[u8]</code> &mdash; allerdings ein Implementationsdetail
<tr><td><code>Path</code>
<td>(1) von <code>OsStr</code>
<tr><td><code>RefCell&lt;DST&gt;
<td>(2) von <code>DST</code>
</table>

<p>Die folgenden Zeiger-Typen wandeln einen Typ dynamischer Größe
in einen Typ fester Größe um, wobei zu beachten ist, dass dabei ein
dicker Zeiger entsteht. Dicke Zeiger kommen in zwei Varianten vor.
Bei einem Ausschnitt entsteht ein Paar aus Zeiger und Länge, bei
Trait-Objekt-Typen ein Paar aus Zeiger und Zeiger auf die
Dispatch-Tabelle.

<table class="bt">
<tr><th>Typ<th>Kommentar
<tr><td><code>*const DST</code><td>einfacher Zeiger auf unveränderbare Daten
<tr><td><code>*mut DST</code><td>einfacher Zeiger auf veränderbare Daten
<tr><td><code>&amp;'a DST</code><td>gemeinsame Leihgabe
<tr><td><code>&amp;'a mut DST</code><td>alleinige Leihgabe
<tr><td><code>Box&lt;DST&gt;</code><td>besitzender Zeiger
<tr><td><code>Rc&lt;DST&gt;</code><td>Referenz-gezählter Zeiger
<tr><td><codE>Arc&lt;DST&gt;</code><td>atomar Referenz-gezählter Zeiger
</table>

<h2 id="Literatur">Literatur</h2>

<ol>
<li id="1">Alice Ryhl: »<a href="https://ryhl.io/blog/temporary-shared-mutation/"
  >Temporarily opt-in to shared mutation</a>«. (15. August 2020).
</ol>

</body>
</html>
