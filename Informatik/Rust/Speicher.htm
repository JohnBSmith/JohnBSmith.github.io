<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Speicherverwaltung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Zeiger">Zeiger</a>
<li><a href="#Allokation">Allokation</a>
<li><a href="#Box">Zeiger vom Typ Box</a>
<li><a href="#Rc">Zeiger vom Typ Rc</a>
<li><a href="#Cell">Zellen vom Typ Cell</a>
<li><a href="#RefCell">Zellen vom Typ RefCell</a>
</ol>

<h2 id="Zeiger">Zeiger</h2>

<p>Ein Zeiger ist eine Variable, die die Speicheradresse einer
anderen Variable als Wert enthält.

<h3>Zeigerarithmetik</h3>

<p>Die in Hochsprache formulierte Funktion
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for x in a {
        println!("{}",x);
    }
}
</pre>

<p>nimmt nach Absenkung diese Gestalt an:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let p_end = unsafe{p.add(a.len())};
    while p != p_end {
        println!("{}",unsafe{*p});
        p = unsafe{p.add(1)};
    }
}
</pre>

<p>Oder alternativ:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let mut n = a.len();
    while n&gt;0 {
        println!("{}",unsafe{*p});
        p = unsafe{p.add(1)};
        n -= 1;
    }
}
</pre>

<p>Die Formulierung
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for i in 0..a.len() {
        println!("{}",a[i]);
    }
}
</pre>

<p>entspricht
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let p = a.as_ptr();
    let n = a.len();
    let mut i = 0;
    while i&lt;n {
        println!("{}",unsafe{*p.add(i)});
        i += 1;
    }
}
</pre>

<h2 id="Allokation">Allokation</h2>

<p>Die Daten, die ein Programm verarbeitet, müssen notgedrungen auf
irgendeine Art im RAM-Speicher des Computers untergebracht werden.
Dafür gibt es zwei Verfahren:

<dl class="indent">
<dt><b>1. Stapelspeicher, engl. <i>stack</i></b>
<dd>Die Zuweisung von Speicher geschieht hier besonders
schnell, da dafür lediglich der Stapelzeiger, engl.
<i>stack pointer</i>, inkrementiert werden braucht. Allerdings muss
der Speicher aus diesem Grund auch in der umgekehrten Reihenfolge
freigegeben werden, wie er zugewiesen wurde. Weil dies nun gerade
der Verwaltung von lokalen Variablen beim Aufrufen und Verlassen von
Unterprogrammen entspricht, arbeiten die meisten Laufzeitsysteme
bevorzugt mit dem Stack.

<dt><b>2. Haldenspeicher, engl. <i>heap</i></b>
<dd>Bei diesem darf Speicher in beliebiger Reihenfolge zugewiesen
und freigegeben werden. Infolge ist der Heap vergleichsweise
kompliziert und langsam.
</dl>

<h2 id="Box">Zeiger vom Typ Box</h2>

<p>Die folgende Funktion <code>new_data</code> gibt ein Array
zurück, das bspw. Bilddaten eines Bildes mit Breite 480 Pixel
und Höhe 300 Pixel aufnehmen soll.

<pre class="rust ibox">
const DATA_LEN: usize = 480*300;

fn new_data() -&gt; [u32; DATA_LEN] {
    [0; DATA_LEN]
}
</pre>

<p>Nun ist der Stack in nativen Laufzeitsystemen begrenzt. Typische
Werte für die Begrenzung liegen bei 1 bis 10&nbsp;MB. Zwar lässt sich
dies ändern, bspw. indem das Hauptprogramm in einem neuen Thread
mit größerem Stack ausgeführt wird, nehmen wir aber zunächst an, dies
wäre uns nicht gegeben. Wollen wir nun ein größeres Array speichern,
oder ein Array von Arrays, ist der Stapel bald aufgebraucht.

<p>Für gewöhnlich wird für solche Datenmengen stattdessen
Haldenspeicher zugewiesen. Dafür zuständig ist die Funktion
<code>Box::new</code>, die einen Zeiger auf den zugewiesenen
Speicher zurückgibt. 

<pre class="rust ibox">
fn new_data() -&gt; Box&lt;[u32; DATA_LEN]&gt; {
    Box::new([0; DATA_LEN])
}
</pre>

<p>Bei einem Zeiger vom Typ <code>Box</code> handelt es sich um einen
sogenannten <i>Smart-Pointer</i>. Ein solcher zeichnet sich durch die
Eigenschaft aus, dass der Speicher automatisch wieder freigegeben wird,
sobald die Lebenszeit des Zeigerwertes endet.

<h2 id="Rc">Zeiger vom Typ Rc</h2>

<p>Stellt man sich Zeiger als Speicheradressen vor, liegt der Gedanke
nicht fern, mehrere Zeiger auf den gleichen Wert zeigen zu lassen.
Der Typ <code>Box</code> schließt dies jedoch aus, weil ein Zeiger
dieses Typs der Eigentümer des Wertes ist. Wir müssen uns hierzu
daran erinnern, dass die Unteilbarkeit von Eigentümerschaft eine
entscheidende Eigenschaft des Typsystems ist.

<p>Was man ohne Frage tun kann, ist die Erstellung beliebig
vieler Zeiger vom Typ <code>&amp;Box&lt;T&gt;</code>, da diese
nur Leihgaben darstellen. Dies bringt jedoch eine Reihe von
Problemen mit sich:

<ul>
<li>Sobald es zu einer Leihgabe kommt, ist die den Wert tragende
Datenstruktur als zugrundeliegender Eigentümer gefroren.
Andernfalls könnte man den Wert entfernen oder verschieben,
was zu Use after free führen würde.

<li>Denkbar sind Situationen, wo man Zeiger auf denselben Wert in zwei
oder mehreren Datenstrukturen speichern möchte, wo nicht bekannt ist,
welcher Zeiger von längerer Lebenszeit ist.
</ul>

<p>Eine Lösung für die Problematik bestünde in der Benutzung eines
sogenannten Arena-Allokators. Bei diesem dauert die Lebenszeit aller
erstellten Werte genau so lange an wie die des Allokators.
Das heißt, im Unterschied zu einem gewöhnlichen Allokator sind
Freigaben nicht zu beliebigen Zeitpunkten möglich. Eines Eigentümers
bedarf es nicht mehr, weil die Arena der eigentliche Eigentümer ist.
An dieser Stelle soll nicht näher auf dieses Konzept eingegangen werden.

<p>Eigentlich ist die Forderung nach Unteilbarkeit von Eigentum
zu streng. Solange einem Wert keine Veränderung widerfährt, dürfte
es mehrere Zeiger auf diesen geben. Nur dann muss der Wert solange
erhalten bleiben, bis der letzte Zeiger verschwunden ist. Allerdings
wissen wir nicht immer, in welcher Reihenfolge die Zeiger kommen
und gehen. Diesem Umstand trägt die Benutzung eines Referenzzählers
Rechnung, der dem Wert hinzugefügt wird. Der Referenzzähler zählt die
Anzahl vorhandener Zeiger. Bei der Erstellung eines neuen Zeigers wird
dieser um eins erhöht, beim Verschwinden eines Zeigers um eins
erniedrigt.

<p>Der Mechanismus der Referenzzählung ist durch den Typ
<code>Rc</code> implementiert, das steht für <i>reference counted</i>.
So wie bei <code>Box</code> ist der Speicherplatz, auf den der
Zeiger zeigt, auf der Halde alloziert. Erstellt wird eine neue
Allokation mit <code>Rc::new</code> oder <code>Rc::from</code>.
Die Methode <code>Rc::clone</code> bewirkt gerade nicht eine
Kopie der Daten, sondern nur eine Kopie des Zeigers und entsprechend
eine Inkrementation des Referenzzählers.

<p>Ein Beispiel zur Benutzung von <code>Rc</code> bieten
Ausschnitte mit Eigentümerschaft. Betrachten wir zunächst 
folgendes Programm.

<pre class="rust ibox">
fn main() {
    let slice: &amp;[u8] = &amp;[0, 0, 0, 0, 1, 1, 1, 1];
    let sub_slice = &amp;slice[4..8];
    println!("{:?}", sub_slice);
}
</pre>

<p>Die Ausschnitte bedingen hier Leihgaben der zugrunde liegenden
Bytesequenz. Stattdessen wollen wir nun Ausschnitte mit gemeinsamer
Eigentümerschaft an der Bytesequenz haben. Um dies zu erreichen,
konstruieren wir für diese Ausschnitte den neuen Typ <code>Slice</code>,
dessen Eintrag <code>data</code> eine gezählte Referenz auf die
Bytesequenz ist.

<pre class="rust ibox">
use std::{fmt, rc::Rc, ops::Range};

struct Slice {
    data: Rc&lt;[u8]&gt;,
    start: usize,
    len: usize
}
impl Slice {
    fn new(data: Rc&lt;[u8]&gt;) -&gt; Self {
        let len = data.len();
        Self{data, start: 0, len}
    }
    fn slice(&amp;self, r: Range&lt;usize&gt;) -&gt; Self {
        let start = self.start + r.start;
        let len = r.end - r.start;
        Self{data: self.data.clone(), start, len}    
    }
}

impl fmt::Debug for Slice {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let start = self.start;
        write!(f, "{:?}", &amp;self.data[start..start+self.len])
    }
}

fn main() {
    let data: Rc&lt;[u8]&gt; = Rc::from([0, 0, 0, 0, 1, 1, 1, 1]);
    let slice = Slice::new(data);
    let sub_slice = slice.slice(4..8);
    println!("{:?}", sub_slice);
}
</pre>

<p>Wir müssen näher darauf blicken, was hier gemacht wurde. Der Typ
<code>&amp;[u8]</code> ist eigentlich über Lebenszeiten
parametrisiert, die Notation unterdrückt dies bloß. Bei der Definition
eines Aliastypen tritt die Abhängigkeit von der Lebenszeit
explizit hervor:

<pre class="rust ibox">
type BorrowSlice&lt;'a&gt; = &amp;'a [u8];
</pre>

<p>Im Typ <code>Slice</code> ist diese Parametrisierung verloren
gegangen. Der Typ <code>Slice</code> ist demnach nicht mehr von
der Lebenszeit eines anderen Datums abhängig.

<h2 id="Cell">Zellen vom Typ Cell</h2>

<p>Der Typ <code>Rc</code> gewährt nur gemeinsame Referenzen, womit
die Daten darunter unveränderlich bleiben. Infolge liegt die gesamte
Datenstruktur immerwährend fest wie ein Kristall. Einem gleichartigen
Problem steht man auch in anderen Situationen gegenüber, &ndash;
überall dort, wo man nur gemeinsame Referenzen bekommt. Dem Ziel
der Programmierung von dynamischen Datenstrukturen läuft diese
Einschränkung offensichtlich zuwider. Zur Auflösung dieser
Einschränkung stehen daher ausgeklügelte Mechanismen zur Verfügung.

<p>Erinnern wir uns daran, dass bei gemeinsamen Referenzen
Veränderungen an den Daten verboten sind, weil es sonst zu Aliasing
und Use after free kommen kann. Einen Teil der Daten unter einer
gemeinsamen Referenz wollen wir nun dennoch verändern dürfen.
Angenommen, wir verbieten Zeiger auf diesen Teil, womit dieser Teil nur
als ganze gelesen und geschrieben werden darf,
dann dürfte es niemals zu den genannten Problemen kommen.

<p>Mit der technischen Ausgestaltung dieser Idee ist der Typ
<code>Cell</code> entstanden. Einen Zeiger auf das Innere eines
Wertes dieses Typs kann man nicht bekommen. Lediglich ist es gestattet,
die Zelle mit der Methode <code>Cell::get</code> gänzlich zu
lesen oder mit <code>Cell:set</code> gänzlich zu schreiben.
Außerdem gibt es noch ein paar Hilfsmethoden zum flexibleren
Ausreizen der zugrundeliegenden Idee.

<p>Eine Anwendung von <code>Cell</code> zeigt die folgende
Implementierung eines Zählers, der sich auch dann verändern
darf, wenn man nur »veränderungslosen« Zugriff auf ihn hat.

<pre class="rust ibox">
use std::{rc::Rc, cell::Cell};

struct Counter {
    value: Cell&lt;u32&gt;
}
impl Counter {
    fn new() -&gt; Self {
        Self{value: Cell::new(0)}
    }
    fn next(&amp;self) -&gt; u32 {
        let value = self.value.get();
        self.value.set(value + 1);
        value
    }
}

fn main() {
    // Scheinbar absurd: Veränderung hinter einer
    // gemeinsamen Referenz.
    let counter = &amp;Counter::new();
    println!("{}", counter.next());
    println!("{}", counter.next());

    // Entsprechend erlaubt.
    let counter = Rc::new(Counter::new());
    println!("{}", counter.next());
    println!("{}", counter.next());
}
</pre>

<h2 id="RefCell">Zellen vom Typ RefCell</h2>

</body>
</html>
