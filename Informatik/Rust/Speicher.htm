<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Speicherverwaltung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Zeiger">Zeiger</a>
<li><a href="#Allokation">Allokation</a>
<li><a href="#Box">Zeiger vom Typ Box</a>
<li><a href="#Rc">Zeiger vom Typ Rc</a>
<li><span class="modest">Zellen vom Typ Cell</span>
<li><span class="modest">Zellen vom Typ RefCell</span>
</ol>

<h2 id="Zeiger">Zeiger</h2>

<p>Ein Zeiger ist eine Variable, die die Speicheradresse einer
anderen Variable als Wert enthält.

<h3>Zeigerarithmetik</h3>

<p>Die in Hochsprache formulierte Funktion
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for x in a {
        println!("{}",x);
    }
}
</pre>

<p>nimmt nach Absenkung diese Gestalt an:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let p_end = unsafe{p.add(a.len())};
    while p != p_end {
        println!("{}",unsafe{*p});
        p = unsafe{p.add(1)};
    }
}
</pre>

<p>Oder alternativ:
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let mut p = a.as_ptr();
    let mut n = a.len();
    while n&gt;0 {
        println!("{}",unsafe{*p});
        p = unsafe{p.add(1)};
        n -= 1;
    }
}
</pre>

<p>Die Formulierung
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    for i in 0..a.len() {
        println!("{}",a[i]);
    }
}
</pre>

<p>entspricht
<pre class="rust ibox">
fn print_array(a: &amp;[char]) {
    let p = a.as_ptr();
    let n = a.len();
    let mut i = 0;
    while i&lt;n {
        println!("{}",unsafe{*p.add(i)});
        i += 1;
    }
}
</pre>

<h2 id="Allokation">Allokation</h2>

<p>Die Daten, die ein Programm verarbeitet, müssen notgedrungen auf
irgendeine Art im RAM-Speicher des Computers untergebracht werden.
Dafür gibt es zwei Verfahren:

<dl class="indent">
<dt><b>1. Stapelspeicher, engl. <i>stack</i></b>
<dd>Die Zuweisung von Speicher geschieht hier besonders
schnell, da dafür lediglich der Stapelzeiger, engl.
<i>stack pointer</i>, inkrementiert werden braucht. Allerdings muss
der Speicher aus diesem Grund auch in der umgekehrten Reihenfolge
freigegeben werden, wie er zugewiesen wurde. Weil dies nun gerade
der Verwaltung von lokalen Variablen beim Aufrufen und Verlassen von
Unterprogrammen entspricht, arbeiten die meisten Laufzeitsysteme
bevorzugt mit dem Stack.

<dt><b>2. Haldenspeicher, engl. <i>heap</i></b>
<dd>Bei diesem darf Speicher in beliebiger Reihenfolge zugewiesen
und freigegeben werden. Infolge ist der Heap vergleichsweise
kompliziert und langsam.
</dl>

<h2 id="Box">Zeiger vom Typ Box</h2>

<p>Die folgende Funktion <code>new_data</code> gibt ein Array
zurück, das bspw. Bilddaten eines Bildes mit Breite 480 Pixel
und Höhe 300 Pixel aufnehmen soll.

<pre class="rust ibox">
const DATA_LEN: usize = 480*300;

fn new_data() -&gt; [u32; DATA_LEN] {
    [0; DATA_LEN]
}
</pre>

<p>Nun ist der Stack in nativen Laufzeitsystemen begrenzt. Typische
Werte für die Begrenzung liegen bei 1 bis 10&nbsp;MB. Zwar lässt sich
dies ändern, bspw. indem das Hauptprogramm in einem neuen Thread
mit größerem Stack ausgeführt wird, nehmen wir aber zunächst an, dies
wäre uns nicht gegeben. Wollen wir nun ein größeres Array speichern,
oder ein Array von Arrays, ist der Stapel bald aufgebraucht.

<p>Für gewöhnlich wird für solche Datenmengen stattdessen
Haldenspeicher zugewiesen. Dafür zuständig ist die Funktion
<code>Box::new</code>, die einen Zeiger auf den zugewiesenen
Speicher zurückgibt. 

<pre class="rust ibox">
fn new_data() -&gt; Box&lt;[u32; DATA_LEN]&gt; {
    Box::new([0; DATA_LEN])
}
</pre>

<p>Bei einem Zeiger vom Typ <code>Box</code> handelt es sich um einen
sogenannten <i>Smart-Pointer</i>. Ein solcher zeichnet sich durch die
Eigenschaft aus, dass der Speicher automatisch wieder freigegeben wird,
sobald die Lebenszeit des Zeigerwertes endet.

<h2 id="Rc">Zeiger vom Typ Rc</h2>

<p>Stellt man sich Zeiger als Speicheradressen vor, liegt der Gedanke
nicht fern, mehrere Zeiger auf den gleichen Wert zeigen zu lassen.
Der Typ <code>Box</code> schließt dies jedoch aus, weil ein Zeiger
dieses Typs der Eigentümer des Wertes ist. Wir müssen uns hierzu
daran erinnern, dass die Unteilbarkeit von Eigentümerschaft eine
entscheidende Eigenschaft des Typsystems ist.

<p>Was man ohne Frage tun kann, ist die Erstellung beliebig
vieler Zeiger vom Typ <code>&amp;Box&lt;T&gt;</code>, da diese
nur Leihgaben darstellen. Dies bringt jedoch eine Reihe von
Problemen mit sich:

<ul>
<li>Sobald es zu einer Leihgabe kommt, ist die den Wert tragende
Datenstruktur als zugrundeliegender Eigentümer gefroren.
Andernfalls könnte man den Wert entfernen oder verschieben,
was zu Use after free führen würde.

<li>Denkbar sind Situationen, wo man Zeiger auf denselben Wert in zwei
oder mehreren Datenstrukturen speichern möchte, wo nicht bekannt ist,
welcher Zeiger von längerer Lebenszeit ist.
</ul>

<p>Eine Lösung für die Problematik bestünde in der Benutzung eines
sogenannten Arena-Allokators. Bei diesem dauert die Lebenszeit aller
erstellten Werte genau so lange an wie die des Allokators.
Das heißt, im Unterschied zu einem gewöhnlichen Allokator sind
Freigaben nicht zu beliebigen Zeitpunkten möglich. Eines Eigentümers
bedarf es nicht mehr, weil die Arena der eigentliche Eigentümer ist.
An dieser Stelle soll nicht näher auf dieses Konzept eingegangen werden.

<p>Eigentlich ist die Forderung nach Unteilbarkeit von Eigentum
zu streng. Solange einem Wert keine Veränderung widerfährt, dürfte
es mehrere Zeiger auf diesen geben. Nur dann muss der Wert solange
erhalten bleiben, bis der letzte Zeiger verschwunden ist. Allerdings
wissen wir nicht immer, in welcher Reihenfolge die Zeiger kommen
und gehen. Diesem Umstand trägt die Benutzung eines Referenzzählers
Rechnung, der dem Wert hinzugefügt wird. Der Referenzzähler zählt die
Anzahl vorhandener Zeiger. Bei der Erstellung eines neuen Zeigers wird
dieser um eins erhöht, beim Verschwinden eines Zeigers um eins
erniedrigt.

<p>Der Mechanismus der Referenzzählung ist durch den Typ
<code>Rc</code> implementiert, das steht für <i>reference counted</i>.


</body>
</html>
