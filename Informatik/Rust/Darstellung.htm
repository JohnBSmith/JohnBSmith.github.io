<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>

<h1>Darstellung im Speicher</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Ausrichtung">Ausrichtung</a>
<li><a href="#Padding">Padding</a>
<li><span class="modest">Größe von Typen</span>
<li><span class="modest">Layout</span>
<li><span class="modest">Das Attribut repr(C)</span>
<li><span class="modest">Nischen</span>
<li><span class="modest">Transmutation</span>
</ol>

<h2 id="Ausrichtung">Ausrichtung</h2>

<p>Dieses Kapitel beschäftigt sich mit der Darstellung von Werten im
Speicher. Der Wert eines Typs ist zunächst ein gedankliches Konzept,
so wie das bei einem mathematischen Objekt ist. Ein mathematisches
Objekt wie eine Zahl befindet sich in einem platonischen Universum, so
nennt man den Raum aller erdenklichen Objekte. Erst die Darstellung der
Zahl durch ein Zahlensystem ermöglicht ihre physische Erfassung. Wir
schreiben ja immer nur die Ziffern einer Zahl auf, die Zahl selbst
haben wir nie gesehen. Je nach Zahlensystem nimmt die Darstellung
der Zahl dabei eine andere Gestalt an.

<p>Auch zur physischen Speicherung eines Wertes bedarf es offensichtlich
einer Darstellung. Werte werden in Computern als Binärzahlen
abgelegt, soviel ist klar. Bei der Darstellung im Speicher
gibt es allerdings noch ein wenig mehr zu beachten. Das fängt schon
damit an, dass die Bits immer zu Gruppen aus acht, den Bytes
zusammengefasst sind. Die Kenntnis der Darstellung zerbricht im
Nebeneffekt die Abstraktion zum benutzten Computer.

<p>Jedes im Arbeitsspeicher abgelegte Datum besitzt eine Adresse.
Enthält ein Zeiger diese Adresse als Wert, bekommt das Programm
durch Dereferenzierung des Zeigers den Zugriff auf das Datum.
Eine Adresse ist die Anzahl an Bytes, um die der Zeiger vom Ursprung
des Speichers aus verschoben wurde.

<p>Es verhält sich nun für gewöhnlich aber so, dass ein Datum nicht
jede mögliche Adresse besitzen kann. Computer arbeiten intern
mit <i>Datenworten</i>, kurz <i>Worten</i>. Typische Wortgrößen
moderner Architekturen sind 32&nbsp;Bit und 64&nbsp;Bit. Für den
Computer sind die Elemente des Speichers nicht die Bytes, sondern die
Worte, der Computer kann sie effizient laden und speichern. Infolge
ist es günstig wenn ein Datum im Speicher so ausgerichtet ist dass
es möglichst wenige Worte überspannt, denn andernfalls würde das
Laden und Speichern eine erhöhte Anzahl an Operationen erfordern.

<p>Betrachten wir eine Architektur mit der Wortgröße 32.
Jede Zahl vom Typ <code>u32</code> ist in dieser Architektur gemäß des
Gesagten so im Speicher ausgerichtet, dass ihre Adresse ein
ganzzahliges Vielfaches von vier ist. Das heißt, die
Zusicherung in

<pre class="rust ibox">
let x: u32 = 0;
let address = &amp;x as *const u32 as usize;
assert!(address % 4 == 0);
</pre>

<p>ist immer erfüllt, und für

<pre class="rust ibox">
let a: [u32; 2] = [1, 2];
let address = &amp;a[0] as *const u32 as usize;
assert!(address % 4 == 0);
</pre>

<p>gilt dasselbe. Schärfer setzt uns die Standardbibliothek
unmissverständlich über

<pre class="rust ibox">
std::mem::align_of::&lt;u32&gt;() == 4
</pre>

<p>in Kenntnis.

<h2 id="Padding">Padding</h2>

<p>Die Ausrichtung betrifft im weiteren Fortgang gleichermaßen die
Einträge von Tupeln und Strukturen. Betrachten wir dazu:

<pre class="rust ibox">
struct S {i: u32, b: u8}

assert_eq!(4, std::mem::align_of::&lt;S&gt;());
assert_eq!(8, std::mem::size_of::&lt;S&gt;());
</pre>

<p>Die Ausrichtung der Struktur ist gleich der des Eintrags
<code>i</code>, das erscheint logisch, denn wäre dieser Betrag geringer,
wäre sie dergestalt im Speicher verschiebbar dass der Eintrag
<code>i</code> unausgerichtet sein würde.

<p>Aber weshalb beträgt die Größe der Struktur acht Bytes und
nicht fünf? Das liegt daran, dass zur Größe der Struktur Padding
hinzukommt, so dass jedes Element einer direkten Abfolge dieser
Strukturen im Speicher ausgerichtet ist.

<p>Unter Padding versteht man das Auffüllen einer Datenstruktur
mit ungenutztem Freiraum, so dass alle ihre Bestandteile im
Speicher ausgerichtet sind. Beispielsweise erzeugt

<pre class="rust ibox">
#[repr(C)]
struct S {b1: u8, i: u32, b2: u8}

println!("{}/{}", align_of::&lt;S&gt;(), size_of::&lt;S&gt;());
</pre>

<p>die Ausgabe <code>4/12</code>. Die Größe der Struktur bläht
sich von sechs auf zwölf auf, weil einmal für <code>b1</code>
drei Bytes und ebenso für <code>b2</code> drei Bytes an Padding
eingefügt werden.

<p>Entfernen wir das Attribut <code>repr(C)</code>, dann ist es
dem Compiler erlaubt, die Reihenfolge der Einträge umzuordnen,
so dass die Struktur die Gestalt

<pre class="rust ibox">
#[repr(C)]
struct S {b1: u8, b2: u8, i: u32}
</pre>

<p>oder

<pre class="rust ibox">
#[repr(C)]
struct S {i: u32, b1: u8, b2: u8}
</pre>

<p>erhält und damit die Größe acht bekommt. Weil <code>b1</code>
und <code>b2</code> nämlich keiner Ausrichtung bedürfen, dürfen
sie direkt hintereinander abgelegt werden, womit zwei Bytes
Padding genügen.

<p>Es ist auch machbar, das Padding und infolge die Ausrichtung
in Strukturen zu unterlassen. Man spricht dann von einer
<i>gepackten</i> Struktur. In der Konsequenz sind Lese- und
Schreibvorgänge allerdings, so wissen wir, ineffizient. Gepackte
Strukturen würden deshalb am ehesten bei Schnittstellen und
Dateiformaten zur Anwendung kommen. Solche Darstellungen werden vom
Compiler <code>rustc</code> mit dem Attribut <code>repr(packed)</code>
unterstützt, ihr Gebrauch ist allerdings nicht empfohlen.

</body>
</html>
