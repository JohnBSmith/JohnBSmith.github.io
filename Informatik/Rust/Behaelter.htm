<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>

<h1>Benutzung von Behältern</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Arten">Arten von Behältern</a>
<li><a href="#Hashtabellen">Hashtabellen</a>
</ol>

<h2>Arten von Behältern</h2>

<p>Behälter (engl. container, collections) sind spezielle generische
Datenstrukturen, die man als Hilfsmittel zur Konstruktion von
Algorithmen und neuen Datenstrukturen benutzen kann. Die
Standardbibliothek von Rust enthält eine Reihe solcher Behälter,
diese sind im Modul <code>std::collections</code> zu finden.

<p>Die wichtigsten Behälter lassen sich wie folgt in Arten einteilen:
<dl class="indent">
<dt><b>Sequenzen</b>
<dd>Es gibt hier <code>Vec</code> für dynamische Felder,
<code>VecDeque</code> für Warteschlangen und
<code>LinkedList</code> für doppelt verkettete Listen.

<dt><b>Abbildungen von Schlüsseln auf Werte</b>
<dd>Diese werden auch assoziative Felder oder Wörterbücher genannt.
Es gibt hier <code>HashMap</code> für assoziativen Felder und
<code>BTreeMap</code> für geordnete assoziative Felder.

<dt><b>Mengen</b>
<dd>Diese Behälter entsprechen den endlichen Mengen in
der Mathematik. Sie lassen sich als assoziative Felder mit fehlenden
Werten betrachten. Es gibt hier <code>HashSet</code> für Mengen
und <code>BTreeSet</code> für geordnete Mengen.
</dl>

<h2 id="Hashtabellen">Hashtabellen</h2>

<h3>Von Feldern zu assoziativen Feldern</h3>

<p>Ein Feld <code>a: [T;n]</code> lässt sich interpretieren als
eine Abbildung der Indexmenge auf die Wertemenge:

<p class="indent"><var>a</var>: {0, &hellip;, <var>n</var>&minus;1}
&rarr; <var>T</var>.

<p>Ein assoziatives Feld kann man als eine Verallgemeinerung eines
Feldes betrachten, die beliebige Indexmengen erlaubt. Die Indizes
werden hierbei als Schlüssel bezeichnet und können zunächst einen
beliebigen Datentyp haben, solange sie nur unterscheidbar sind.

<p>Für die Unterscheidbarkeit benötigen die Schlüssel eine
Äquivalenzrelation, welche über den Trait <code>Eq</code> zugänglich
gemacht wird. Für effiziente Umsetzungen sollten die Schlüssel
zudem entweder hashbar sein via Trait <code>Hash</code>, oder
eine Totalordnung haben via Trait <code>Ord</code>.

<p>Die Begriffe Äquivalenzrelation (equivalence relation),
Halbordnung (partial order) und Totalordnung (total order)
sind mathematisch streng definiert. Die Definition der jeweiligen
Relation enthält Axiome, die von einer Implementation für
einen Datentyp erfüllt werden müssen.

<h3>Hashtabellen definieren und anwenden</h3>

<p>Variadische Funktionen werden in Rust bisweilen nicht unterstützt.
Da das Literal für Hashtabellen variadisch ist und die Tupel-Syntax
für Schlüsselwert-Paare etwas umständlich ist, behilft man sich am
besten mit einem Makro:

<pre class="rust indent">
macro_rules! hashmap {
    ($( $key:tt: $value:expr ),*) =&gt; {{
        let mut map = HashMap::new();
        $(map.insert($key.into(),$value.into());)*
        map
    }}
}
</pre>

<p>Definition und Anwendung von Hashtabellen gestaltet sich nun
wie bei Feldern:
<pre class="rust indent">
use std::collections::HashMap;

fn main() {
    let m: HashMap&lt;String,i32&gt; = hashmap!{
        "x": 1, "y": 2
    };
    println!("{:?}",m);
    println!("{}",m["x"]);
}
</pre>
<p>So wie <code>a[k]</code> zum Programmabbruch via <code>panic</code>
führt, falls <code>k</code> außerhalb von <code>0..a.len()</code>
liegt, tut es auch <code>m[key]</code>, falls <code>key</code> nicht
in <code>m</code> enthalten ist.

<p>Zusätzlich gibt es auch die Methode <code>m.get(key)</code>, die
<code>Some(value)</code> bei Vorhandensein von <code>key</code> in
<code>m</code> zurückgibt, sonst <code>None</code>. Somit ist auch
gestattet:
<pre class="rust indent">
println!("{:?}",m.get("x"));
</pre>

<p>Man kann <code>m.get(key)</code> als Verallgemeinerung von
<code>m[key]</code> betrachten, da <code>m[key]</code> im
Wesentlichen das gleiche bedeutet wie <code>m.get(key).unwrap()</code>.

<h3>Äquivalenz per Zeigervergleich</h3>

<p>Manchmal soll die Äquivalenzrelation zwischen Objekten nicht
über ihren Inhalt definiert sein, sondern über ihre Identifizierung.
Ein erster Ansatz wäre die Speicherung der Identifizierung als
zusätzlicher Eintrag <code>id</code>. Das kann z.&nbsp;B. eine
Zahl vom Typ <code>u32</code> sein.

<p>Der Typ zur Identifizierung sei hier <code>Id</code> genannt.
Man kann einen solchen Typ auch nachträglich als Wrapper-Typ über
jeden beliebigen Objekt-Typ bilden.

<p>Entsprechend ergibt sich nun:

<pre class="rust indent">
use std::collections::HashMap;
use std::hash::{Hash,Hasher};
use std::rc::Rc;

#[derive(Debug)]
struct Id {
    id: u32, name: Rc&lt;str&gt;
}
impl Id {
    fn new(id: u32, name: &amp;str) -&gt; Self {
        Self{id, name: Rc::from(name)}
    }
}
impl Hash for Id {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.id.hash(state);
    }
}
impl PartialEq for Id {
    fn eq(&amp;self, y: &amp;Self) -&gt; bool {
        self.id == y.id
    }
}
impl Eq for Id {}

fn main() {
    let mut m: HashMap&lt;Id,()&gt; = HashMap::new();
    m.insert(Id::new(0,"A"),());
    m.insert(Id::new(1,"A"),());
    println!("{:?}",m);
}
</pre>

<p>Ein wenig problematisch hierbei ist allerdings, dass die
Identifizierung manuell festgelegt werden muss. Man bräuchte zusätzlich
einen Zähler zur Gewährleistung, dass für jedes Objekt eine einmalige
Identifikation erzeugt wird.

<p>Wenn das Objekt aber ohnehin alloziert wird, kann man auch gleich
den Zeiger als Speicheradresse betrachten und diese zur Identifizierung
heranziehen. Dafür sind lediglich ein paar kleine Modifikationen
vorzunehmen:

<pre class="rust indent">
use std::collections::HashMap;
use std::hash::{Hash,Hasher};
use std::rc::Rc;

#[derive(Debug,Clone)]
struct Id {
    id: Rc&lt;str&gt;
}
impl Id {
    fn new(text: &amp;str) -&gt; Self {
        Self{id: Rc::from(text)}
    }
}
impl Hash for Id {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        (&amp;*self.id as *const str as *const () as usize).hash(state);
    }
}
impl PartialEq for Id {
    fn eq(&amp;self, y: &amp;Self) -&gt; bool {
        Rc::ptr_eq(&amp;self.id,&amp;y.id)
    }
}
impl Eq for Id {}

fn main() {
    let mut m: HashMap&lt;Id,()&gt; = HashMap::new();
    m.insert(Id::new("A"),());
    m.insert(Id::new("A"),());
    println!("{:?}",m);
}
</pre>
<p>Bei der Berechnung des Hashwertes muss man hier aufpassen,
dass man
<pre class="rust indent">
(&amp;*self.id as *const str as *const () as usize).hash(state);
</pre>
anstelle von
<pre class="rust indent">
(&amp;self.id as *const _ as usize).hash(state);
</pre>
schreibt. Es soll ja nicht die Speicheradresse der Referenz des Zeigers
gehasht werden, sondern die Speicheradresse, welche der Zeiger enthält.
Dies wird durch das folgende Programm verdeutlicht:
<pre class="rust indent">
use std::rc::Rc;

#[derive(Clone)]
struct Id {id: Rc&lt;str&gt;}

fn main() {
    let a = Id{id: Rc::from("A")};
    let b = a.clone();
    println!("Diese Adressen stimmen nicht überein:");
    println!("0x{:x}",&amp;a.id as *const _ as usize);
    println!("0x{:x}",&amp;b.id as *const _ as usize);
    println!();
    println!("Diese Adressen stimmen überein:");
    println!("0x{:x}",&amp;*a.id as *const str as *const () as usize);
    println!("0x{:x}",&amp;*b.id as *const str as *const () as usize);
}
</pre>

<p>Der Typcast <code>as *const ()</code> ist übrigens vonnöten, weil
<code>&amp;str</code> bzw. <code>*const str</code> ein dicker Zeiger
bestehend aus Datenzeiger und Länge ist. Durch den Typcast wird
die Länge entfernt, es verbleibt ein einfacher Zeiger der sich
in eine Speicheradresse vom Typ <code>usize</code> umwandeln lässt.

<p>Nun sind Leute beim Programmieren auch noch mit anderen Dingen
beschäftigt und würden es dabei gerne vermeiden, ihren mentalen Fokus
auf diese Feinheiten zu lenken. Glücklicherweise ist eine Abstraktion
dieser Konvertierung erreichbar:

<pre class="rust indent">
fn rc_as_usize&lt;T: ?Sized&gt;(p: &amp;Rc&lt;T&gt;) -&gt; usize {
    &amp;**p as *const T as *const () as usize
}
</pre>

<p>Der Trait-Bound <code>?Sized</code> drückt hierbei aus, dass
<code>Rc&lt;T&gt;</code> bzw. <code>&amp;T</code> auch ein
dicker Zeiger sein kann. Die Variante ohne Unterstützung von
dicken Zeigern ist ein wenig kürzer:

<pre class="rust indent">
fn rc_as_usize&lt;T&gt;(p: &amp;Rc&lt;T&gt;) -&gt; usize {
    &amp;**p as *const T as usize
}
</pre>

<p>Eine Warnung noch: Man könnte auf die Idee kommen,
<code>rc_as_usize</code> zu
<pre class="rust indent">
fn ptr_as_usize&lt;T: ?Sized&gt;(p: &amp;T) -&gt; usize {
    p as *const T as *const () as usize
}
</pre>

<p>zu verallgemeinern. Dann ist aber folgendes Programm möglich:
<pre class="rust indent">
fn main() {
    let id: Rc&lt;str&gt; = Rc::from("A");
    println!("0x{:x}",rc_as_usize(&amp;id));
    println!("0x{:x}",ptr_as_usize(&amp;*id));
    println!("0x{:x}",ptr_as_usize(&amp;id));
}
</pre>
<p>Die Ausgabe jagt mir einen Schauer über den Rücken:
<pre class="indent">
0xf3a408
0xf3a408
0xbffe09a8
</pre>

<p>Ein genauer Blick auf die Typsignatur von <code>ptr_as_usize</code>
bringt die Erklärung. Nämlich bekommt die Funktion beim ersten
Aufruf <code>&amp;T&nbsp;=&nbsp;&amp;str</code>, beim zweiten jedoch
<code>&amp;T&nbsp;=&nbsp;&amp;Rc&lt;str&gt;</code>. Diese
gefährliche Subtilität will man eigentlich mittels der
Abstraktion verhindern. Die starke Verallgemeinerung konterkariert
dieses Unterfangen jedoch.

</body>
</html>

