<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>

<h1>Memoisierung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#fix">Der Fixpunkt-Kombinator</a>
<li><span class="modest">Memoisierender Fixpunkt-Kombiantor</span>
</ol>

<h2 id="fix">Der Fixpunkt-Kombinator</h2>

<p>Worauf ich abziele, will ich zur Vereinfachung zunächst in Python
darstellen. Ziel ist die Implementierung eines rekursiven
Algorithmus. Beispielsweise berechnet die Funktion

<pre class="ibox">
<b>def</b> fac(n):
    <b>return</b> 1 <b>if</b> n == 0 <b>else</b> n*fac(n - 1)
</pre>

<p>bekanntlich die Fakultät einer Zahl. Nun kann man Rekursion
alternativ mit einem Hilfsmittel herstellen, dem sogenannten
Fixpunkt-Kombinator. Das geht so:

<pre class="ibox">
<b>def</b> fix(cb):
    <b>def</b> f(x): <b>return</b> cb(f, x)
    <b>return</b> f

fac = fix(<b>lambda</b> f, n: 1 <b>if</b> n == 0 <b>else</b> n*f(n - 1))
</pre>

<p>Wir machen es uns nun zur Aufgabe, <code>fix</code> in Rust
zu formulieren. Dabei stellt sich das Problem in den Weg,
dass man aufgrund der eingefangenen Variable <code>cb</code>
(callback) ein Closure benötigt, Rust jedoch keine benannten Closures
kennt. Benannte Closures sind allerdings entbehrlich. Mit der folgenden
Trickserei kommen wir da raus:

<pre class="ibox">
<b>def</b> fix(cb):
    <b>return</b> <b>lambda</b> x: cb(cb, x)

fac = fix(<b>lambda</b> f, n: 1 <b>if</b> n == 0 <b>else</b> n*f(f, n - 1))
</pre>

<p>Schließlich müssen wir noch das Typsystem befriedigen.
Bei der näheren Betrachtung stellt sich heraus, dass
<code>f</code> ein rekursiver Typ sein muss, denn <code>f</code>
bekommt sich selbst als Argument zugeführt. Das stellt aber kein
wesentliches Problem dar, denn rekursive Typen sind mittels
<code>struct</code> konstruierbar. Insgesamt findet man die
folgende Konstruktion.

<pre class="rust ibox">
struct Rec&lt;'a&gt;(&amp;'a dyn Fn(&amp;Rec, u32) -&gt; u32);

impl Rec&lt;'_&gt; {
    fn call(&amp;self, x: u32) -&gt; u32 {(self.0)(&amp;self, x)}
}

fn fix(cb: impl Fn(&amp;Rec, u32) -&gt; u32) -&gt; impl Fn(u32) -&gt; u32 {
    move |x| cb(&amp;Rec(&amp;cb), x)
}

fn main() {
    let fac = fix(|f, n| if n == 0 {1} else {n*f.call(n - 1)});
    println!("{}", fac(4));
}
</pre>

<p>Einer generischen Formulierung steht keine Beschwerlichkeit
im Wege. Wir gelangen zu:

<pre class="rust ibox">
struct Rec&lt;'a, X, Y&gt;(&amp;'a dyn Fn(&amp;Rec&lt;X, Y&gt;, X) -&gt; Y);

impl&lt;X, Y&gt; Rec&lt;'_, X, Y&gt; {
    fn call(&amp;self, x: X) -&gt; Y {(self.0)(&amp;self, x)}
}

fn fix&lt;X, Y&gt;(cb: impl Fn(&amp;Rec&lt;X, Y&gt;, X) -&gt; Y) -&gt; impl Fn(X) -&gt; Y {
    move |x| cb(&amp;Rec(&amp;cb), x)
}
</pre>

<p>Damit haben wir nun einen allgemeinen Fixpunkt-Kombinator.
Mehr noch, es sind sogar mehrstellige Funktionen realisierbar.
Darf man nämlich für <code>X</code> alle möglichen Typen einsetzen,
dann darf es auch ein Tupeltyp sein. Beispielsweise kann man die
Potenzfunktion folgendermaßen schreiben:

<pre class="rust ibox">
fn main() {
    let pow = fix(|f, (x, n)|
        if n == 0 {1} else {x*f.call((x, n - 1))});
    println!("{}", pow((2, 10)));
}
</pre>

</body>
</html>

