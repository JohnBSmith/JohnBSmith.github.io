<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Sichere Programmierung</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Typsicherheit">Typsicherheit ausnutzen</a>
  <ol>
  <li><a href="#Validierung">Validierung</a>
  <li><a href="#ADT">Abstrakte Datentypen</a>
  <li><a href="#Schreibschutz">Schreibgeschützte Komponenten</a>
  <li><a href="#Typzustaende">Typzustände</a>
  <li><a href="#Einheiten">Einheiten</a>
  <li><a href="#Strikte-Einheiten">Strikte Einheiten</a>
  <li><a href="#Terminierung">Terminierung erzwingen</a>
  </ol>
<li><a href="#Laufzeit">Prüfungen zur Laufzeit</a>
  <ol>
  <li><a href="#Monaden">Monaden</a>
  <li><a href="#Contracts">Vertragsbasierte Programmierung</a>
  <li><a href="#Rekursionstiefe">Beschränkung der Rekursionstiefe</a>
  <li><a href="#Tests">Automatische Tests</a>
  </ol>
<li><a href="#Lints">Lints ausnutzen</a>
  <ol>
  <li><a href="#must-use">Implizites Verwerfen verhindern</a>
  </ol>
<li><a href="#Literatur">Literatur</a>
</ol>

<h2 id="Typsicherheit">Typsicherheit ausnutzen</h2>

<h3 id="Validierung">Validierung</h3>

<p>Angenommen, wir erhalten über eine Schnittstelle eine
Zeichenkette die aus genau vier dezimalen Ziffern bestehen soll.
Diese Zeichenkette wird später in eine Zahl umgewandelt und für
einen Datenbankindex verwendet. Nun ist es aber so, dass diese
Zeichenkette von einem Client zu einem Server kommt. Das Client-Programm
übergibt jedoch eine Zeichenkette die eine falsche Zahl von Ziffern
besitzt oder Buchstaben enthält. Dies führt dazu dass das Datenbanksystem
in einen invaliden Zustand gerät und ein über Monate lang unbemerktes
Datenleck entsteht.

<p>Das Problem hier ist, dass einer der Programmierer
vielleicht nicht gewusst hat, dass die Daten vor der Benutzung hätten
validiert werden müssen.

<p>In Rust kann eine solche Validierung vom Typsystem erzwungen
werden, indem für die validierten Daten ein eigener Datentyp definiert
wird, nennen wir ihn <code>DatabaseIndex</code>. Die Idee dabei ist,
dass erstens die betroffenen Unterprogramme nur Werte vom Typ
<code>DatabaseIndex</code> entgegennehmen und zweitens
ein solcher Wert nur über eine Validierung erzeugt werden kann.

<pre class="rust ibox">
mod db {
    #[derive(Clone, Copy)]
    pub struct DatabaseIndex {
        index: u16
    }
    impl DatabaseIndex {
        pub fn new(s: &amp;str) -&gt; Option&lt;Self&gt; {
            let a: Vec&lt;char&gt; = s.chars().collect();
            return if a.len() == 4 &amp;&amp;
                a[0].is_digit(10) &amp;&amp; a[1].is_digit(10) &amp;&amp;
                a[2].is_digit(10) &amp;&amp; a[3].is_digit(10)
            {
                Some(DatabaseIndex {
                    index: s.parse::&lt;u16&gt;().unwrap()
                })
            } else {
                None
            };
        }
        pub fn get(&amp;self) -&gt; u16 {
            self.index
        }
    }
}

use std::{io, io::Write};

fn main() {
    loop {
        print!("Index: ");
        if io::stdout().flush().is_err() {println!();}
        let mut s = String::new();
        io::stdin().read_line(&amp;mut s).unwrap();
        s.pop();
        match db::DatabaseIndex::new(&amp;s) {
            Some(index) =&gt; {
                database_access(index)
            },
            None =&gt; {
                println!("Fehler: ungültiger Datenbankindex.");
                continue;
            }
        };
    }
}

fn database_access(index: db::DatabaseIndex) {
    println!("Validierter Index: {}", index.get());
}
</pre>

<p>Hierzu ist zu bemerken, dass das Feld <code>index</code>
von <code>Datenbankindex</code> privat ist. Daher besteht der Zugang
zu Werten vom Typ <code>Datenbankindex</code> nur über die öffentlichen
Funktionen <code>new</code> und <code>get</code>.

<p>Die Idee ist nun, die Steuerung der Datenbank von ihrem Kernel zu
abstrahieren. Bei der Ansteuerung der Datenbank sollte es nie
zu einem invaliden Zustand kommen. Lediglich im Kernel besteht Zugriff
auf die private Funktionalität, bei der das System auch zerstört
werden kann, wenn man nicht vorsichtig ist.

<p>In Verbindung hiermit kann gesagt werden, dass die Maxime eine
möglichst strenge Typisierung der gesamten Datenverarbeitung sein
sollte.

<h3 id="ADT">Abstrakte Datentypen</h3>
<p>Ein abstrakter Datentyp, kurz ADT, ist ein Datentyp mit Operationen,
bei dem die interne Struktur und die interne Implementation der
Operationen vor der Öffentlichkeit verschwiegen wird. Bei einem
abstrakten Datentyp kann es sich um einen einfachen Datentyp oder
auch um eine komplizierte Datenstruktur handeln. Wichtig ist nur,
dass nur solche Operationen öffentlich sind, die eine Schnittstelle
zur Außenwelt repräsentieren.

<p>Es ist möglich dass ein abstrakter Datentyp eine vollkommen
typsichere Schnittstelle besitzt, obwohl dem bei der internen
Implementation nicht so ist. Man spricht von einer
<i>sicheren Kapselung</i> oder <i>sicheren Abstraktion</i>.

<p>Rust bietet die Mittel zur Darstellung von abstrakten Datentypen,
indem Variablen und Funktionen per Vorgabe zunächst privat sind.
Möchte man etwas zur öffentlichen Schnittstelle hinzufügen, so muss es
mit dem Schlüsselwort <code>pub</code> als <i>public</i> deklariert werden.

<p>Rust bietet außerdem Zero-Cost-Abstractions, die eine
Spezialisierung von allgemeinen abstrakten Datentypen zu spezielleren
ermöglichen, ohne dass es dabei zu Laufzeiteinbußen kommt.
Zur Umsetzung wird die Inline-Ersetzung von Funktionsaufrufen genutzt.

<p>Als einfachstes Beispiel soll ein Stapelspeicher formuliert
werden, der nur die Operationen <code>push</code> und <code>pop</code>
unterstützt.

<pre class="rust ibox">
mod stack {
    pub struct Stack&lt;T&gt; {
        v: Vec&lt;T&gt;
    }
    impl&lt;T&gt; Stack&lt;T&gt; {
        pub fn new() -&gt; Self {
            Stack {v: Vec::new()}
        }
        pub fn push(&amp;mut self, x: T) {
            self.v.push(x);
        }
        pub fn pop(&amp;mut self) -&gt; T {
            match self.v.pop() {Some(x) =&gt; x, None =&gt; panic!()}
        }
    }
}

use stack::Stack;

fn main() {
    let mut a: Stack&lt;i32&gt; = Stack::new();
    a.push(1);
    a.push(2);
    println!("{}", a.pop());
    println!("{}", a.pop());
}
</pre>

<p>Der Konstruktor <code>new</code> und die Methoden
<code>push</code> und <code>pop</code> können mit
<code>#[inline(always)]</code> annotiert werden, um Inline-Ersetzung
zu erzwingen. Die Funktionen sind aber so kurz, dass der Compiler
das in aller Wahrscheinlichkeit automatisch macht, sofern die
Optimierungen eingeschaltet werden.

<p>Das Konzept der Schnittstelle lässt sich aber auch noch
schärfer umsetzen. Spezifiziert man die Schnittstelle durch einen
Trait, dann lassen sich abstrakte Programme schreiben,
welche nur noch auf die Schnittstelle zugreifen, aber nicht
mehr auf konkrete Datentypen.

<pre class="rust ibox">
mod stack {
    pub trait Stack&lt;T&gt; {
        fn new() -&gt; Self;
        fn push(&amp;mut self, x: T);
        fn pop(&amp;mut self) -&gt; T;
    }

    pub struct VecStack&lt;T&gt; {
        v: Vec&lt;T&gt;
    }
    impl&lt;T&gt; Stack&lt;T&gt; for VecStack&lt;T&gt; {
        fn new() -&gt; Self {
            VecStack {v: Vec::new()}
        }
        fn push(&amp;mut self, x: T) {
            self.v.push(x);
        }
        fn pop(&amp;mut self) -&gt; T {
            match self.v.pop() {Some(x) =&gt; x, None =&gt; panic!()}
        }
    }
}

use stack::{Stack,VecStack};

fn routine&lt;S: Stack&lt;i32&gt;&gt;() {
    let mut a: S = S::new();
    a.push(1);
    a.push(2);
    println!("{}", a.pop());
    println!("{}", a.pop());
}

fn main() {
    routine::&lt;VecStack&lt;i32&gt;&gt;();
}
</pre>

<h3 id="Schreibschutz">Schreibgeschützte Komponenten</h3>

<p>Oft möchte man bei Datenstrukturen von außen nur Lesezugriff
auf Komponenten zulassen. Ein solcher Schreibschutz gehört neben
Privatheit zum Konzept der Kapselung. Würde man eine Schnittstelle
zulassen, die Manipulation interner Variablen erlaubt, ließe sich damit
die Integrität der Datenstruktur zerstören. Mit dem Schreibschutz
können wir eine konforme Benutzung der Datenstruktur erzwingen.

<p>Als Beispiel wählen wir eine Datenstruktur, welche eine Liste von
Obst in verschiedenen Sorten und ihr Gesamtgewicht speichert. Sowohl
die Liste als auch das Gesamtgewicht müssen von außen schreibgeschützt
sein.

<p>Der Grundaufbau der Obstkiste sieht so aus:

<pre class="rust ibox">
struct Fruit {kind: String, weight: u32}
struct FruitCrate {list: Vec&lt;Fruit&gt;, total_weight: u32}
</pre>

<p>Die Zahlen speichern sinnvollerweise die Masse in Gramm.
Die Datenstruktur wird nun eingekapselt. Die problematischen
Komponenten &ndash; das sind hier sämtliche &ndash; lassen wir
privat. Ausgelesen werden die Komponenten stattdessen mit Methoden,
wobei man der Methode auch den gleichen Bezeichner wie der
Komponente geben kann.

<pre class="rust ibox">
pub mod fruit_crate {
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        list: Vec&lt;Fruit&gt;,
        total_mass: u32
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self {list: Vec::new(), total_mass: 0}
        }
        pub fn push(&amp;mut self, kind: &amp;str, mass: u32) {
            self.list.push(Fruit {kind: kind.to_string(), mass});
            self.total_mass += mass;
        }
        pub fn total_mass(&amp;self) -&gt; u32 {self.total_mass}
        pub fn list(&amp;self) -> &amp;Vec&lt;Fruit&gt; {&amp;self.list}
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel", 1000);
    fc.push("Birnen", 1000);
    println!("Die Obstkiste wiegt {}g.", fc.total_mass());
}
</pre>

<p>In Rust gestaltet sich dazu nun noch eine kleine technische
Schwierigkeit. Nämlich wird mit dem Methodenaufruf <code>list</code>
die gesamte Datenstruktur ausgeborgt. Gäbe es noch eine frei
beschreibbare Komponente, könnte man auf diese während des Ausborgens
nicht mehr zugreifen. Als Beispiel sei der Obstkiste eine boolesche
Variable hinzugefügt, die angibt ob die Kiste geöffnet ist.

<pre class="rust ibox">
pub mod fruit_crate {
    #[derive(Debug)]
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        list: Vec&lt;Fruit&gt;,
        total_mass: u32,
        pub open: bool
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self {list: Vec::new(), total_mass: 0, open: true}
        }
        /* Der Rest wie zuvor */
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel", 1000);
    fc.push("Birnen", 1000);
    let a = fc.list();
    fc.open = false;
    println!("{:?}", a);
}
</pre>

<p>Der Compiler würgt das ab, da <code>open</code> nicht überschrieben
werden kann während <code>fc</code> ausgeborgt ist. Es gibt nun
zwei Ansätze, wie sich dieses Problem lösen ließe.

<p>Natürlich ließe sich hier auch <code>Cell&lt;bool&gt;</code> benutzen.
Für allgemeineres müsste man dann aber <code>RefCell</code> heranziehen,
was weniger effizient ist.

<p>Der erste Ansatz besteht darin, das Ausborgen mit einer Methode
aufzuteilen. Hierbei werden Teil-borrows als Tupel oder Struktur
zurückgeben. Zu <code>FruitCrate</code> müssen wir lediglich die
folgende Methode hinzufügen:

<pre class="rust ibox">
pub fn borrow_parts(&amp;mut self) -&gt; (&amp;mut bool, &amp;Vec&lt;Fruit&gt;) {
    (&amp;mut self.open, &amp;self.list)
}
</pre>

<p>So wird es vom Compiler akzeptiert:
<pre class="rust ibox">
fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel", 1000);
    fc.push("Birnen", 1000);
    let (open, list) = fc.borrow_parts();
    *open = false;
    println!("{:?}", list);
}
</pre>

<p>Beim zweiten Ansatz hüllt man die schreibgeschützten
Komponenten in eine Struktur <code>ReadOnly</code> ein.

<pre class="rust ibox">
pub mod fruit_crate {
    pub struct ReadOnly&lt;T&gt;(T);

    impl&lt;T&gt; std::ops::Deref for ReadOnly&lt;T&gt; {
        type Target = T;
        fn deref(&amp;self) -&gt; &amp;T {&amp;self.0}
    }

    #[derive(Debug)]
    pub struct Fruit {
        pub kind: String,
        pub mass: u32
    }    
    pub struct FruitCrate {
        pub list: ReadOnly&lt;Vec&lt;Fruit&gt;&gt;,
        pub total_mass: ReadOnly&lt;u32&gt;,
        pub open: bool
    }
    impl FruitCrate {
        pub fn new() -&gt; Self {
            Self{
                list: ReadOnly(Vec::new()),
                total_mass: ReadOnly(0),
                open: true
            }
        }
        pub fn push(&amp;mut self, kind: &amp;str, mass: u32) {
            self.list.0.push(Fruit {kind: kind.to_string(), mass});
            self.total_mass.0 += mass;
        }
    }
}

use fruit_crate::FruitCrate;

fn main() {
    let mut fc = FruitCrate::new();
    fc.push("Äpfel", 1000);
    fc.push("Birnen", 1000);
    let list = &amp;*fc.list;
    fc.open = false;
    println!("{:?}", list);
}
</pre>

<p>Da <code>ReadOnly</code> nicht aus dem Modul heraus genommen
werden kann, definiert man dafür am besten ein Makro:
<pre class="rust ibox">
macro_rules! define_read_only {
    () =&gt; {
        pub struct ReadOnly&lt;T&gt;(T);
        
        impl&lt;T&gt; std::ops::Deref for ReadOnly&lt;T&gt; {
            type Target = T;
            fn deref(&amp;self) -&gt; &amp;T {&amp;self.0}
        }
    }
}
</pre>

<h3 id="Typzustaende">Typzustände</h3>

<p>Manchmal müssen Methoden in einer bestimmten Reihenfolge aufgerufen
werden. Dass die Reihenfolge schon zur Kompilierzeit bekannt ist,
weist darauf hin, dass sich ein entsprechender Formalismus mittels
des Typsystems formulieren lassen müsste. Man spricht von
<i>Typzuständen</i>, engl. <i>typestates</i>. Rust bietet mit seinem
affinen Typsystem (Move-Semantik) die Möglichkeit, Typzustände bis
zu einem gewissen Ausmaß zu modellieren.

<p>Ohne affines Typsystem sind Typzustände nicht möglich, da die
fehlende Move-Semantik dazu führt, dass sich Variablen noch nach dem
Methodenaufruf benutzen lassen bis sie out of scope sind. Der
springende Punkt ist aber, dass die Methode die Variable »aufessen«
soll.

<p>Ein einfaches Beispiel. Angenommen, es gibt einen Typ <code>A</code>
mit den Methoden <code>f1</code>, <code>f2a</code>, <code>f2b</code>
und <code>f3</code>. Wir würden nun gern haben, dass <code>f2x</code>
nur nach <code>f1</code> aufgerufen werden kann und <code>f3</code>
nur nach <code>f2x</code>.

<p>Zur Umsetzung werden drei Typzustände <code>A</code>, <code>A2</code>
und <code>A3</code> definiert. Die Daten der Typzustände bleiben
privat, damit sich die Objekte ausschließlich über Methoden konstruieren
lassen. Jeder Typzustand bekommt jeweils seine erlaubten Methoden.

<pre class="rust ibox">
pub mod a_state {
    pub struct A {data: ()}
    impl A {
        pub fn new() -&gt; A {A {data: ()}}
        pub fn f1(self) -&gt; A2 {A2 {data: self.data}}
    }
    
    pub struct A2 {data: ()}
    impl A2 {
        pub fn f2a(self) -&gt; A3 {A3 {data: self.data}}
        pub fn f2b(self) -&gt; A3 {A3 {data: self.data}}
    }
    
    pub struct A3 {data: ()}
    impl A3 {
        pub fn f3(self) {let _ = self.data;}
    }
}

use crate::a_state::A;

fn main() {
    let a = A::new();
    let a = a.f1();
    let a = a.f2a();
    a.f3();
}
</pre>

<p>Als Nebeneffekt sind hier syntaktisch angenehme Methodenketten
erlaubt:

<pre class="rust ibox">
A::new().f1().f2a().f3();
</pre>

<p>Dass jeder Typzustand ein eigenständiger Datentyp ist, kann
unpraktisch sein, etwa wenn Methoden für einige oder alle Typzustände
gültig sein sollen. Tatsächlich können wir die Typzustände
zusammenfassen, indem der Zustand als Typparameter kodiert wird.
Die Zustände sollen hierbei keinerlei Daten tragen, weswegen wir
<code>PhantomData</code> heranziehen.

<pre class="rust ibox">
pub mod a_state {
    use std::marker::PhantomData as Ph;

    pub trait State {}
    pub struct A1; impl State for A1 {}
    pub struct A2; impl State for A2 {}
    pub struct A3; impl State for A3 {}

    pub struct A&lt;S: State&gt; {
        data: (), marker: Ph&lt;S&gt;
    }
    pub fn new_a() -&gt; A&lt;A1&gt; {A {data: (), marker: Ph}}
    impl A&lt;A1&gt; {
        pub fn f1(self) -&gt; A&lt;A2&gt; {A {data: self.data, marker: Ph}}
    }
    impl A&lt;A2&gt; {
        pub fn f2a(self) -&gt; A&lt;A3&gt; {A {data: self.data, marker: Ph}}
        pub fn f2b(self) -&gt; A&lt;A3&gt; {A {data: self.data, marker: Ph}}
    }
    impl A&lt;A3&gt; {
        pub fn f3(self) {}
    }
}

use a_state::new_a;

fn main() {
    new_a().f1().f2a().f3();
}
</pre>

<h3 id="Einheiten">Einheiten</h3>

<p>Einheiten beugen bei technischen oder physikalischen Rechnungen
gegen Missverständnisse vor. Zur Schaffung einer erhöhten Sicherheit
würden wir dieses Konzept nun auch gerne in die Programmierung
einbringen.

<p>Zunächst ließe sich mehr Klarheit schaffen durch Definition der
Einheiten als Konstanten:

<pre class="rust ibox">
pub mod unit {
    #![allow(non_upper_case_globals)]
    pub const km: f64 = 1000.0;
    pub const  m: f64 = 1.0;
    pub const cm: f64 = 0.01;
    pub const mm: f64 = 0.001;
}

use unit::{cm, mm};
use std::f64::consts::PI;

fn circumference(radius: f64) -&gt; f64 {
    2.0*PI*radius
}

fn main() {
    let r = 4.0*cm + 2.0*mm;
    println!("{} m", circumference(r));
}
</pre>

<p>Hierbei verbleibt aber das Problem, dass sich Größen
verschiedener Einheit beliebig addieren und multiplizieren lassen.
Das würde man jedoch gerne auf erlaubte Operationen beschränken.
Hierzu muss für Größen offenbar ein Datentyp definiert werden.

<p>Man könnte nun für alle möglichen Einheiten einen separaten
Datentyp definieren. Wesentlich günstiger ist aber die Definition
der Dimension als Datentyp. Die Einheiten normalisieren den Zahlenwert
dann bloß, dergestalt dass dieser nur in kohärenter Einheit
gespeichert wird.

<p>Weiterhin könnte man nun für alle möglichen Größenarten einen
separaten Datentyp definieren bzw. diese mit ihrer Dimension
zusammenfallen lassen. Jedoch ließen sich die Implementationen
wiederkehrender Operationen dann nicht faktorisieren. Daher macht
man die Dimension am besten zu einem Typargument der Größe. Da die
Dimension lediglich zur Kompilierzeit existieren soll, nutzt man
<code>PhantomData</code>. Eine Größe besteht nun aus einem Zahlenwert
<code>value</code> (in kohärenter Einheit) und einer dazugehörigen
Dimension <code>dim</code>.

<p>Wir gehen wie erläutert vor und definieren regelkonform die
Multiplikation einer Zahl mit einer Größe und die Addition von zwei
Größen gleicher Dimension. Die Einheiten modellieren wir einfach
als konstante Größen:

<pre class="rust ibox">
pub mod quantities {
    use std::marker::PhantomData as Ph;
    use std::ops::{Mul, Add};
    use std::fmt;

    pub trait Dimension {}

    #[derive(Clone,Copy)]
    pub struct Quantity&lt;D: Dimension&gt; {
        value: f64, dim: Ph&lt;D&gt;
    }
    impl&lt;D: Dimension&gt; Mul&lt;Quantity&lt;D&gt;&gt; for f64 {
        type Output = Quantity&lt;D&gt;;
        fn mul(self, y: Quantity&lt;D&gt;) -&gt; Quantity&lt;D&gt; {
            Quantity {value: self*y.value, dim: Ph}
        }
    }
    impl&lt;D: Dimension&gt; Add&lt;Quantity&lt;D&gt;&gt; for Quantity&lt;D&gt; {
        type Output = Quantity&lt;D&gt;;
        fn add(self, y: Quantity&lt;D&gt;) -&gt; Quantity&lt;D&gt; {
            Quantity {value: self.value + y.value, dim: Ph}
        }
    }
    
    pub struct Length;
    impl Dimension for Length {}

    impl fmt::Display for Quantity&lt;Length&gt; {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "{} m", self.value)
        }
    }

    pub mod unit {
        #![allow(non_upper_case_globals)]
        use crate::quantities::{Quantity, Length};
        use std::marker::PhantomData as Ph;
        pub const km: Quantity&lt;Length&gt; = Quantity {value: 1.000, dim: Ph};
        pub const  m: Quantity&lt;Length&gt; = Quantity {value: 1.0,   dim: Ph};
        pub const cm: Quantity&lt;Length&gt; = Quantity {value: 0.01,  dim: Ph};
        pub const mm: Quantity&lt;Length&gt; = Quantity {value: 0.001, dim: Ph};
    }
}

use quantities::{Quantity, Length};
use quantities::unit::{cm, mm};
use std::f64::consts::PI;

fn circumference(radius: Quantity&lt;Length&gt;) -&gt; Quantity&lt;Length&gt; {
    2.0*PI*radius
}

fn main() {
    let r = 4.0*cm + 2.0*mm;
    println!("{}", circumference(r));
}
</pre>

<h3 id="Strikte-Einheiten">Strikte Einheiten</h3>

<p>Manchmal möchte man bestimmte Einheiten pedantisch einfordern
oder die Umrechnung in kohärente Einheiten herauskürzen. Die Größe
bekommt dann als Typargument die konkrete Einheit anstelle der
abstrakten Dimension.

<pre class="rust ibox">
pub mod quantities {
    use std::marker::PhantomData as Ph;
    use std::ops::{Mul, Add};
    use std::fmt;

    pub trait Unit {
        const NAME: &amp;'static str;
    }

    #[derive(Clone,Copy)]
    pub struct Quantity&lt;U: Unit&gt; {
        value: f64, unit: Ph&lt;U&gt;
    }
    impl&lt;U: Unit&gt; Mul&lt;Quantity&lt;U&gt;&gt; for f64 {
        type Output = Quantity&lt;U&gt;;
        fn mul(self, y: Quantity&lt;U&gt;) -&gt; Quantity&lt;U&gt; {
            Quantity {value: self*y.value, unit: Ph}
        }
    }
    impl&lt;U: Unit&gt; Add&lt;Quantity&lt;U&gt;&gt; for Quantity&lt;U&gt; {
        type Output = Quantity&lt;U&gt;;
        fn add(self, y: Quantity&lt;U&gt;) -&gt; Quantity&lt;U&gt; {
            Quantity {value: self.value + y.value, unit: Ph}
        }
    }
    impl&lt;U: Unit&gt; From&lt;f64&gt; for Quantity&lt;U&gt; {
        fn from(x: f64) -&gt; Quantity&lt;U&gt; {Quantity {value: x, unit: Ph}}
    }
    impl&lt;U: Unit&gt; fmt::Display for Quantity&lt;U&gt; {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "{} {}", self.value, U::NAME)
        }
    }

    #[allow(non_camel_case_types)]
    #[derive(Clone, Copy)]
    pub struct cm;
    impl Unit for cm {const NAME: &amp;'static str = "cm";}
}

use quantities::{Quantity, cm};
use std::f64::consts::PI;

fn circumference(radius: Quantity&lt;cm&gt;) -&gt; Quantity&lt;cm&gt; {
    2.0*PI*radius
}

fn main() {
    let r = Quantity::&lt;cm&gt;::from(4.0);
    println!("{}", circumference(r));
}
</pre>

<h3 id="Terminierung">Terminierung erzwingen</h3>

<p>Programme können die Ausdrücke <code>panic!()</code> und
<code>unreachable!()</code> enthalten. Diese sind überall erlaubt,
da sie den leeren Typ haben und somit als divergent betrachtet
werden können. Enthält eine Funktion einen solchen Ausdruck direkt
oder indirekt über ihre transitiven Abhängigkeiten, ist die
normale Terminierung der Funktion nicht mehr gesichert, sie muss
vom Programmierer verifiziert werden. Es gibt zwar auch noch andere
Möglichkeiten der Divergenz &ndash; etwa wenn der Kontrollfluss
semantisch in eine unendliche Schleife gerät &ndash; das lassen
wir aber zunächst außen vor.

<p>Betrachten wir das folgende Programm das einen divergenten
Ausdruck <code>unreachable!()</code> enthält.
<pre class="rust ibox">
enum Symbol {Identifier, Number, Add}
struct Token {symbol: Symbol, data: Option&lt;String&gt;}

fn tokens_to_string(a: &amp;[Token]) -&gt; String {
    let mut buffer = String::new();
    for t in a {
        match t.symbol {
            Symbol::Identifier | Symbol::Number =&gt; {
                if let Some(data) = &amp;t.data {
                    buffer.push_str(data);
                } else {
                    unreachable!();
                }
            },
            Symbol::Add =&gt; {
                buffer.push('+');
            }
        }
        buffer.push(' ');
    }
    buffer
}

fn main() {
    let a = vec![
        Token {symbol: Symbol::Identifier, data: Some("x".to_string())},
        Token {symbol: Symbol::Add, data: None},
        Token {symbol: Symbol::Number, data: Some("1".to_string())}
    ];
    println!("{}", tokens_to_string(&amp;a))
}
</pre>

<p>Man verifiziert leicht, dass das Programm terminiert, falls
die Token-Liste denn korrekt erzeugt wurde. Umstrukturierung
der Datenstruktur gestattet aber eine Entfernung des missliebigen
divergenten Ausdrucks, die Terminierung des Programms ist dann
sicher.

<pre class="rust ibox">
enum Symbol {
    Identifier(String),
    Number(u32),
    Add
}

fn tokens_to_string(a: &amp;[Symbol]) -&gt; String {
    let mut buffer = String::new();
    for t in a {
        match t {
            Symbol::Identifier(id) =&gt; {
                buffer.push_str(id);
            },
            Symbol::Number(x) =&gt; {
                buffer.push_str(&amp;format!("{}",x));
            },
            Symbol::Add =&gt; {
                buffer.push('+');
            }
        }
        buffer.push(' ');
    }
    buffer
}

fn main() {
    let a = vec![
        Symbol::Identifier("x".to_string()),
        Symbol::Add,
        Symbol::Number(1)
    ];
    println!("{}", tokens_to_string(&amp;a))
}
</pre>

<p>Terminierung von Programmen unter allen Umständen ist unter gewissen
Anforderungen wichtig. Zwar ist Divergenz keine Sicherheitslücke
&ndash; explizite Divergenz wird vielmehr eingesetzt um logische
Fehler und Sicherheitslücken zu verhindern &ndash;
jedoch bleibt dabei die Möglichkeit bestehen,
dass das Programm irgendwann mit einer Fehlermeldung abstürzt.
Das ist meist ein eher gutes Verhalten &ndash; je früher die
Fehlermeldung kommt, desto besser &ndash; aber kein optimales.
Für ausfallsichere Systeme ist so eine Divergenz jedoch verboten,
etwa will man nicht dass einfach die Avionik eines Flugzeuges abstürzt.

<p>Freiheit von Divergenz kann in Rust leider nicht vollständig kodiert
werden, das Typsystem ist dafür nicht reichhaltig genug und die
standardmäßig verwendeten Datenstrukturen geben das aufgrund
der Speicherallokation zudem auch nicht her. Die normale implizite
Speicherallokation in Rust kann zu <code>panic!()</code> führen. Man
müsste stattdessen sogenannte <i>fehlbare</i> Speicherallokation
benutzen oder aber den Speicher ganz am Anfang des Programms allozieren.

<h2 id="Laufzeit">Prüfungen zur Laufzeit</h2>

<h3 id="Monaden">Monaden</h3>

<p>Wie gesagt stellen sich einem bei der Programmierung von
ausfallsicheren Systemen gewisse Schwierigkeiten. Dies fängt schon bei
den arithmetischen Operationen an, denn nicht einmal diese sind total.
Kommt es zum arithmetischen Überlauf, bricht das Programm ab &ndash;
zumindest wenn die Erzeugung von automatischen Überlauf-Prüfungen
aktiviert ist, andernfalls kommt es zu einer Verschleierung der
Fehlerursache, was man als Verschlimmerung empfinden kann. Die
Division durch null führt bei Ganzzahlen immer zu einem
Programmabbruch.

<p>Wie im Abschnitt ›<a href="FP.htm#Monaden">Monaden</a>‹
im Kapitel ›Funktionale Programmierung‹ erläutert, lassen sich mit
einem Wrapper-Typ totale Funktionen aus partiellen gewinnen.
Unter Beschränkung auf solche monadischen Typen erreicht man dann
sichere Terminierung, da schlicht keine partiellen Funktionen mehr
zur Verfügung stehen, vorausgesetzt man benutzt die normalen
Datentypen nicht mehr. Das folgende Beispiel zeigt eine ausfallsichere
Umwandlung einer Zeichenkette in eine Ganzzahl &ndash; ein recht
kurzes Beispiel, wobei aber auch ein kompletter mit monadischen Typen
arbeitender Parser denkbar und machbar ist.

<pre class="rust ibox">
mod ru32 {
    trait Monad&lt;T&gt; where Self: Sized {
        fn unit(x: T) -&gt; Self;
        fn bind(self, f: impl Fn(T)-&gt;Self) -&gt; Self;
    }

    #[derive(Debug, Clone, Copy)]
    pub struct Ru32 (Option&lt;u32&gt;);

    impl Ru32 {pub fn err() -&gt; Self {return Ru32(None);}}
    impl From&lt;u32&gt; for Ru32 {
        fn from(x: u32) -&gt; Self {Self(Some(x))}
    }
    impl From&lt;char&gt; for Ru32 {
        fn from(c: char) -&gt; Self {Self(Some(u32::from(c)))}
    }
    impl Monad&lt;u32&gt; for Ru32 {
        fn unit(x: u32) -&gt; Self {Self::from(x)}
        fn bind(self, f: impl Fn(u32)-&gt;Self) -&gt; Self {
            match self.0 {
                Some(x) =&gt; f(x), None =&gt; Self(None)
            }
        }
    }
    impl std::ops::Add&lt;Self&gt; for Ru32 {
        type Output = Self;
        fn add(self, y: Self) -&gt; Self {
            self.bind(|x| y.bind(|y| Self(x.checked_add(y))))
        }
    }
    impl std::ops::Sub&lt;Self&gt; for Ru32 {
        type Output = Self;
        fn sub(self, y: Self) -&gt; Self {
            self.bind(|x| y.bind(|y| Self(x.checked_sub(y))))
        }
    }
    impl std::ops::Mul&lt;Ru32&gt; for u32 {
        type Output = Ru32;
        fn mul(self, y: Ru32) -&gt; Ru32 {
            y.bind(|y| Ru32(self.checked_mul(y)))
        }
    }
}

use ru32::Ru32;

fn str_to_u32(s: &amp;str) -&gt; Ru32 {
    let mut acc = Ru32::from(0);
    for digit in s.chars() {
        if !digit.is_digit(10) {return Ru32::err();}
        acc = 10*acc + (Ru32::from(digit) - Ru32::from('0'));
    }
    acc
}

fn main() {
    println!("{:?}", str_to_u32("1440"));
    println!("{:?}", str_to_u32("10000000000"));
}
</pre>

<p>Nun kann man einwenden, dass das Programm ineffizient ist weil es
unnötigen Aufwand enthält. Das ist ein gutes und richtiges Argument,
der springende Punkt soll hier aber darin bestehen, das Programm
erst einmal sicher zu machen. Nach dieser mentalen Trennung kümmern
wir uns um Optimierungen bezüglich Laufzeit und Speicherverbrauch nun
<i>im Nachhinein</i>. Dabei kann man die Korrektheit von
Optimierungen auch mit dem <a href="Verifikation.htm">Hoare-Kalkül</a>
beweisen oder nicht, je nachdem wie pedantisch man es halten will.

<p>Die Bedingung <code>digit.is_digit(10)</code> liefert z.&nbsp;B. die
Einschränkung <code>'0'&nbsp;&le;&nbsp;digit&nbsp;&le;&nbsp;'9'</code>,
infolge ist <code>0&nbsp;&le;&nbsp;digit-'0'</code>. Demnach darf man
<pre class="rust ibox">
Ru32::from(digit) - Ru32::from('0')
</pre>

<p>ersetzen gegen:
<pre class="rust ibox">
Ru32::from(u32::from(digit) - u32::from('0'))
</pre>


<h3 id="Contracts">Vertragsbasierte Programmierung</h3>

<p>Bei der vertragsbasierten Programmierung, engl. contract programming,
sichern Laufzeitprüfungen das korrekte Arbeiten von Algorithmen ab.
Die Prüfungen haben eine strukturierte Form, sie kommen als Prüfung
von <i>Vorbedingungen</i>, <i>Nachbedingungen</i> und
<i>Invarianten</i> vor.

<p>Nehmen wir als Beispiel eine Funktion <code>zip</code>, welche
zwei Arrays <code>a,b</code> entgegennimmt und ein Array
von Paaren <code>(a<sub>k</sub>,b<sub>k</sub>)</code> zurückgibt.
Die Vorbedingung ist, dass beide Arrays die gleiche Länge haben
müssen, die Nachbedingung dass das Ergebnis auch diese Länge besitzt.

<p>Die Vor- und Nachbedingung kann man mittels assert-Anweisungen
formulieren.

<pre class="rust ibox">
fn zip&lt;X: Clone, Y: Clone&gt;(a: &amp;[X], b: &amp;[Y]) -&gt; Vec&lt;(X, Y)&gt; {
    let n = a.len();
    
    // Precondition
    assert!(n == b.len(), "zip(a, b): a.len() == b.len()");

    let mut acc = Vec::with_capacity(n);
    for k in 0..n {
        acc.push((a[k].clone(), b[k].clone()));
    }

    // Postcondition
    assert!(n == v.len());

    acc
}

fn main() {
    let a = vec![1, 2, 3, 4];
    let b = vec!["a", "b", "c", "d"];
    let c = zip(&amp;a, &amp;b);
    println!("{:?}", c);
}
</pre>

<p>Ein Nachteil bei dieser Formulierung ist, dass eine
return-Anweisung die Nachbedingung unterdrücken würde.
Eine Konstruktion zur Entfernung dieses Schönheitsfehlers ist
die Verhüllung in einer inneren Funktion, wobei ein Makro für
hübsche Syntax sorgt. Die Verhüllung ist auch unter der Bezeichnung
IIFE bekannt, das steht für <i>Immediately invoked function
expression</i>.

<pre class="rust ibox">
macro_rules! contract {
    (precondition $pre:tt $body:tt
     postcondition($arg:ident) $post:tt)
    =&gt; {
        $pre;
        let value = (|| $body)();
        let $arg = &amp;value;
        $post;
        value
    }
}

fn zip&lt;X: Clone, Y: Clone&gt;(a: &amp;[X], b: &amp;[Y]) -&gt; Vec&lt;(X, Y)&gt; {
    let n = a.len();
    contract! {
        precondition {
            assert!(n == b.len(), "zip(a, b): a.len() == b.len()");
        }{
            let mut acc = Vec::with_capacity(n);
            for k in 0..n {
                acc.push((a[k].clone(), b[k].clone()));
            }
            acc
        } postcondition(acc) {
            assert!(n == acc.len());
        }
    }
}
</pre>

<p>Zuweilen findet man auch die Benennung der Zusicherungen als
Verben vor. Dann wird die Vorbedingung durch <i>require</i>
eingeleitet, die Nachbedingung durch <i>ensure</i>.

<h3 id="Rekursionstiefe">Beschränkung der Rekursionstiefe</h3>

<p>Erlaubt eine Funktion beliebige Rekursionstiefe, kommt es irgendwann
zu einem Überlauf des Laufzeitstapels, es kommt zum Abbruch des
laufenden Programms. Wir würden für bestimmte Anwendungen aber gerne
haben, dass das Programm nicht abstürzt bzw. so terminiert wie wir es
wollen. Man kann sich dabei z.&nbsp;B. eine Flugzeugavionik vorstellen
oder einen Parser für unbekannte Daten aus dem Internet.

<p>Eine Möglichkeit wäre es, rekursive Funktionen schlicht zu
verbieten, wie in MISRA-C gefordert. Dies kann man aber als zu
einschränkend empfinden, da viele praktische Verfahren wie der
rekursive Abstieg mittels wechselseitiger Rekursion formuliert sind.

<p>Eine weitere Überlegung bestünde darin, das Programm in einem
extra vorgesehenen Thread auszuführen. Beim Überlauf des
Laufzeitstapels kommt es jedoch unweigerlich zum Abbruch des
gesamten Programms, nicht nur des aktuellen Threads.

<p>Wir können das Problem umgehen, indem die maximale Rekursionstiefe
vorab beschränkt wird. Betrachten wir exemplarisch
die rekursive Berechnung der Addition:
<pre class="rust ibox">
fn add(x: u32, y: u32) -&gt; u32 {
    if y == 0 {x} else {add(x, y - 1) + 1}
}
</pre>
<p>Auf meinem Computer lag die maximale Rekursionstiefe
für <code>fn main() {add(0,N);}</code> bei <code>N=174551</code>.
Der genaue Wert ist von unbekannten technischen Details der
Laufzeitumgebung abhängig und muss nicht unbedingt eine feste
Konstante sein. Wenn man unbedingt möchte, kann man diesen Wert durch
Vergrößerung des Laufzeitstapels erhöhen, der Compiler oder das
Laufzeitsystem sollte dafür eine Konfiguration bereithalten.

<p>Man modifiziert die Funktion nun so:
<pre class="rust ibox">
fn add(x: u32, y: u32, depth_max: u32) -&gt; Result&lt;u32,()&gt; {
    if depth_max == 0 {return Err(());}
    if y == 0 {Ok(x)} else {Ok(add(x, y - 1, depth_max - 1)? + 1)}
}
</pre>


<h3 id="Tests">Automatische Tests</h3>

<p>Ausreizen des Typsystems gestattet es, so viele
Implementierungsfehler wie möglich vom Compiler
abfangen zu lassen. Trotzdem verbleibt dann immer noch
Programmverhalten das sich einer Beschreibung durch das Typsystem
entzieht. Das hat unter anderem damit zu tun dass das Typsystem der
Programmiersprache nicht reichhaltig genug ist, um die benötigten
logischen Zusammenhänge vollständig beschreiben zu können. Außerdem
kann der Compiler keinesfalls feststellen ob ein Algorithmus korrekt
implementiert ist, denn dazu müsste der Compiler zunächst eine formale
Spezifikation bekommen die der Algorithmus zu erfüllen hat. Diese
Spezifikation liegt aber offensichtlich oft noch nicht einmal vor.

<p>Ein anderer Weg zum Abfangen von fehlerhaften Algorithmen sind
automatische Tests. Umso ausgiebiger diese Tests ausfallen, umso
besser.

<p>Tests sind gewöhnliche Funktionen, die man am besten ordentlich
in einem Modul ansammelt. Einem solchen Modul gibt man das Attribut
<code>#[cfg(test)]</code>,
dies sorgt dafür, dass das Modul nur beim Testen kompiliert wird.
Tests sind gewöhnliche Funktionen. Auch bei Tests gibt es
Hauptfunktionen wie <code>main</code>. Im Unterschied zum Programm
kann es aber bei den Tests mehrere unterschiedliche Testläufe geben.
Aus diesem Grund gibt man den Hauptfunktionen gewöhnliche Namen und
markiert sie mit dem Attribut <code>#[test]</code>.

<p>Angenommen, jemand hat einen neuen Algorithmus geschrieben.
Mir ist dazu kein besseres Beispiel eingefallen als ein Primzahltest
<code>is_prime</code>, das ist ein recht kurzer Algorithmus.
Der Algorithmus wird mit einem schon bekannten einfacheren Algorithmus
<code>is_prime_basic</code> überprüft. Zur Sicherheit wird der
einfache Algorithmus zusätzlich mit einem unabhängig ermittelten
Resultat überprüft.

<pre class="rust ibox">
fn is_prime(n: u32) -&gt; bool {
    if n &lt; 2 {return false;}
    let mut i: u32 = 2;
    while i*i &lt;= n {
        if n%i == 0 {return false;}
        i += 1;
    }
    true
}

#[cfg(test)]
mod tests {
    use crate::is_prime;

    fn is_prime_basic(n: u32) -&gt; bool {
        n &gt; 1 &amp;&amp; (2..n).all(|k| n%k != 0)
    }

    #[test]
    fn test0() {
        let s: u32 = (0..10000).filter(|&amp;n| is_prime_basic(n)).sum();
        assert_eq!(s, 5736396);
    }
    
    #[test]
    fn test1() {
        for n in 0..10000 {
            assert_eq!(is_prime(n), is_prime_basic(n));
        }
    }
}

fn main() {
    let a: Vec&lt;u32&gt; = (1..).filter(|&amp;n| is_prime(n))
        .take(100).collect();
    println!("{:?}", a);
}
</pre>

<p>Das ist natürlich kein Beweis, dass der Algorithmus in jedem
Fall das richtige Ergebnis liefert. Tatsächlich wurde hier
der arithmetische Überlauf nicht berücksichtigt, der erst bei
viel größeren Zahlen auftritt. Im Release-Modus
würden Overflow-Checks entfernt werden, ein Überlauf bliebe also
im schlimmsten Fall unentdeckt.

<h2 id="Lints">Lints ausnutzen</h2>

<h3 id="must-use">Implizites Verwerfen verhindern</h3>

<p>Oft stellt es einen logischen Fehler dar, wenn der Rückgabewert
einer Funktion einfach verworfen wird. Bspw. ergibt das Aufrufen einer
reinen Funktion wie

<pre class="rust ibox">
fn even(x: i32) -&gt; bool {x%2 == 0}
</pre>

<p>ohne Verwendung des Rückgabewertes keinen Sinn. Zur Vorbeugung
gegen diese Art von logischen Fehlern steht das Attribut
<code>must_use</code> zur Verfügung.

<pre class="rust ibox">
#[must_use]
fn even(x: i32) -&gt; bool {x%2 == 0}
</pre>

<p>Die Anweisung
<pre class="rust ibox">
even(0);
</pre>

<p>führt dann bei der Kompilation zu einer Warnung. Möchte man den
Wert trotzdem verwerfen, muss man dies nun explizit tun:

<pre class="rust ibox">
let _ = even(0);
</pre>

<p>Neben den Funktionen sind auch die Definitionen von Strukturen,
Enumerationen und Traits mit dem Attribut <code>must_use</code>
behaftbar. So hat der Typ <code>Result</code> dieses bekommen,
damit die Err-Variante nicht versehentlich ignoriert wird,
auch wenn die Ok-Variante nicht gebraucht wird. Ein solcher Fall
zeigt sich ganz klar etwa bei <code>Result&lt;(),E&gt;</code>.

<h2 id="Literatur">Literatur</h2>

<ol>
<li>José Duarte, António Ravara: »<a href="https://doi.org/10.1145/3475061.3475082"
   >Retrofitting Typestates into Rust</a>«.
   In: 25th Brazilian Symposium on Programming Languages (SBLP 2021),
   27. September bis 1. Oktober 2021, Joinville, Brasilien.
   ACM, New York, NY, USA.
<li>»<a href="https://anssi-fr.github.io/rust-guide/"
   >Secure Rust Guidelines &ndash; Recommendations for secure
   applications development with Rust</a>«. ANSSI (2020).
<li>»<a href="https://de.wikipedia.org/wiki/MISRA-C"
  >MISRA C: Guidelines for the use of the C language in critical systems</a>«.
<li>»<a href="https://en.wikipedia.org/wiki/CERT_C_Coding_Standard"
  >SEI CERT C Coding Standard: Rules for Developing Safe,
  Reliable, and Secure Systems</a>«.
<li>»<a href="https://cwe.mitre.org/top25/archive/"
  >CWE Top 25 Most Dangerous Software Weaknesses</a>«.
</ol>

</body>
</html>
