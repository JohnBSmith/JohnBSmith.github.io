<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="css/main.css" rel="stylesheet">
  <script src="js/main.js"></script>
  <script src="js/rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Funktionen</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Tupelwertige-Funktionen">Tupelwertige Funktionen</a>
<li><a href="#Variadische-Funktionen">Variadische Funktionen</a>
</ol>

<h2 id="Tupelwertige-Funktionen">Tupelwertige Funktionen</h2>

<p>Rust erlaubt Funktionen mit mehr als einem Rückgabewert.
Ermöglicht wird dies durch die Zusammenfassung der Rückgabewerte zu
einem Tupel.

<p>Als einfaches Beispiel bietet sich die Umrechnung zwischen
kartesischen und polaren Koordinaten an.

<pre class="rust ibox">
fn from_polar(r: f64, phi: f64) -&gt; (f64,f64) {
    (r*phi.cos(), r*phi.sin())
}

fn polar_from(x: f64, y: f64) -&gt; (f64,f64) {
    (x.hypot(y), y.atan2(x))
}

fn main() {
    use std::f64::consts::PI;
    let (x,y) = from_polar(1.0,0.5*PI);
    println!("x = {:.4}; y = {:.4}",x,y);

    let (r,phi) = polar_from(x,y);
    println!("r = {:.4}; phi = {:.4}",r,phi);
}
</pre>

<h2 id="Variadische-Funktionen">Variadische Funktionen</h2>

<h3>Homogene Argumente</h3>

<p>Als <i>variadisch</i> bezeichnet man Funktionen, die keine
feste Arität haben, d.h. keine feste Anzahl an Argumenten. Zwar sind
solche Funktionen in Rust nicht direkt formulierbar, allerdings
lassen sie sich ausreichend ergonomisch nachstellen, indem der
variadische Teil in ein Slice verpackt wird.

<p>Für die Funktion <code>mean</code>, welche den Mittelwert der
Argumente bildet, findet sich bspw. die Formulierung:
<pre class="rust ibox">
fn mean(a: &amp;[f64]) -&gt; f64 {
    a.iter().sum::&lt;f64&gt;()/(a.len() as f64)
}

fn main() {
    let m = mean(&amp;[1.0, 2.0, 3.0, 4.0]);
    println!("{}",m);
}
</pre>

<h3>Heterogene Argumente</h3>

<p>Bei heterogenen Argumenten möchte man für die Argumente einer
variadischen Funktion jeweils einen unterschiedlichen Typ zulassen.
Ein Ansatz, wie sich das erreichen lässt, ist das Hochcasten der
Argumente in einen Trait-Typ. Das kann im Extremfall auch der
Trait <code>Any</code> sein. Dafür muss von den Argumenten jeweils
ein Borrow gebildet werden. Wir definieren für die Borrows ein Makro
<code>argv</code>, das sorgt für hübsche Syntax.

<p>Das Beispiel zeigt eine variadische Funktion die Argumente
unterschiedlichen Typs verträgt, solange diese nur den
Trait <code>Display</code> implementieren.

<pre class="rust ibox">
macro_rules! argv {
    ($($x:expr),*) =&gt; {&amp;[$(&amp;$x),*]}
}

fn display(a: &amp;[&amp;dyn std::fmt::Display]) {
    for x in a {
        println!("{}",x);
    }
}

fn main() {
    display(argv!["Eule", 24, true]);
}
</pre>

</body>
</html>

