<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Rust-Buch</title>
  <link href="main.css" rel="stylesheet">
  <script src="rust.js"></script>
</head>
<body>

<p>&uparrow;<a href="Rust.htm">Programmieren in Rust</a>
<h1>Zusammengesetzte Datentypen</h1>

<h2>Inhaltsverzeichnis</h2>
<ol>
<li><a href="#Strukturen">Strukturen</a>
<li><a href="#Enumerationen">Enumerationen</a>
<li><a href="#Nominal">Nominale Typisierung</a>
</ol>

<h2 id="Strukturen">Strukturen</h2>
<p>Wenn man sich einen Datentyp zunächst als Menge von zulässigen Werten
vorstellt, dann ergibt auch das kartesische Produkt von zwei oder
mehr Datentypen einen Sinn. Sind <code>A</code> und <code>B</code> zwei
Datentypen, dann ist das kartesische Produkt die Menge

<p class="math">A &times; B
:= {(<var>a</var>,&nbsp;<var>b</var>) | <var>a</var>&in;A &and; <var>b</var>&in;B},

<p>das ist die Menge aller geordneten Paare, bei denen die erste
Komponente den Typ <code>A</code> und die zweite Komponente
den Typ <code>B</code> besitzt. In Rust schreibt man diesen Typ
als <code>(A,B)</code>. Zu beachten ist, dass die Indizierung
nicht bei eins startet, sondern bei null. Ein Beispiel dazu:

<pre class="rust indent">
fn main(){
    let t: (u32, u32) = (360, 240);
    println!("({}|{})", t.0, t.1);
}
</pre>

<p>Aus ergonomischen Gründen ist es nun wünschenswert,
die Komponenten der Tupel nicht unter ihrem Index anzusprechen,
sondern über Bezeichner. Man schreibt in Rust dann z.&nbsp;B.
<code>struct Name{a: A, b: B}</code>, wobei die erste Komponente unter
dem Bezeichner <code>a</code> und die zweite unter <code>b</code>
angesprochen wird. Ein Beispiel dazu:

<pre class="rust indent">
struct Point{
    a: u32, b: u32
}

fn main(){
    let t: Point = Point{a: 360, b: 240};
    println!("({}|{})", t.a, t.b);
}
</pre>

<p>Ein als <code>struct</code> definierter zusammengesetzer Datentyp
wird als <i>Struktur</i> bezeichnet. In der theoretischen Informatik
spricht man vom <i>Produkt</i>. Bei Pascal und verwandten
Sprachen kennt man die synonymen Begriffe <i>Record</i>
und <i>Verbund</i>.


<h2 id="Enumerationen">Enumerationen</h2>
<p>Stellen wir uns einen Datentyp zunächst wieder als Menge von
zulässigen Werten vor, dann ergibt auch die disjunkte Vereinigung
von zwei oder mehr Datentypen einen Sinn. Sind <code>A</code>
und <code>B</code> zwei Datentypen, dann ist disjunkte Vereinigung
die Menge

<p class="math">A+B
:= {(0,&nbsp;<var>x</var>)&nbsp;|&nbsp;<var>x</var>&in;A}
&cup; {(1,&nbsp;<var>x</var>)&nbsp;|&nbsp;<var>x</var>&in;B}.

<p>Die disjunkte Vereinigung, auch <i>Summe</i> genannt,
wird demnach als Zusammenfassung der Wertemengen betrachtet,
wobei aber ein <i>Tag</i>, hier <code>0</code> oder <code>1</code>,
eine strenge Unterscheidung der Wertemengen ermöglicht.

<p>Aus ergonomischen Gründen ist es nun wieder wünschenswert,
wenn Bezeichner anstelle von Indizes als Tags verwendet werden.
Eine solche Konstruktion wird in Rust als <code>enum</code> bezeichnet.
Ein Beispiel:

<pre class="rust indent">
enum E{
    Int(i32), Char(char)
}

fn print(x: E) {
    match x {
        E::Int(i) =&gt; {println!("Zahl: {}.",i);},
        E::Char(c) =&gt; {println!("Zeichen: {}.",c);}
    }
}

fn main(){
    let x: E = E::Int(12);
    let y: E = E::Char('y');
    print(x);
    print(y);
}
</pre>

<p>Hier ist <code>E</code> eine disjunkte Vereinigung mit den
Tags <code>E::Int</code> und <code>E::Char</code>.

<p>Synonym zu <i>Enumeration</i> und <i>Summe</i> spricht man
auch von einer <i>disjunkten Vereinigung</i>
(engl. <i>disjoint union</i>), <i>diskriminierten Vereinigung</i>
(engl. <i>tagged union</i>), oder einem <i>Koprodukt</i>.

<h2 id="Nominal">Nominale Typisierung</h2>

<p>Zu unterscheiden ist zwischen <i>struktureller</i> und
<i>nominaler</i> Typisierung. Bei der strukturellen Typisierung &ndash;
man spricht auch von anonymen Typen &ndash; stimmen zwei Typen genau
dann überein, wenn sie von gleicher Gestalt sind. Bei der nominalen
Typisierung stimmen zwei Typen genau dann überein, wenn sie den selben
Namen haben, dessen Definition aber einmalig ist. Die nominale
Typisierung behaftet so gesagt einen strukturellen Typ mit einem
im gesamten Programm und der gesamten Welt einzigartigen Namen, welcher
den resultierenden Typ unterschiedlich von allen anderen Typen macht.

<p>Die folgende Tabelle gibt Aufschluss, wie nominale und
struktruelle Typen in Rust erstellt werden:
<table class="bt indent">
<tr>
<th>
<th>Nominal
<th>Strukturell
<tr>
<th>Struktur
<td><code>struct Name{x:X,y:Y}</code>
<td>nicht vorhanden
<tr>
<th>Tupel
<td><code>struct Name(X,Y);</code>
<td><code>(X,Y)</code>
<tr>
<th>Enumeration
<td><code>enum Name{A(X),B(Y)}</code>
<td>nicht vorhanden
<tr>
<th>Feld
<td><code>struct Name([X;2]);</code>
<td><code>[X;2]</code>
</table>

<p>Die strukturelle Typisierung erlaubt vor allem Ergonomie und
Komfort. Die nominale Typisierung ist dagegen grundlegend für die
Typsicherheit.

<p>Man kann zu jedem beliebigen strukturellen Typen <code>T</code>
einen nominalen erzeugen, indem man ihn als <code>struct Name(T)</code>
einhüllt.

</body>
</html>

