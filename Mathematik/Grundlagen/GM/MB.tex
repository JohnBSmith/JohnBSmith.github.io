
\chapter{Maschinengestütztes Beweisen}

\section{Terme und Typen}

\subsection{Zur Aussagenlogik}

Der Einführung einer Subjunktion\index{Subjunktion} entspricht die
Einführung einer $\lambda$"=Abstraktion,\index{Abstraktion}%
\index{Lambda-Abstraktion} also einer anonymen Funktion.%
\index{anonyme Funktion} Der aus der Herleitung
\[\begin{prooftree}
    \infer0{A,B\vdash A}
  \infer1{A\vdash B\cond A}
\infer1{\vdash A\cond B\cond A}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
    \infer0{\Gamma, a\colon A, b\colon B\vdash a\colon A}
  \infer1{\Gamma, a\colon A\vdash (b\mapsto a)\colon B\to A}
\infer1{\Gamma\vdash a\mapsto (b\mapsto a)\colon A\to B\to A}
\end{prooftree}\]
mit $\Gamma:=[A\colon\mathrm{Prop}, B\colon\mathrm{Prop}]$ entstandene
Term wird zum Beispiel abgefasst als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` Beispiel1 (A B: Prop):
  A -> B -> A.
`\kw{Proof}`
  `\kw{fun}` a => `\kw{fun}` b => a.
\end{lstlisting}
Der Beseitigung der Subjunktion entspricht die Applikation einer
Funktion. Betrachten wir dazu die Herleitung
\[\begin{prooftree}
      \infer0{A\cond B\vdash A\cond B}
      \infer0{A\vdash A}
    \infer2{A,A\cond B\vdash B}
  \infer1{A\vdash (A\cond B)\cond B}
\infer1{\vdash A\cond (A\cond B)\cond B}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
      \infer0{\Gamma,f\colon A\to B\vdash f\colon A\to B}
      \infer0{\Gamma,a\colon A\vdash a\colon A}
    \infer2{\Gamma,a\colon A, f\colon A\to B\vdash f(a)\colon B}
  \infer1{\Gamma,a\colon A\vdash (f\mapsto f(a))\colon (A\to B)\to B}
\infer1{\Gamma\vdash (a\mapsto f\mapsto f(a))\colon A\to (A\to B)\to B}
\end{prooftree}\]
mit $\Gamma:=[A\colon\mathrm{Prop}, B\colon\mathrm{Prop}]$.
Der Beweis wird demnach implementiert als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` Beispiel2 (A B: Prop):
  A -> (A -> B) -> B.
`\kw{Proof}`
  `\kw{fun}` a => `\kw{fun}` f => f a.
\end{lstlisting}

\begin{table}
\begin{center}
\caption{Funktionen für die Konjunktion und die Disjunktion}
\label{tab:Funktionen-Konjunktion-Disjunktion}
\begin{tabular}{@{}cll@{}}
\toprule
\textbf{Junktor} & \textbf{Einführung} & \textbf{Beseitigung}\\
\midrule[\heavyrulewidth]
Konjunktion & $\code{conj}\,A\;B\colon A \to B \to A\land B$
& $\code{proj1}\;A\;B\colon A\land B\to A$\\
& & $\code{proj2}\;A\;B\colon A\land B\to B$\\
\midrule[\heavyrulewidth]
Disjunktion & $\code{or\_introl}\,A\;B\colon A\to A\lor B$
& $\code{or\_elim}\,A\;B\colon (A\to C)\to (A\to C)$\\
& $\code{or\_intror}\,A\;B\colon A\to B\lor A$
& $\phantom{\code{or\_elim}\,A\;B\colon}\to (A\lor B\to C)$\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\noindent
Tabelle \ref{tab:Funktionen-Konjunktion-Disjunktion} zeigt die Funktionen,
mit denen Terme für die Konjunktion und die Disjunktion konstruiert
werden können.\index{Konjunktion}\index{Disjunktion}

Ein kurzes Beispiel. Mit der Herleitung
\[\begin{prooftree}
    \hypo{\Gamma\vdash A\land B}
  \infer1{\Gamma\vdash B}
    \hypo{\Gamma\vdash A\land B}
  \infer1{\Gamma\vdash A}
\infer2{\Gamma\vdash B\land A}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
    \hypo{\Gamma\vdash h\colon A\land B}
  \infer1{\Gamma\vdash\code{proj2}(h)\colon B}
    \hypo{\Gamma\vdash h\colon A\land B}
  \infer1{\Gamma\vdash\code{proj1}(h)\colon A}
\infer2{\Gamma\vdash\code{conj} (\code{proj2}(h)) (\code{proj1}(h))\colon B\land A}
\end{prooftree}\]
kommt man bezüglich $\Gamma:=[h\colon A\land B]$ zum Term
\[(h\mapsto\code{conj} (\code{proj2}(h)) (\code{proj1}(h)))\colon A\land B\to B\land A.\]
Der Quelltext hierzu:

\noindent
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` conj_commutativity (A B: Prop):
  A /\ B -> B /\ A.
`\kw{Proof}`
  `\kw{fun}` h => conj (proj2 h) (proj1 h).
\end{lstlisting}
Dieser Beweis ist allerdings für \texttt{Prop} spezifisch. Für Typen
allgemeiner Art findet sich aber ein analoger Beweis. Der
Curry"=Howard"=Korrespondenz entsprechend betrifft dies die Produkttypen
$A\times B$, die \verb|prod A B| oder \verb|A*B| geschrieben werden. Die
zweite Schreibweise wird aber nur gestattet, wenn keine Zweideutigkeit
mit der Multiplikation von Zahlen besteht. Die Analoga zu
\texttt{proj1}, \texttt{proj2} und \texttt{conj} sind
\texttt{fst}, \texttt{scd} und \texttt{pair}, wobei dies für
first, second steht und man \verb|(x, y)| statt \verb|pair x y|
schreiben darf. Es ergibt sich also der folgende Quelltext:
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` prod_commutativity (A B: Type):
  A * B -> B * A.
`\kw{Proof}`
  `\kw{fun}` h => (snd h, fst h).
\end{lstlisting}
Statt die Projektionen zu nutzen, kann der Term auch via
Musterabgleich als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{fun}` h => `\kw{match}` h `\kw{with}` (a, b) => (b, a) `\kw{end}`
\end{lstlisting}
abgefasst werden, wobei hierfür zudem die Kurzschreibweise
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{fun}` '(a, b) => (b, a) `\textrm{bzw.}` `\kw{fun}` '(pair a b) => (pair b a)
\end{lstlisting}
existiert.

Für den Beweis von $A\lor B\cond B\lor A$ findet sich
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` disj_commutativity (A B: Prop):
  A \/ B -> B \/ A.
`\kw{Proof}`
  or_elim
    (`\kw{fun}` a => or_intror a)
    (`\kw{fun}` b => or_introl b).
\end{lstlisting}
Alternativ wird der Term via Musterabgleich abgefasst:
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{fun}` h => `\kw{match}` h `\kw{with}`
| or_introl a => or_intror a
| or_intror b => or_introl b
`\kw{end}`
\end{lstlisting}

\noindent
Die Negation $\lnot A$ wird als $A\cond\bot$ definiert, weshalb sie
unter die Regeln der Subjunktion fällt, und daher keine eigenen benötigt.
Die Syntax für $\bot$ ist \code{False}, und die für $\lnot A$ ist
\verb|~A|. Ein kurzes Beispiel. Zum Beweis von $A\cond\lnot\lnot A$
braucht man ja lediglich aus $A$ und $\lnot A$ einen Widerspruch
herstellen. Es liegt also ein $a\colon A$ und eine Funktion
$f\colon\lnot A$ bzw. $f\colon A\to\bot$ vor, woraus nur
noch $f(a)$ geformt werden braucht. Der Satz und dessen Beweisterm sind
demnach formalisiert als

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` double_negation_intro (A: Prop):
  A -> ~~A.
`\kw{Proof}`
  `\kw{fun}` a: A => `\kw{fun}` f: ~A => f a.
\end{lstlisting}

\noindent
Der Beweis der Umkehrung ist nicht möglich, insofern das System auf
intuitionistischer Logik basiert. Wir können die Beseitigung der
Doppelnegation allerdings axiomatisch voraussetzen via

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Axiom}` ax_dne: `\kw{forall}` (A: Prop), ~~A -> A.
\end{lstlisting}

\noindent
Zur pedantischen Schaffung von Klarheit gäbe es alternativ auch noch
die Möglichkeit, DNE in sämtlichen Sätzen, deren Beweis von DNE abhängt,
explizit als Prämisse aufzuführen. Zur Abkürzung kann man DNE dabei
verpacken mit der

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Definition}` DNE := `\kw{forall}` (A: Prop), ~~A -> A.
\end{lstlisting}

\noindent
Zum Beispiel gelingt der Beweis von ex falso quodlibet vermittels DNE als
\[\begin{prooftree}
    \infer0{\bot,\lnot A\vdash\bot}
  \infer1{\bot\vdash\lnot\lnot A}
\infer1[DNE]{\bot\vdash A}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
    \infer0{\Gamma,x\colon \bot,f\colon \lnot A\vdash x\colon \bot}
  \infer1{\Gamma,x\colon\bot\vdash (f\mapsto x)\colon \lnot\lnot A}
\infer1[DNE]{\Gamma,x\colon\bot\vdash \mathrm{dne}(A)(f\mapsto x)\colon A}
\end{prooftree}\]
Die diesbezügliche Implementierung ist

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` efq (dne: DNE) (A: Prop): False -> A.
`\kw{Proof}` `\kw{fun}` x: False => dne A (`\kw{fun}` f: ~A => x).
\end{lstlisting}

\noindent
Man kann EFQ aber auch ohne Weiteres erhalten, da das logische System
bereits ein intuitionistisches ist. Später werden wir sehen, dass
$\bot$ als leerer induktiver Typ gedeutet werden darf. Infolge erhält man
einen Beweis von EFQ vermittels leerem Musterabgleich, so sonderbar das
auch erscheinen mag.

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` efq (A: Prop): False -> A.
`\kw{Proof}` `\kw{fun}` x: False => `\kw{match}` x `\kw{with}` `\kw{end}`.
\end{lstlisting}

\subsection{Zur Prädikatenlogik}

Der \strong{Allquantifizierung} $\forall x\in X\colon A(x)$ entspricht
$\prod_{x\colon X} A(x)$, ein Typ abhängiger Funktionen. Einen Bezug auf
diese Beziehung herstellend, bekam der Typ die Syntax
\code{\kw{forall} x: X, A x}. Ein Beweis der Allaussage der ist also eine
Funktion $f$, die jedem Individuum $x$ vom Typ $X$ einen Wert $f(x)$ vom
Typ $A(x)$ zuordnet, womit $A(x)$ zu jedem $x$ bewohnt sein muss.
Einfaches Beispiel. Gezeigt werden soll
\[A\land (\forall x\in X\colon B(x))\cond\forall x\in X\colon A\land B(x)).\]
Konstruiert werden muss eine Funktion, die jedem $x\colon X$ einen
Wert vom Typ $A\times B(x)$ zuordnet, unter der Annahme, es sei ein Paar $(a,f)$
mit $a\colon A$ und $f(x)\colon B(x)$ zu jedem $x\colon X$ verfügbar.
Dies schafft
\[\textstyle (a,f)\colon A\times\prod_{x\in X} B(x)\mapsto
x\colon X\mapsto (a, f(x)).\]
Die Implementierung ist
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` const_factor (X A: Type) (B: X -> Type):
  A * (forall x: X, B x) -> forall x: X, A * B x.
`\kw{Proof}`
  `\kw{fun}` '(a, f) => `\kw{fun}` x => (a, f x).
\end{lstlisting}
Für Aussagen vom Typ \code{Prop} braucht man aber die Modifizierung
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` const_factor (X: Type) (A: Prop) (B: X -> Prop):
  A /\ (forall x: X, B x) -> forall x: X, A /\ B x.
`\kw{Proof}`
  `\kw{fun}` '(conj a f) => `\kw{fun}` x => conj a (f x).
\end{lstlisting}

\subsection{Induktive Typen}

Die induktiven Typen entsprechen den frei erzeugten induktiven Mengen.
Im Zuge dessen stehen strukturelle Induktion und Rekursion bezüglich
solcher Typen zur Verfügung. Im Bezug auf die kategorielle Semantik
versteht sich ein induktiver Typ als \emph{initiale Algebra}, worauf ich
an dieser Stelle aber nicht weiter eingehen will.

Das Schlüsselwort \kw{Inductive} leitet die Definition eines neuen
induktiven Typen ein, die sich aus der Festlegung von
\emph{Konstruktorfunktionen} zusammensetzt. Kommt es hierbei zu keiner
Selbstbezüglichkeit, erhält man als Spezialfall ein Mittel zur Festlegung
einer Summe, auch Enumeration genannt, die der disjunkten Vereinigung
von Mengen entspricht.

Während die Konstruktorfunktionen der Einführung von Termen dienen,
steht eine Rekursorfunktion zur deren Beseitigung zur Verfügung.
Statt direkt auf den Rekursor zugreifen zu müssen, bietet die Sprache
darüber hinaus das Mittel des Musterabgleichs, der mit dem Schlüsselwort
\kw{match} eingeleitet wird.

Beispiel. Der Typ \code{N} der natürlichen Zahlen mit den beiden
Konstruktoren \code{zero} und \code{succ} wird eingeführt mit
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Inductive}` N := zero: N | succ: N -> N.
\end{lstlisting}
Hierbei ist \code{zero} eine Konstante, die man als Konstruktorfunktion
ohne Argumente deuten kann. Man kann die Signaturen alternativ auch in
der kurzen Form
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Inductive}` N := zero | succ (n: N).
\end{lstlisting}
notieren, -- die ausgelassenen Typangaben werden dabei abgeleitet.

Die rekursive Festlegung einer Funktion wird in der geläufigen Weise
notiert, wie Funktionen definiert werden, muss allerdings mit dem
Schlüsselwort \kw{Fixpoint} statt \kw{Definition} eingeleitet
werden. Der Compiler prüft, ob die Berechnungsvorschrift
einen strukturellen Abstieg zustande bringt, womit gemeint ist, dass
jeder rekursive Aufruf entsprechend der induktiven Struktur den Vorgänger
des aktuellen Arguments als Argument bekommt. Der Vorgänger wird hierbei
mit dem Musterabgleich in Erfahrung gebracht, was mit einer
Fallunterscheidung einhergeht. Existiert kein Vorgänger, liegt also ein
Basisfall vor, muss ein Rekursionsanfang stattfinden.

Die Prüfung schließt Konstruktionen aus, bei denen nicht erkennbar ist,
ob sie die Bedingungen des Rekursionssatzes erfüllen. Somit wird
abgesichert, dass jede Funktion wohldefiniert ist, bzw. jede Berechnung
terminiert, sich also nicht in einer endlosen Schleife verfängt.

Beispiel. Def. \ref{def:N-Addition} auf S. \pageref{def:N-Addition} wird
implementiert als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Fixpoint}` add (a b: N): N :=
  `\kw{match}` b `\kw{with}` zero => a | succ b => succ (add a b) `\kw{end}`.
\end{lstlisting}
Alternativ zum Musterabgleich kann die Funktion auch mit dem Rekursor
\code{N\_rec} festgelegt werden, der allerdings eine Funktion in einem
Argument liefert, nämlich dem, über das die Rekursion läuft. Ein
Hindernis entsteht dadurch aber nur scheinbar, weil wir die Konstruktion
über das erste Argument \code{a} parametrisieren können. Die Funktion
\code{add} liegt damit in geschönfinkelter Form vor, was aber zuvor
bereits der Fall war, weil dies per se so ist, sofern man nicht explizit
Paare oder Tupel ins Spiel bringt. Der Rekursor hat die Signatur
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
N_rec: `\kw{forall}` P: N -> Set, P zero ->
  (`\kw{forall}` n: N, P n -> P (succ n)) -> `\kw{forall}` n: N, P n.
\end{lstlisting}
Demnach bekommt \code{N\_rec} drei Argumente. Das erste Argument
\code{P} bestimmt den Typ der Werts in Abhängigkeit der natürlichen
Zahl, für uns konstant \code{N}. Das zweite Argument stellt den
Anfangswert dar, und das dritte kodiert die Rekursionsgleichung.
Das heißt, will man eine Funktion $f\colon N\to X$ rekursiv festlegen
gemäß
\[f(\mathrm{zero}) := x_0,\quad f(\mathrm{succ}(n)) := \varphi(n,f(n)),\]
hat man $f=N_\mathrm{rec}(P,x_0,\varphi)$ mit $P(n):=X$. Die Addition
erhalten wir damit als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Definition}` add (a: N): N -> N :=
  N_rec (`\kw{fun}` b => N) a (`\kw{fun}` b y => succ y).
\end{lstlisting}
Ich will noch ein weiteres Beispiel aufführen, bei dem die Konstruktion
durchsichtiger sein mag. Statt \code{N} benutzen wir nun den bereits
verfügbaren Typ \code{nat} für die natürlichen Zahlen $\N$, der die
Nomenklatur \code{O} statt \code{zero} und \code{S} statt \code{succ}
besitzt. Weiterhin steht nun die übliche mathematische Notation
einschließlich des Dezimalsystems zur Verfügung.

Die Fakultätsfunktion wird gemäß
\[f(0) := 1,\quad f(n+1) := (n+1)f(n)\]
rekursiv festgelegt. Wir haben also $f=\N_\mathrm{rec}(P,1,\varphi)$
mit $P(n):=\N$ und $\varphi(n,x)=(n+1)x$. Damit ergibt sich die
Implementierung
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Definition}` f: nat -> nat :=
  nat_rec (`\kw{fun}` n => nat) 1 (`\kw{fun}` n x => (n + 1)*x).
\end{lstlisting}
Dass dies völlig analog zum Musterabgleich ist, sieht man an
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Fixpoint}` f (n: nat): nat :=
  `\kw{match}` n `\kw{with}` O => 1 | S n => (n + 1)*f n `\kw{end}`.
\end{lstlisting}

\begin{figure}[t]
\begin{lstlisting}[%
caption={Beispiel zur strukturellen Induktion und Rekursion},%
label=lst:Liste, escapechar=`]
`\kw{Require}` `\kw{Import}` Arith.PeanoNat.
`\kw{Definition}` Symbol := nat.
`\kw{Inductive}` List := nil | cons (x: Symbol) (a: List).

`\kw{Fixpoint}` len (a: List): nat :=
  `\kw{match}` a `\kw{with}` nil => 0 | cons a0 a1 => len a1 + 1 `\kw{end}`.

`\kw{Fixpoint}` concat (a b: List): List :=
  `\kw{match}` a `\kw{with}` nil => b | cons a0 a1 => cons a0 (concat a1 b) `\kw{end}`.

`\kw{Theorem}` len_concat (a b: List):
  len (concat a b) = len a + len b.
`\kw{Proof}`.
  induction a as [| x a ih].
  * simpl. reflexivity.
  * simpl. rewrite ih. rewrite <- Nat.add_assoc.
    rewrite (Nat.add_comm _ 1). rewrite Nat.add_assoc. reflexivity.
`\kw{Qed}`.
\end{lstlisting}
\end{figure}

Das Beispiel zu der Liste von Symbolen, das wir ursprünglich in Abschnitt
\ref{sec:Strukturelle-Induktion} gerechnet haben, wird nochmals in
Listing \ref{lst:Liste} aufgeführt. Den Typ der Symbole kodieren wir hierbei
als Synonym zu den natürlichen Zahlen, um uns erst einmal nicht damit
auseinandersetzen zu müssen, wie denn ein Symbol beschaffen sei. Es ist
auch machbar, den Typ der Liste parametrisch über den Typ der Elemente
zu definieren. Bei dem, was wir zeigen wollen, spielt der Typ der Elemente
nämlich keine Rolle. Parametrisch über den Typ \code{T} lautet die
Festlegung
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Inductive}` List T := nil | cons (x: T) (a: List T).
\end{lstlisting}

\section{Taktiken}

Statt Terme zu schreiben, nutzt man lieber Taktiken. Sie bieten den
Vorteil, dass die Schlussregeln mit ihnen rückwärts angewendet werden
können. Man gibt dabei das zu beweisende Theorem als \emph{Ziel}\index{Ziel}
vor. Vermittels den Taktiken, die zu den Schlussregeln des natürlichen
Schließens gehören, kann das Ziel auf ein oder mehrere \emph{Unterziele}%
\index{Unterziele} zurückgeführt werden. Das geht bis zum Erreichen
von Grundsequenzen so weiter.

Mit $\Gamma:=[A\colon\mathrm{Prop},B\colon\mathrm{Prop}]$ gilt
\[\begin{prooftree}
        \infer0{\Gamma,g\colon\lnot B\vdash g\colon\lnot B}
          \infer0{\Gamma,f\colon A\to B\vdash f\colon A\to B}
          \infer0[exact $a$]{\Gamma,a\colon A\vdash a\colon A}
        \infer2[apply $f$]{\Gamma,f\colon A\to B, a\colon A\vdash f(a)\colon B}
      \infer2[apply $g$]{\Gamma, f\colon A\to B, g\colon\lnot B, a\colon A\vdash g(f(a))\colon\bot}
    \infer1[intro $a$]{\Gamma, f\colon A\to B, g\colon\lnot B\vdash a\mapsto g(f(a))\colon \lnot A}
  \infer1[intro $g$]{\Gamma, f\colon A\to B\vdash g\mapsto a\mapsto g(f(a))\colon \lnot B\to\lnot A}
\infer1[intro $f${\normalsize .}]{\Gamma\vdash f\mapsto g\mapsto a\mapsto g(f(a))\colon (A\to B)\to (\lnot B\to\lnot A)}
\end{prooftree}\]
Man beachte, dass der konstruierte Term $f\mapsto g\mapsto a\mapsto g(f(a))$ am Anfang noch
unbekannt ist. Bekannt sind im jeweiligen Schritt lediglich die zur
Verfügung stehenden Variablen und der Typ, dessen Term zu konstruieren
ist. Erst nachdem man sich rückwärts von der Wurzel aus zu den
Blättern hin durchgearbeitet hat, kann man den Weg zur Wurzel hin
zurücklaufen und dabei schrittweise den Terme konstruieren.
In der Praxis gibt man sich in der Regel zufrieden, bei den Blättern
angekommen zu sein. Der tatsächliche Verlauf sieht also so aus:
\[\begin{prooftree}
        \infer0{\Gamma,g\colon\lnot B\vdash g\colon\lnot B}
          \infer0{\Gamma,f\colon A\to B\vdash f\colon A\to B}
          \infer0[exact $a$]{\Gamma,a\colon A\vdash {?}\colon A}
        \infer2[apply $f$]{\Gamma,f\colon A\to B, a\colon A\vdash {?}\colon B}
      \infer2[apply $g$]{\Gamma, f\colon A\to B, g\colon\lnot B, a\colon A\vdash {?}\colon\bot}
    \infer1[intro $a$]{\Gamma, f\colon A\to B, g\colon\lnot B\vdash {?}\colon \lnot A}
  \infer1[intro $g$]{\Gamma, f\colon A\to B\vdash {?}\colon \lnot B\to\lnot A}
\infer1[intro $f$]{\Gamma\vdash {?}\colon (A\to B)\to (\lnot B\to\lnot A)}
\end{prooftree}\]
Der Quelltext hierzu:
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` contraposition (A B: Prop):
  (A -> B) -> (~B -> ~A).
`\kw{Proof.}`
  intro f. intro g. intro a.
  apply g. apply f. exact a.
`\kw{Qed.}`
\end{lstlisting}
Die Entwicklungsumgebung ermöglicht es hierbei, auf dem Verlauf der
Taktiken zu wandern. Zwischen den Schritten wird das aktuelle Ziel und
dessen Kontext gezeigt, so dass man die Übersicht darüber behält,
was zu beweisen verbleibt und welche Mittel dafür verfügbar sind.

Es ist üblich, verfügbare Aussagen, die als Annahmen gemacht
oder aus diesen abgeleitet wurden, als \emph{Hypothesen} zu bezeichnen
und deren Variablen bzw. Termbezeichnern diesbezüglich ein \code{h} oder
ein \code{H} voranzustellen. Fällt keine sinnvolle Benennung ein,
oder wäre diese zu umständlich, kann man lokale Hypothesen auch
einfach \code{h1}, \code{h2}, \code{h3} usw. nennen. Für den letzten
Beweis ginge beispielsweise

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` contraposition (A B: Prop):
  (A -> B) -> (~B -> ~A).
`\kw{Proof.}`
  intro hAB. intro hnB. intro hA.
  apply hnB. apply hAB. exact hA.
`\kw{Qed.}`
\end{lstlisting}
