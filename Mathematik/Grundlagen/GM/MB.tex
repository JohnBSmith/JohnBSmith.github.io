
\chapter{Maschinengestütztes Beweisen}

\section{Terme und Typen}

\subsection{Zur Aussagenlogik}

Der Einführung einer Subjunktion\index{Subjunktion} entspricht die
Einführung einer $\lambda$"=Abstraktion,\index{Abstraktion}%
\index{Lambda-Abstraktion} also einer anonymen Funktion.%
\index{anonyme Funktion} Der aus der Herleitung
\[\begin{prooftree}
    \infer0{A,B\vdash A}
  \infer1{A\vdash B\cond A}
\infer1{\vdash A\cond B\cond A}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
    \infer0{\Gamma, a\colon A, b\colon B\vdash a\colon A}
  \infer1{\Gamma, a\colon A\vdash (b\mapsto a)\colon B\to A}
\infer1{\Gamma\vdash a\mapsto (b\mapsto a)\colon A\to B\to A}
\end{prooftree}\]
mit $\Gamma:=[A\colon\mathrm{Prop}, B\colon\mathrm{Prop}]$ entstandene
Term wird zum Beispiel abgefasst als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` Beispiel1 (A B: Prop):
  A -> B -> A.
`\kw{Proof}`
  `\kw{fun}` a => `\kw{fun}` b => a.
\end{lstlisting}
Der Beseitigung der Subjunktion entspricht die Applikation einer
Funktion. Betrachten wir dazu die Herleitung
\[\begin{prooftree}
      \infer0{A\cond B\vdash A\cond B}
      \infer0{A\vdash A}
    \infer2{A,A\cond B\vdash B}
  \infer1{A\vdash (A\cond B)\cond B}
\infer1{\vdash A\cond (A\cond B)\cond B}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
      \infer0{\Gamma,f\colon A\to B\vdash f\colon A\to B}
      \infer0{\Gamma,a\colon A\vdash a\colon A}
    \infer2{\Gamma,a\colon A, f\colon A\to B\vdash f(a)\colon B}
  \infer1{\Gamma,a\colon A\vdash (f\mapsto f(a))\colon (A\to B)\to B}
\infer1{\Gamma\vdash (a\mapsto f\mapsto f(a))\colon A\to (A\to B)\to B}
\end{prooftree}\]
mit $\Gamma:=[A\colon\mathrm{Prop}, B\colon\mathrm{Prop}]$.
Der Beweis wird demnach implementiert als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` Beispiel2 (A B: Prop):
  A -> (A -> B) -> B.
`\kw{Proof}`
  `\kw{fun}` a => `\kw{fun}` f => f a.
\end{lstlisting}

\begin{table}
\begin{center}
\caption{Funktionen für die Konjunktion und die Disjunktion}
\label{tab:Funktionen-Konjunktion-Disjunktion}
\begin{tabular}{@{}cll@{}}
\toprule
\textbf{Junktor} & \textbf{Einführung} & \textbf{Beseitigung}\\
\midrule[\heavyrulewidth]
Konjunktion & $\code{conj}\,A\;B\colon A \to B \to A\land B$
& $\code{proj1}\;A\;B\colon A\land B\to A$\\
& & $\code{proj2}\;A\;B\colon A\land B\to B$\\
\midrule[\heavyrulewidth]
Disjunktion & $\code{or\_introl}\,A\;B\colon A\to A\lor B$
& $\code{or\_elim}\,A\;B\colon (A\to C)\to (A\to C)$\\
& $\code{or\_intror}\,A\;B\colon A\to B\lor A$
& $\phantom{\code{or\_elim}\,A\;B\colon}\to (A\lor B\to C)$\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\noindent
Tabelle \ref{tab:Funktionen-Konjunktion-Disjunktion} zeigt die Funktionen,
mit denen Terme für die Konjunktion und die Disjunktion konstruiert
werden können.\index{Konjunktion}\index{Disjunktion}

Ein kurzes Beispiel. Mit der Herleitung
\[\begin{prooftree}
    \hypo{\Gamma\vdash A\land B}
  \infer1{\Gamma\vdash B}
    \hypo{\Gamma\vdash A\land B}
  \infer1{\Gamma\vdash A}
\infer2{\Gamma\vdash B\land A}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
    \hypo{\Gamma\vdash h\colon A\land B}
  \infer1{\Gamma\vdash\code{proj2}(h)\colon B}
    \hypo{\Gamma\vdash h\colon A\land B}
  \infer1{\Gamma\vdash\code{proj1}(h)\colon A}
\infer2{\Gamma\vdash\code{conj} (\code{proj2}(h)) (\code{proj1}(h))\colon B\land A}
\end{prooftree}\]
kommt man bezüglich $\Gamma:=[h\colon A\land B]$ zum Term
\[(h\mapsto\code{conj} (\code{proj2}(h)) (\code{proj1}(h)))\colon A\land B\to B\land A.\]
Der Quelltext hierzu:

\noindent
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` conj_commutativity (A B: Prop):
  A /\ B -> B /\ A.
`\kw{Proof}`
  `\kw{fun}` h => conj (proj2 h) (proj1 h).
\end{lstlisting}
Dieser Beweis ist allerdings für \texttt{Prop} spezifisch. Für Typen
allgemeiner Art findet sich aber ein analoger Beweis. Der
Curry"=Howard"=Korrespondenz entsprechend betrifft dies die Produkttypen
$A\times B$, die \verb|prod A B| oder \verb|A*B| geschrieben werden. Die
zweite Schreibweise wird aber nur gestattet, wenn keine Zweideutigkeit
mit der Multiplikation von Zahlen besteht. Die Analoga zu
\texttt{proj1}, \texttt{proj2} und \texttt{conj} sind
\texttt{fst}, \texttt{scd} und \texttt{pair}, wobei dies für
first, second steht und man \verb|(x, y)| statt \verb|pair x y|
schreiben darf. Es ergibt sich also der folgende Quelltext:
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` prod_commutativity (A B: Type):
  A * B -> B * A.
`\kw{Proof}`
  `\kw{fun}` h => (snd h, fst h).
\end{lstlisting}
Statt die Projektionen zu nutzen, kann der Term auch via
Musterabgleich als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{fun}` h => `\kw{match}` h `\kw{with}` (a, b) => (b, a) `\kw{end}`
\end{lstlisting}
abgefasst werden, wobei hierfür zudem die Kurzschreibweise
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{fun}` '(a, b) => (b, a) `\textrm{bzw.}` `\kw{fun}` '(pair a b) => (pair b a)
\end{lstlisting}
existiert.

Für den Beweis von $A\lor B\cond B\lor A$ findet sich
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` disj_commutativity (A B: Prop):
  A \/ B -> B \/ A.
`\kw{Proof}`
  or_elim
    (`\kw{fun}` a => or_intror a)
    (`\kw{fun}` b => or_introl b).
\end{lstlisting}
Alternativ wird der Term via Musterabgleich abgefasst:
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{fun}` h => `\kw{match}` h `\kw{with}`
| or_introl a => or_intror a
| or_intror b => or_introl b
`\kw{end}`
\end{lstlisting}

\noindent
Die Negation $\lnot A$ wird als $A\cond\bot$ definiert, weshalb sie
unter die Regeln der Subjunktion fällt, und daher keine eigenen benötigt.
Die Syntax für $\bot$ ist \code{False}, und die für $\lnot A$ ist
\verb|~A|. Ein kurzes Beispiel. Zum Beweis von $A\cond\lnot\lnot A$
braucht man ja lediglich aus $A$ und $\lnot A$ einen Widerspruch
herstellen. Es liegt also ein $a\colon A$ und eine Funktion
$f\colon\lnot A$ bzw. $f\colon A\to\bot$ vor, woraus nur
noch $f(a)$ geformt werden braucht. Der Satz und dessen Beweisterm sind
demnach formalisiert als

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` double_negation_intro (A: Prop):
  A -> ~~A.
`\kw{Proof}`
  `\kw{fun}` a: A => `\kw{fun}` f: ~A => f a.
\end{lstlisting}

\noindent
Der Beweis der Umkehrung ist nicht möglich, insofern das System auf
intuitionistischer Logik basiert. Wir können die Beseitigung der
Doppelnegation allerdings axiomatisch voraussetzen via

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Axiom}` ax_dne: `\kw{forall}` (A: Prop), ~~A -> A.
\end{lstlisting}

\noindent
Zur pedantischen Schaffung von Klarheit gäbe es alternativ auch noch
die Möglichkeit, DNE in sämtlichen Sätzen, deren Beweis von DNE abhängt,
explizit als Prämisse aufzuführen. Zur Abkürzung kann man DNE dabei
verpacken mit der

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Definition}` DNE := `\kw{forall}` (A: Prop), ~~A -> A.
\end{lstlisting}

\noindent
Zum Beispiel gelingt der Beweis von ex falso quodlibet vermittels DNE als
\[\begin{prooftree}
    \infer0{\bot,\lnot A\vdash\bot}
  \infer1{\bot\vdash\lnot\lnot A}
\infer1[DNE]{\bot\vdash A}
\end{prooftree}
\;\rightsquigarrow\;\;
\begin{prooftree}
    \infer0{\Gamma,x\colon \bot,f\colon \lnot A\vdash x\colon \bot}
  \infer1{\Gamma,x\colon\bot\vdash (f\mapsto x)\colon \lnot\lnot A}
\infer1[DNE]{\Gamma,x\colon\bot\vdash \mathrm{dne}(A)(f\mapsto x)\colon A}
\end{prooftree}\]
Die diesbezügliche Implementierung ist

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` efq (dne: DNE) (A: Prop): False -> A.
`\kw{Proof}` `\kw{fun}` x: False => dne A (`\kw{fun}` f: ~A => x).
\end{lstlisting}

\noindent
Man kann EFQ aber auch ohne Weiteres erhalten, da das logische System
bereits ein intuitionistisches ist. Später werden wir sehen, dass
$\bot$ als leerer induktiver Typ gedeutet werden darf. Infolge erhält man
einen Beweis von EFQ vermittels leerem Musterabgleich, so sonderbar das
auch erscheinen mag.

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` efq (A: Prop): False -> A.
`\kw{Proof}` `\kw{fun}` x: False => `\kw{match}` x `\kw{with}` `\kw{end}`.
\end{lstlisting}

\subsection{Zur Prädikatenlogik}

Der \strong{Allquantifizierung} $\forall x\in X\colon A(x)$ entspricht
$\prod_{x\colon X} A(x)$, ein Typ abhängiger Funktionen. Einen Bezug auf
diese Beziehung herstellend, bekam der Typ die Syntax
\code{\kw{forall} x: X, A x}. Ein Beweis der Allaussage der ist also eine
Funktion $f$, die jedem Individuum $x$ vom Typ $X$ einen Wert $f(x)$ vom
Typ $A(x)$ zuordnet, womit $A(x)$ zu jedem $x$ bewohnt sein muss.
Einfaches Beispiel. Gezeigt werden soll
\[A\land (\forall x\in X\colon B(x))\cond\forall x\in X\colon A\land B(x)).\]
Konstruiert werden muss eine Funktion, die jedem $x\colon X$ einen
Wert vom Typ $A\times B(x)$ zuordnet, unter der Annahme, es sei ein Paar $(a,f)$
mit $a\colon A$ und $f(x)\colon B(x)$ zu jedem $x\colon X$ verfügbar.
Dies schafft
\[\textstyle (a,f)\colon A\times\prod_{x\in X} B(x)\mapsto
x\colon X\mapsto (a, f(x)).\]
Die Implementierung ist
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` const_factor (X A: Type) (B: X -> Type):
  A * (forall x: X, B x) -> forall x: X, A * B x.
`\kw{Proof}`
  `\kw{fun}` '(a, f) => `\kw{fun}` x => (a, f x).
\end{lstlisting}
Für Aussagen vom Typ \code{Prop} braucht man aber die Modifizierung
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` const_factor (X: Type) (A: Prop) (B: X -> Prop):
  A /\ (forall x: X, B x) -> forall x: X, A /\ B x.
`\kw{Proof}`
  `\kw{fun}` '(conj a f) => `\kw{fun}` x => conj a (f x).
\end{lstlisting}

\subsection{Induktive Typen}

Die induktiven Typen entsprechen den frei erzeugten induktiven Mengen.
Im Zuge dessen stehen strukturelle Induktion und Rekursion bezüglich
solcher Typen zur Verfügung. Im Bezug auf die kategorielle Semantik
versteht sich ein induktiver Typ als \emph{initiale Algebra}, worauf ich
an dieser Stelle aber nicht weiter eingehen will.

Das Schlüsselwort \kw{Inductive} leitet die Definition eines neuen
induktiven Typen ein, die sich aus der Festlegung von
\emph{Konstruktorfunktionen} zusammensetzt. Kommt es hierbei zu keiner
Selbstbezüglichkeit, erhält man als Spezialfall ein Mittel zur Festlegung
einer Summe, auch Enumeration genannt, die der disjunkten Vereinigung
von Mengen entspricht.

Während die Konstruktorfunktionen der Einführung von Termen dienen,
steht eine Rekursorfunktion zur deren Beseitigung zur Verfügung.
Statt direkt auf den Rekursor zugreifen zu müssen, bietet die Sprache
darüber hinaus das Mittel des Musterabgleichs, der mit dem Schlüsselwort
\kw{match} eingeleitet wird.

Beispiel. Der Typ \code{N} der natürlichen Zahlen mit den beiden
Konstruktoren \code{zero} und \code{succ} wird eingeführt mit
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Inductive}` N := zero: N | succ: N -> N.
\end{lstlisting}
Hierbei ist \code{zero} eine Konstante, die man als Konstruktorfunktion
ohne Argumente deuten kann. Man kann die Signaturen alternativ auch in
der kurzen Form
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Inductive}` N := zero | succ (n: N).
\end{lstlisting}
notieren, -- die ausgelassenen Typangaben werden dabei abgeleitet.

Die rekursive Festlegung einer Funktion wird in der geläufigen Weise
notiert, wie Funktionen definiert werden, muss allerdings mit dem
Schlüsselwort \kw{Fixpoint} statt \kw{Definition} eingeleitet
werden. Der Compiler prüft, ob die Berechnungsvorschrift
einen strukturellen Abstieg zustande bringt, womit gemeint ist, dass
jeder rekursive Aufruf entsprechend der induktiven Struktur den Vorgänger
des aktuellen Arguments als Argument bekommt. Der Vorgänger wird hierbei
mit dem Musterabgleich in Erfahrung gebracht, was mit einer
Fallunterscheidung einhergeht. Existiert kein Vorgänger, liegt also ein
Basisfall vor, muss ein Rekursionsanfang stattfinden.

Die Prüfung schließt Konstruktionen aus, bei denen nicht erkennbar ist,
ob sie die Bedingungen des Rekursionssatzes erfüllen. Somit wird
abgesichert, dass jede Funktion wohldefiniert ist, bzw. jede Berechnung
terminiert, sich also nicht in einer endlosen Schleife verfängt.

Beispiel. Def. \ref{def:N-Addition} auf S. \pageref{def:N-Addition} wird
implementiert als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Fixpoint}` add (a b: N): N :=
  `\kw{match}` b `\kw{with}` zero => a | succ b => succ (add a b) `\kw{end}`.
\end{lstlisting}
Alternativ zum Musterabgleich kann die Funktion auch mit dem Rekursor
\code{N\_rec} festgelegt werden, der allerdings eine Funktion in einem
Argument liefert, nämlich dem, über das die Rekursion läuft. Ein
Hindernis entsteht dadurch aber nur scheinbar, weil wir die Konstruktion
über das erste Argument \code{a} parametrisieren können. Die Funktion
\code{add} liegt damit in geschönfinkelter Form vor, was aber zuvor
bereits der Fall war, weil dies per se so ist, sofern man nicht explizit
Paare oder Tupel ins Spiel bringt. Der Rekursor hat die Signatur
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
N_rec: `\kw{forall}` P: N -> Set, P zero ->
  (`\kw{forall}` n: N, P n -> P (succ n)) -> `\kw{forall}` n: N, P n.
\end{lstlisting}
Demnach bekommt \code{N\_rec} drei Argumente. Das erste Argument
\code{P} bestimmt den Typ der Werts in Abhängigkeit der natürlichen
Zahl, für uns konstant \code{N}. Das zweite Argument stellt den
Anfangswert dar, und das dritte kodiert die Rekursionsgleichung.
Das heißt, will man eine Funktion $f\colon N\to X$ rekursiv festlegen
gemäß
\[f(\mathrm{zero}) := x_0,\quad f(\mathrm{succ}(n)) := \varphi(n,f(n)),\]
hat man $f=N_\mathrm{rec}(P,x_0,\varphi)$ mit $P(n):=X$. Die Addition
erhalten wir damit als
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Definition}` add (a: N): N -> N :=
  N_rec (`\kw{fun}` b => N) a (`\kw{fun}` b y => succ y).
\end{lstlisting}
Ich will noch ein weiteres Beispiel aufführen, bei dem die Konstruktion
durchsichtiger sein mag. Statt \code{N} benutzen wir nun den bereits
verfügbaren Typ \code{nat} für die natürlichen Zahlen $\N$, der die
Nomenklatur \code{O} statt \code{zero} und \code{S} statt \code{succ}
besitzt. Weiterhin steht nun die übliche mathematische Notation
einschließlich des Dezimalsystems zur Verfügung.

Die Fakultätsfunktion wird gemäß
\[f(0) := 1,\quad f(n+1) := (n+1)f(n)\]
rekursiv festgelegt. Wir haben also $f=\N_\mathrm{rec}(P,1,\varphi)$
mit $P(n):=\N$ und $\varphi(n,x)=(n+1)x$. Damit ergibt sich die
Implementierung
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Definition}` f: nat -> nat :=
  nat_rec (`\kw{fun}` n => nat) 1 (`\kw{fun}` n x => (n + 1)*x).
\end{lstlisting}
Dass dies völlig analog zum Musterabgleich ist, sieht man an
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Fixpoint}` f (n: nat): nat :=
  `\kw{match}` n `\kw{with}` O => 1 | S n => (n + 1)*f n `\kw{end}`.
\end{lstlisting}

\noindent
Zur Vorführung, wie die Implementierung von Induktionsbeweisen ausschaut,
will ich den kurzen Beweis von Satz \ref{nat-zero} nutzen.

Es gibt Berechnungsregeln zur automatischen Vereinfachung von Ausdrücken.
Dies verhält sich analog zur Auswertung von Termen, die auf dem Papier
oder im Quelltext eines Programms stehen. Allerdings resultiert die
Vereinfachung nicht unbedingt in einem Wert, weil in Ausdrücken auch
Variablen vorkommen dürfen, deren Wert unbekannt gelassen wird.

Betrachten wir \code{add a zero}. Dies vereinfacht sich entsprechend
der Definition zu \code{a}, was auch ginge, wenn statt der Variable
\code{a} irgendein Term stehen würde. Insofern der Wert von \code{a}
unbekannt verbleibt, endet die Vereinfachung hiermit.

Die Gleichung \code{a = add a zero} vereinfacht sich mithin zu \code{a = a},
denn Vereinfachungen finden auch innerhalb von Ausdrücken statt.
Zum Beweis dieser Aussage genügt daher der Beweis von \code{a = a},
der aber direkt aus Reflexivität der Gleichheit hervorgeht, die mit
\code{eq\_refl} benannt wird.

\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem zero_neutral_right (a: N): a = add a zero.
Proof eq_refl a.
\end{lstlisting}

\noindent
Bei \code{add zero a} ist jedoch keine Vereinfachung möglich. Hier müssen
wir eine Induktion über \code{a} durchführen. Aus der genaueren Betrachtung
des Beweises von Satz \ref{nat-zero} wird sichtbar, dass darin eine Termersetzung
stattfindet. Wir benötigen als Hilfsmittel das Ersetzungsschema zur
Gleichheit, das nun, unter veränderter Reihenfolge, als \code{eq\_ind}
zur Verfügung steht, dazu später mehr. Wir bringen es kurz in die
gewohnte Reihenfolge:

\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem eq_subst (A: Type) (P: A -> Prop):
  forall x y: A, x = y -> P x -> P y.
Proof fun x y h hx => eq_ind x P hx y h.
\end{lstlisting}

\noindent
Im Weiteren ist das Induktionsprinzip verfügbar als

\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
N_ind: forall P: N -> Prop, P zero ->
  (forall n: N, P n -> P (succ n)) -> forall n: N, P n.
\end{lstlisting}

\noindent
Es liegt nun alles Rüstzeug vor, was wir zur Implementierung des Beweises
benötigen. Die Induktionsannahme sei darin mit \code{ih} für \emph{induction
hypothesis} bezeichnet.

\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem zero_neutral_left (a: N): a = add zero a.
Proof N_ind (fun a => a = add zero a)
  (eq_refl zero)
  (fun a ih => eq_subst N (fun n => succ a = succ n)
    a (add zero a) ih (eq_refl (succ a))) a.
\end{lstlisting}

\noindent
An dieser Stelle muss man sich ernstlich fragen, ob ein Beweis immer
in so einer verklausulierten Weise kodiert werden muss, was mit zunehmender
Länge des Beweises in mehr oder weniger schwer durchsichtigen Termsalat
mündet. Zwar sind wie bei Programmiersprachen Hilfsbezeichner für
Teilterme einführbar, die entsprechend für Teilbeweise stehen. Es verbleibt
allerdings das Problem, dass die Prüfung des Beweises erst nach dessen
Vervollständigung möglich ist. Zur Auflösung dieser Problematik stehen
\emph{Taktiken} zur Verfügung, mit denen wir uns bald eingehend
beschäftigen wollen. Sie führen Ziele gemäß den Schlussregeln auf
Unterziele zurück, wonach der Aufbau von Beweisen rückwärts stattfindet.
Der gerade geführte Beweis bekommt beispielsweise die Gestalt:
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Theorem zero_neutral_left (a: N):
  a = add zero a.
Proof.
  induction a as [| a ih].
  * simpl. reflexivity.
  * simpl. rewrite <- ih. reflexivity.
Qed.
\end{lstlisting}
Im Beweis kommen die Taktiken \code{induction}, \code{simpl}, \code{rewrite}
und \code{reflexivity} vor. Es führt \code{simpl} für \emph{simplify}
eine Vereinfachung durch, und \code{rewrite} nimmt Ersetzungen gemäß
\code{eq\_subst} vor. Erwartungsgemäß steht \code{induction} für die
vollständige Induktion mittels \code{N\_ind} und \code{reflexivity} für
die Anwendung von \code{eq\_refl}.

\begin{figure}[t]
\begin{lstlisting}[%
caption={Beispiel zur strukturellen Induktion und Rekursion},%
label=lst:Liste, escapechar=`]
`\kw{Require}` `\kw{Import}` Arith.PeanoNat.
`\kw{Definition}` Symbol := nat.
`\kw{Inductive}` List := nil | cons (x: Symbol) (a: List).

`\kw{Fixpoint}` len (a: List): nat :=
  `\kw{match}` a `\kw{with}` nil => 0 | cons a0 a1 => len a1 + 1 `\kw{end}`.

`\kw{Fixpoint}` concat (a b: List): List :=
  `\kw{match}` a `\kw{with}` nil => b | cons a0 a1 => cons a0 (concat a1 b) `\kw{end}`.

`\kw{Theorem}` len_concat (a b: List):
  len (concat a b) = len a + len b.
`\kw{Proof}`.
  induction a as [| x a ih].
  * simpl. reflexivity.
  * simpl. rewrite ih. rewrite <- Nat.add_assoc.
    rewrite (Nat.add_comm _ 1). rewrite Nat.add_assoc. reflexivity.
`\kw{Qed}`.
\end{lstlisting}
\end{figure}

Das Beispiel zu der Liste von Symbolen, das wir ursprünglich in Abschnitt
\ref{sec:Strukturelle-Induktion} gerechnet haben, wird nochmals in
Listing \ref{lst:Liste} aufgeführt. Den Typ der Symbole kodieren wir hierbei
als Synonym zu den natürlichen Zahlen, um uns erst einmal nicht damit
auseinandersetzen zu müssen, wie denn ein Symbol beschaffen sei. Es ist
auch machbar, den Typ der Liste parametrisch über den Typ der Elemente
zu definieren. Bei dem, was wir zeigen wollen, spielt der Typ der Elemente
nämlich keine Rolle. Parametrisch über den Typ \code{T} lautet die
Festlegung
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Inductive}` List T := nil | cons (x: T) (a: List T).
\end{lstlisting}

\section{Taktiken}

Statt Terme zu schreiben, nutzt man lieber Taktiken. Sie bieten den
Vorteil, dass die Schlussregeln mit ihnen rückwärts angewendet werden
können. Man gibt dabei das zu beweisende Theorem als \emph{Ziel}\index{Ziel}
vor. Vermittels den Taktiken, die zu den Schlussregeln des natürlichen
Schließens gehören, kann das Ziel auf ein oder mehrere \emph{Unterziele}%
\index{Unterziele} zurückgeführt werden. Das geht bis zum Erreichen
von Grundsequenzen so weiter.

Mit $\Gamma:=[A\colon\mathrm{Prop},B\colon\mathrm{Prop}]$ gilt
\[\begin{prooftree}
        \infer0{\Gamma,g\colon\lnot B\vdash g\colon\lnot B}
          \infer0{\Gamma,f\colon A\to B\vdash f\colon A\to B}
          \infer0[exact $a$]{\Gamma,a\colon A\vdash a\colon A}
        \infer2[apply $f$]{\Gamma,f\colon A\to B, a\colon A\vdash f(a)\colon B}
      \infer2[apply $g$]{\Gamma, f\colon A\to B, g\colon\lnot B, a\colon A\vdash g(f(a))\colon\bot}
    \infer1[intro $a$]{\Gamma, f\colon A\to B, g\colon\lnot B\vdash a\mapsto g(f(a))\colon \lnot A}
  \infer1[intro $g$]{\Gamma, f\colon A\to B\vdash g\mapsto a\mapsto g(f(a))\colon \lnot B\to\lnot A}
\infer1[intro $f${\normalsize .}]{\Gamma\vdash f\mapsto g\mapsto a\mapsto g(f(a))\colon (A\to B)\to (\lnot B\to\lnot A)}
\end{prooftree}\]
Man beachte, dass der konstruierte Term $f\mapsto g\mapsto a\mapsto g(f(a))$ am Anfang noch
unbekannt ist. Bekannt sind im jeweiligen Schritt lediglich die zur
Verfügung stehenden Variablen und der Typ, dessen Term zu konstruieren
ist. Erst nachdem man sich rückwärts von der Wurzel aus zu den
Blättern hin durchgearbeitet hat, kann man den Weg zur Wurzel hin
zurücklaufen und dabei schrittweise den Terme konstruieren.
In der Praxis gibt man sich in der Regel zufrieden, bei den Blättern
angekommen zu sein. Der tatsächliche Verlauf sieht also so aus:
\[\begin{prooftree}
        \infer0{\Gamma,g\colon\lnot B\vdash g\colon\lnot B}
          \infer0{\Gamma,f\colon A\to B\vdash f\colon A\to B}
          \infer0[exact $a$]{\Gamma,a\colon A\vdash {?}\colon A}
        \infer2[apply $f$]{\Gamma,f\colon A\to B, a\colon A\vdash {?}\colon B}
      \infer2[apply $g$]{\Gamma, f\colon A\to B, g\colon\lnot B, a\colon A\vdash {?}\colon\bot}
    \infer1[intro $a$]{\Gamma, f\colon A\to B, g\colon\lnot B\vdash {?}\colon \lnot A}
  \infer1[intro $g$]{\Gamma, f\colon A\to B\vdash {?}\colon \lnot B\to\lnot A}
\infer1[intro $f$]{\Gamma\vdash {?}\colon (A\to B)\to (\lnot B\to\lnot A)}
\end{prooftree}\]
Der Quelltext hierzu:
\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` contraposition (A B: Prop):
  (A -> B) -> (~B -> ~A).
`\kw{Proof.}`
  intro f. intro g. intro a.
  apply g. apply f. exact a.
`\kw{Qed.}`
\end{lstlisting}
Die Entwicklungsumgebung ermöglicht es hierbei, auf dem Verlauf der
Taktiken zu wandern. Zwischen den Schritten wird das aktuelle Ziel und
dessen Kontext gezeigt, so dass man die Übersicht darüber behält,
was zu beweisen verbleibt und welche Mittel dafür verfügbar sind.

Es ist üblich, verfügbare Aussagen, die als Annahmen gemacht
oder aus diesen abgeleitet wurden, als \emph{Hypothesen} zu bezeichnen
und deren Variablen bzw. Termbezeichnern diesbezüglich ein \code{h} oder
ein \code{H} voranzustellen. Fällt keine sinnvolle Benennung ein,
oder wäre diese zu umständlich, kann man lokale Hypothesen auch
einfach \code{h1}, \code{h2}, \code{h3} usw. nennen. Für den letzten
Beweis ginge beispielsweise

\begin{lstlisting}[escapechar=`, xleftmargin=\mathindent]
`\kw{Theorem}` contraposition (A B: Prop):
  (A -> B) -> (~B -> ~A).
`\kw{Proof.}`
  intro hAB. intro hnB. intro hA.
  apply hnB. apply hAB. exact hA.
`\kw{Qed.}`
\end{lstlisting}

\newpage
\section{Rückkehr zum Anfang}

\subsection{Pedantische Erklärung der Aussagenlogik}

Mit dem Verständnis der essentiellen Grundlagen des maschinengestützten
Beweisens wäre es an der Zeit, einmal eine umfänglichere Argumentation zu
formalisieren. Statt zu den Grundbegriffen irgendeiner beliebigen Theorie
will ich zurück zur Aussagenlogik und ihrer Semantik kommen. Mit der
Implementierung des natürlichen Schließens gewinnen wir nämlich ein
verlässlicheres Verständnis der logischen Grundlagen, frei von potentiell
vorhandenen Ungenauigkeiten, Flüchtigkeitsfehlern oder Fehldeutungen.

Zunächst legen wir die aussagenlogische Sprache mit dem Typ der Formeln
als induktive Struktur fest. Vermittels der Konstruktoren wird direkt ein
abstrakter Syntaxbaum kodiert, so dass wir keinen Parser betrachten brauchen,
dessen weitläufige Konstruktion uns vom Wesentlichen ablenken würde.
Weiterhin legen wir $\lnot A$ und $A\bicond B$
als Abkürzungen für $A\cond\bot$ und $(A\cond B)\land (B\cond A)$ fest,
womit sich die Induktion über den Formelaufbau verkürzt und die Schlussregeln
für diese Junktoren entfallen dürfen. Die aussagenlogischen Variablen
nummerieren wir kurzum mit den natürlichen Zahlen, so dass wir keine
Zeichenketten betrachten brauchen. Listing \ref{lst:Aussagenlogik}
zeigt die Implementierung.

Als nächstes die klassische Semantik. Wir könnten für Wahrheitswerte
pauschal den Typ \code{Prop} vorsehen; dies wäre so auch durchführbar, wie
der Leser ausprobieren mag. Allerdings wird dadurch der Wahrheitsbegriff
mit dem der Metalogik vermischt. Dies wird gut daran erkennbar, dass die
Metalogik als Typentheorie eine intuitionistische ist. Wir müssten
den Satz vom ausgeschlossenen Dritten holzschnittartig als Axiom hinzufügen,
um aus ihr eine klassische zu machen. Gerade für die Beweistheorie wird
eine solche unnötige Verwässerung als problematisch angesehen. Außerdem lassen
sich Terme vom Typ \code{Prop} nicht ausrechnen. Man legt daher für die
Wahrheitswerte eine Menge $\B$ fest, deren zwei Elemente als die beiden
Wahrheitswerte gedeutet werden. Wie diese beiden Elemente lauten, ist
an sich unwichtig, wir können zum Beispiel wie zuvor $\B:=\{0,1\}$ oder auch
$\B:=\{\mathrm F,\mathrm T\}$ haben. Mit dem Präludium der Standardbibliothek
liegt $\B$ bereits als Typ \code{bool} mit den Werten \code{false}
und \code{true} vor, genauer als
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent]
Inductive bool: Set := true: bool | false: bool.
\end{lstlisting}
Da wir die aussagenlogischen Variablen mit den natürlichen Zahlen abzählen,
können wir eine Interpretation als Funktion $I\colon\N\to\B$ sehen.
Die Erfüllung $I\models A$ notieren wir als \code{sat I A} für
\emph{satisfies}. Sie wird getreu Def. \ref{def:sat} rekursiv über den
Formelaufbau festgelegt, siehe Listing \ref{lst:Aussagenlogik}.

\begin{figure}[t]
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent, escapechar=`,
label=lst:Aussagenlogik, caption={Die aussagenlogische Sprache und ihre
klassische Semantik}]
Inductive Formula: Set :=
| var: nat -> Formula
| falsum: Formula
| conj: Formula -> Formula -> Formula
| disj: Formula -> Formula -> Formula
| subj: Formula -> Formula -> Formula.

Definition neg A := subj A falsum.
Definition bij A B := conj (subj A B) (subj B A).

Fixpoint sat (I: nat -> bool) (A: Formula): bool :=
  match A with
  | var a => I a
  | falsum => false
  | conj A B => andb (sat I A) (sat I B)
  | disj A B => orb (sat I A) (sat I B)
  | subj A B => orb (negb (sat I A)) (sat I B)
  end.

Definition sat_all (I: nat -> bool) (`Γ`: Ensemble Formula) :=
  forall A, In Formula `Γ` A -> sat I A = true.

Definition valid `Γ` A: Prop :=
  forall (I: nat -> bool), sat_all I `Γ` -> sat I A = true.
\end{lstlisting}
\end{figure}

Nun zur logischen Folgerung. Weil im Kalkül des natürlichen Schließens
lediglich endliche Ansammlungen von Formeln auftreten, könnten wir uns
auf endliche Listen beschränken. Ich will die logische Folgerung aber
sogleich für allgemeine Mengen definieren,
um innerhalb der üblichen Terminologie zu bleiben. Dies zieht nach
sich, dass die Erfüllung $I\models\Gamma$ einer Formelmenge $\Gamma$ aufgrund
deren potenzieller Unendlichkeit, und damit Unberechenbarkeit, nicht
mehr Werte in \code{bool} annehmen kann, weshalb sie als metasprachliche
Aussage vom Typ \code{Prop} kodiert werden muss, siehe
\code{sat\_all I Γ} in Listing \ref{lst:Aussagenlogik}.
Die logische Folgerung $\Gamma\models A$ wird daraufhin getreu
Def. \ref{def:valid} mit der Bezeichnung \code{valid Γ A} festgelegt.

Um die weiteren Ausführungen nicht übermäßig weitläufig werden zu lassen,
betrachten wir das kleine Fragment des natürlichen Schließens, das lediglich
aus der Einführung von Grundsequenzen und der Beseitigungsregel der
Konjunktion besteht. Die Regeln werden als die Konstruktoren des Typs
\code{Prf Γ A} kodiert, der als Typ der Beweise der Sequenz
$\Gamma\vdash A$ in Erscheinung treten soll, siehe Listing \ref{lst:KdnS}.
Die Ableitbarkeit \code{provable} wird getreu Def. \ref{def:Ableitbarkeit}
festgelegt. Als Hilfsmittel benötigen wir daher noch die Funktion
\code{as\_set}, die eine endliche Liste von Formeln in eine Menge umwandelt.

\begin{figure}[t]
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent, escapechar=`,
label=lst:KdnS, caption={Fragment des natürliches Schließens und Ableitbarkeit}]
Inductive Formulas: Set :=
| nil: Formulas
| cons: Formulas -> Formula -> Formulas.

Inductive Prf: Formulas -> Formula -> Set :=
| basic_sequent A: Prf (cons nil A) A
| conj_eliml `Γ` A B: Prf `Γ` (conj A B) -> Prf `Γ` A.

Fixpoint as_set (`Γ`: Formulas): Ensemble Formula :=
  match `Γ` with
  | nil => Empty_set Formula
  | cons `Γ` A => Add Formula (as_set `Γ`) A
  end.

Definition provable `Γ` A: Prop :=
  exists `Γ`0, Included Formula (as_set `Γ`0) `Γ` /\
    exists p: Prf `Γ`0 A, True.
\end{lstlisting}
\end{figure}

Nun verbleibt die Korrektheit des Fragments zu bestätigen. Drei
Hilfssätze zerlegen dies in kleine Schritte, siehe Listing
\ref{lst:Korrektheit-KdnS}. Zunächst wird die Gültigkeit der
Beseitigungsregel zur Konjunktion bestätigt,
also dass $\Gamma\models A$ aus $\Gamma\models A\land B$ folgt. Daraufhin
zeigt das Lemma zur Korrektheit auf, dass $\Gamma\models A$ aus einem
vorliegenden Beweis $p$ der Sequenz $\Gamma\vdash A$ folgt. Dies ist
der wesentliche Teil der Argumentation, der vermittels struktureller
Induktion über den Aufbau von $p$ geführt wird. Das Lemma zur
Erfüllung von Mengen bestätigt noch kurz, dass $I\models\Gamma$
aus $\Gamma\subseteq\Delta$ und $I\models\Delta$ folgt. Schließlich
kommen die Hilfssätze im Hauptbeweis zur Anwendung.

\begin{figure}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent, escapechar=`,
label=lst:Korrektheit-KdnS, caption={Korrektheit des natürliches Schließens}]
Lemma conj_eliml_is_valid `Γ` A B:
  valid `Γ` (conj A B) -> valid `Γ` A.
Proof.
  intro h. unfold valid. intro I. intro hI.
  unfold valid in h. assert (h := h I hI). clear hI.
  simpl in h. apply andb_prop in h. exact (proj1 h).
Qed.

Lemma soundness_lemma `Γ` A:
  (exists p: Prf `Γ` A, True) -> valid (as_set `Γ`) A.
Proof.
  intro h. destruct h as (p, _).
  induction p as [| `Γ` A B p ih].
  * unfold valid. intros I hI. unfold sat_all in hI.
    apply hI. simpl. unfold Add.
    apply Union_intror. apply In_singleton.
  * exact (conj_eliml_is_valid (as_set `Γ`) A B ih).
Qed.

Lemma sat_set_lemma I `Γ` `Δ`:
  Included Formula `Γ` `Δ` -> (sat_all I `Δ`) -> (sat_all I `Γ`).
Proof.
  intros h hI. unfold sat_all. intros A hA.
  unfold sat_all in hI. apply hI. apply h. exact hA.
Qed.

Theorem natural_deduction_is_sound `Γ` A:
  provable `Γ` A -> valid `Γ` A.
Proof.
  intro h. unfold provable in h.
  destruct h as (`Γ`0, (h0, (p, _))).
  assert (h_valid: valid (as_set `Γ`0) A).
  { apply soundness_lemma. exists p. trivial. }
  unfold valid. intros I hI. apply h_valid.
  exact (sat_set_lemma I (as_set `Γ`0) `Γ` h0 hI).
Qed.
\end{lstlisting}
\end{figure}

\subsection{Ein System der axiomatischen Mengenlehre}

Der Beweisassistent schafft bereits die Mittel zur Klärung logischer
Gesetzmäßigkeiten. Vermittels induktiver Typen gelingt außerdem die
Konstruktion mathematischer Strukturen in ergonomischer Art und Weise,
was die Darlegung mathematischer Theorien auf typentheoretischer Basis
ermöglicht. Dienlich ist dieser Ansatz auch zum maschinengestützten
Verifizieren von Computerprogrammen. Am Anfang wurde allerdings die
Mengenlehre als Fundament für die mathematischen Grundlagen beschrieben.
Deshalb wollen wir nochmals zurück zur Mengenlehre kommen, auch um sie
besser mit der Typentheorie vergleichen zu können.

Zunächst einmal sollte die Mengenlehre reichhaltig genug sein, dass
alle mathematischen Objekte und Sachverhalte ohne Umwege in ihr
ausgedrückt werden können. Die reine ZFC erweist sich dabei als zu
minimalistisch, was ihre praktische Handhabung erschwert. So fehlt in ihr
sogar ein Konstantensymbol für die leere Menge. Es besteht diesbezüglich
Bedarf an Erweiterungen durch Definition, die es ermöglichen,
Konstanten und Mengenoperationen auf gewohnte Art und Weise zu nutzen.
Weiterhin erscheint es uns als wünschenswert, über Klassen sprechen
zu können. In Bezug auf diese Anforderungen erscheinen die Mengenlehren
NBG, MK oder auch die Tarski"=Grothendieck"=Mengenlehre als besonders
dienlich. Im Weiteren wird eine Implementierung der MK"=Mengenlehre nach
der in \cite{Kelly} und \cite{Tianyu-Sun} ausgeführten Axiomatik
vorgenommen, weil diese annehmlich kurz gefasst ist, also ohne
umständliche technische Erklärungen auskommt.

Man kann auf die im vorherigen Abschnitt beschriebene Art das gesamte
formale System konstruieren, das aus der Logik erster Stufe und dem
Axiomensystem der Mengenlehre besteht; geläufig ist diese Methodik
als \emph{tiefe Einbettung}. Hiermit wäre es möglich, innerhalb der
Typentheorie, die diesbezüglich die Rolle der Metalogik einnimmt,
Aussagen über das System zu machen. Da dies aber recht umständlich
ist und wir mehr an der pragmatischen Anwendung interessiert sind, wollen
wir das Axiomensystem direkt in der bereits zur Verfügung stehenden Logik
höherer Stufe abfassen, was als \emph{flache Einbettung} bezeichnet wird.
Man muss hierbei selbst darauf acht geben, allenfalls Quantifizierungen
über Prädikate zu nutzen, wenn sie einem Schema in der Logik erster Stufe
entsprechen.

Ich will darauf hinweisen, dass wir die Prädikate der Logik und die
Relationen der Mengenlehre unbedingt auseinanderhalten müssen. Im Axiom
\code{comp} zum Schema der Klassenkomprehension, siehe Listing
\ref{lst:MK-Axiome}, taucht bspw. eine Allquantifizierung über eine
Prädikatvariable auf, für die bei der Spezialisierung eine beliebige
Formel eingesetzt werden darf. Eine Relation innerhalb der Mengenlehre
ist dagegen eine Menge bzw. Klasse, also ein Objekt des Diskursuniversums.
Ein Beispiel, an dem der Zwiespalt in dramatischer Weise ersichtlich wird,
bietet der dedekindsche Rekursionssatz. Dieser spricht über die Existenz
einer Funktion, verlangt also bereits zu seiner Formulierung eine Logik
mindestens zweiter Stufe. Trotzdem ist der Satz problemlos in der Mengenlehre
in Logik erster Stufe fassbar, insofern hierbei über die Existenz einer
Funktion in Form einer Menge gesprochen wird. Das ist ein motivierendes
Beispiel für die Idee, dass die Mengenlehre in gewisser Weise eine Logik
höherer Stufe innerhalb der Logik erster Stufe beschreibt.

Wir legen zunächst drei Parameter fest, siehe Listing
\ref{lst:MK-Definitionen}. Mit \code{Class} bezeichnen wir den Typ der
Klassen; dieser unterscheidet sich von der Allklasse, die wir im Weiteren
via Komprehension definieren. Mit \code{In} bezeichnen wir das zweistellige
Prädikat $\in$, führen für \code{In x A} aber sogleich die übliche Notation
$x\in A$ ein. Die Operation \code{Comp} bezeichnet die Komprehension, die
zu einem einstelligen Prädikat die Klasse der Mengen beschreibt, die das
Prädikat erfüllen.

Als nächstes folgen einige Definitionen. Das einstellige Prädikat
\code{set} prüft, ob eine Klasse eine Menge ist. Zu erwähnen wäre,
dass $\forall x\colon A(x)$ bzw. $\exists x\colon A(x)$ gerne als
Kurzschreibweise für $\forall X\colon\mathrm{set}(X)\cond A(X)$ bzw.
$\exists X\colon\mathrm{set}(X)\land A(X)$ genutzt wird. Man einigt
sich also darauf, dass sich eine Quantifizierung bezüglich einer groß
geschriebenen Variable über alle Klassen erstreckt, wogegen eine bezüglich
einer klein geschriebenen nur über alle Mengen läuft. Ich will mich dieser
Konvention aber im Folgenden nicht anschließen, zumal sie nicht ohne
Weiteres vom Beweisassistenten unterstützt wird. Wir fahren stattdessen
mit den gewohnten Schreibweisen fort.

Die Einermenge $\{x\}$ kommt in den beiden Varianten \code{sg x} und
\code{Sg x}, die für eine Menge $x$ übereinstimmen. Sollte $x$ aber eine
echte Klasse sein, so wird $\mathrm{sg}(x)$ die leere Menge sein, während sich
für $\mathrm{Sg}(x)$ die Allklasse ergibt. Man kann das so verstehen, dass der
eigentliche Definitionsbereich dieser Operation die Allklasse ist. Liegt
die Klasse $x$ nun außerhalb von diesem, ist also eine echte Klasse, muss
man sich überlegen, welchen Wert $\{x\}$ man $x$ zuordnen will, weil eine
jede Operation auf dem gesamten Diskursuniversum definiert ist, das alle
Klassen umfasst. Hier gibt es zwei natürliche Varianten; entweder die
Zuordnung der leeren Menge oder aber die Zuordnung der Allklasse.

Im Weiteren will ich statt $\mathrm{sg}$ von $\mathrm{Sg}$ Gebrauch machen,
da sich dieses ein wenig gutartiger verhält. Zwar sind beide Varianten
auf der Allklasse injektiv. Setzt man aber nur $x$ als Menge voraus,
könen wir aus $\mathrm{sg}(x)=\mathrm{sg}(y)$ nicht mehr $x=y$ folgern,
denn die Gleichung ist auch für $x=\emptyset$ und $y$ eine echte Klasse
erfüllt. Es handelt sich also mehr um eine technische Spielerei, um in
Sachverhalten weniger Voraussetzungen schreiben zu müssen.

\begin{figure}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent, escapechar=`,
label=lst:MK-Definitionen, caption={Begrifflichkeiten der Mengenlehre}]
Parameter Class: Type.
Parameter In: Class -> Class -> Prop.
Parameter Comp: (Class -> Prop) -> Class.
Notation "x `$\in$` A" := (In x A) (at level 70).
Notation "x `$\notin$` A" := (~In x A) (at level 70).
Notation "{ x | P }" := (Comp (fun x: Class => P)).

Definition set x := exists C, x `$\in$` C.
Definition Inclusion A B := forall x, x `$\in$` A -> x `$\in$` B.
Definition EmptySet := {x | False}.
Definition UnivCl := {x | True}.
Definition DiagCl := {x | x `$\notin$` x}.
Notation "`$\emptyset$`" := EmptySet (at level 0).
Notation "A `$\subseteq$` B" := (Inclusion A B) (at level 70).

Definition intersection A B := {x | x `$\in $` A /\ x `$\in$` B}.
Definition union A B := {x | x `$\in$` A \/ x `$\in$` B}.
Definition diff A B := {x | x `$\in$` A /\ x `$\notin$` B}.
Definition Intersection M := {x | forall A, A `$\in$` M -> x `$\in$` A}.
Definition Union M := {x | exists A, A `$\in$` M /\ x `$\in$` A}.
Definition Power M := {A | A `$\subseteq$` M}.
Definition sg x := {y | x = y}.
Definition Sg x := {y | set x -> x = y}.
Definition PairSet x y := union (Sg x) (Sg y).
Definition Pair x y := PairSet (Sg x) (PairSet x y).
Definition Prod X Y := {t |
  exists x y, x `$\in$` X /\ y `$\in$` Y /\ t = Pair x y}.
Notation "A `$\cap$` B" := (intersection A B) (at level 45).
Notation "A `$\cup$` B" := (union A B) (at level 50).
Notation "A \ B" := (diff A B) (at level 50).
Notation "( x , y )" := (Pair x y) (at level 0).
Notation "A `$\times$` B" := (Prod A B) (at level 40).
Notation "`$\bigcap$` M" := (Intersection M) (at level 0, M at level 30).
Notation "`$\bigcup$` M" := (Union M) (at level 0, M at level 30).
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent, escapechar=`,
caption={Begrifflichkeiten im Bezug auf Relationen und Funktionen}]
Definition dom R := {x | exists y, (x, y) `$\in$` R}.
Definition rng R := {y | exists x, (x, y) `$\in$` R}.
Definition img R A := {y | exists x, x `$\in$` A /\ (x, y) `$\in$` R}.
Definition inv_img R B := {x | exists y, y `$\in$` B /\ (x, y) `$\in$` R}.
Definition app f x := `$\bigcap$`{y | (x, y) `$\in$` f}.

Definition relation R :=
  forall t, t `$\in$` R -> exists x y, t = (x, y).

Definition function f := relation f /\
  forall x y y`\ttq`, (x, y) `$\in$` f -> (x, y`\ttq`) `$\in$` f -> y = y`\ttq`.

Definition choice_function f :=
  function f /\ forall x, x `$\in$` dom f -> app f x `$\in$` x.

Definition fn f X Y := function f /\ dom f = X /\ rng f `$\subseteq$` Y.

Definition inj f X Y := fn f X Y /\ forall x x`\ttq`,
  x `$\in$` X -> x`\ttq` `$\in$` X -> app f x = app f x`\ttq` -> x = x`\ttq`.

Definition sur f X Y := fn f X Y /\ rng f = Y.

Definition bij f X Y := inj f X Y /\ sur f X Y.

Definition inv f := {t | exists x y,
  t = (y, x) /\ (x, y) `$\in$` f}.

Definition restr f A := f `$\cap$` (A `$\times$` UnivCl).

Definition composition g f := {t | exists x y z,
  t = (x, z) /\ (x, y) `$\in$` f /\ (y, z) `$\in$` g}.
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Coq, xleftmargin=\mathindent, escapechar=`,
label=lst:MK-Axiome, caption={Axiome der Mengenlehre}]
Axiom lem: forall (A: Prop),
  A \/ ~A.

Axiom ext: forall (A B: Class),
  (forall x, x `$\in$` A <-> x `$\in$` B) -> A = B.

Axiom comp: forall (P: Class -> Prop),
  forall u, u `$\in$` {x | P x} <-> set u /\ P u.

Axiom pairing: forall {x y: Class},
  set x -> set y -> set (PairSet x y).

Axiom subset: forall {A B: Class},
  A `$\subseteq$` B -> set B -> set A.

Axiom power: forall {M: Class},
  set M -> set (Power M).

Axiom unions: forall {M: Class},
  set M -> set (`$\bigcup\,$`M).

Axiom regularity: forall (A: Class),
  ~(A = `$\emptyset$`) -> exists x, x `$\in$` A /\ x `$\cap$` A = `$\emptyset$`.

Axiom infinity: exists (A: Class),
  `$\emptyset$` `$\in$` A /\ forall x, x `$\in$` A -> x `$\cup$` (Sg x) `$\in$` A.

Axiom substitution: forall (f: Class),
  function f -> set (dom f) -> set (rng f).

Axiom choice: exists (f: Class),
  choice_function f /\ dom f = UnivCl \ (Sg `$\emptyset$`).
\end{lstlisting}
\end{figure}
