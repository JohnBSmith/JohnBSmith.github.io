
sub partition(n,k)
  if n<k
    return 0
  elif k==1 or n==k
    return 1
  else
    m = partition.m
    t = [n,k]
    if t in m
      return m[t]
    else
      m[t]=partition(n-1,k-1)+partition(n-k,k)
      return m[t]
    end
  end
end
partition.m={}

# partition function
sub pf(*argv)
  if size(argv)==2
    return partition(argv[0],argv[1])
  else
    n=argv[0]
    return (1..n).sum(|k| partition(n,k))
  end
end

sub partitions(n,k,max)
  if n==0
    return [[]]
  elif n>k*max
    return []
  elif n==k*max
    return [[max]*k]
  elif k==1
    return [[n]]
  else
    a=[]
    for x in 1..min(max,n-1)
      for t in partitions(n-x,k-1,x)
        a.push(t+[x])
      end
    end
    return a
  end
end

sub p(n,k)
  partitions(n,k,n)
end

sub u(n)
  all=true
  for i in 1..n
    t = [pf(n,i),size(p(n,i))]
    if t[0]!=t[1]
      all=false
    end
    print(t)
  end
  print(all)
end

sub triplets(n)
  a=[]
  for x,y,z in partitions(n,3,n)
    if x^2+y^2==z^2
      a.push([x,y,z])
    end
  end
  return a
end

triplets(1000).each(print)

