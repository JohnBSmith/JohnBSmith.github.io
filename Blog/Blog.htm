<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Blog</title>
  <link href="blog.css" rel="stylesheet">
</head>
<body>
<div id="content">
<header id="header">
<h1>Blog</h1>
<a href="../de.htm">Home</a><a href="../Rest/Portal.htm">Portal</a>
</header>

<div id="main-aside">
<main id="main">
<h2>Inhaltsverzeichnis</h2>
<ol>
<li><span class="date">[2015-01-16]</span>
  <a href="#Ueberweisungen">Grusel vor Überweisungsbetrug</a>
<li><span class="date">[2015-08-19]</span>
  <a href="#rm">Remove</a>
<li><span class="date">[2015-12-12]</span>
  <a href="#Passwoerter">Kryptische Passwörter</a>
</ol>

<h2 id="Ueberweisungen">Grusel vor Überweisungsbetrug</h2>
<div class="date">16. Januar 2015</div>

<p>Das Verfahren zur Kontrolle bei der Überweisung von Geld ist
m.E. nicht mehr ernst zu nehmen. Das Fälschen von
Überweisungsträgern ist äußerst leicht, was wohl darauf
zurückzuführen ist, dass das Verfahren noch aus Zeiten stammt
wo Bankangestellte den Kunden persönlich kannten.
Seltsamerweise wird bei der Abgabe des Trägers nicht einmal ein
Personalausweis verlangt. Je einfacher es nun ist, bei einem fremden
Kreditinstitut ein anonymes Konto zu eröffnen, desto unsicherer wird
die Situation für alle anderen. Ein fremdes Kreditinstitut, sei es
nun im Inland oder im Ausland, sollte jedoch niemals über die
Sicherheit aller Unbeteiligten bestimmen können. Wenn man nicht
ständig pedantisch sämtliche Kontoauszüge überprüft, könnten einem
schnell große Summen Geld verloren gehen.
</p>


<p>Die einfachste Lösung wäre die Verwendung einer
Einmal-Passwort-Liste, ähnlich wie beim TAN-Verfahren. Man muss nur
den Passwort-Zettel an einem sicheren Ort aufbewahren. Je Überweisung
wird dann ein Passwort von der Liste gestrichen und auf den Träger
geschrieben. Die Passwörter müssen nicht besonders lang sein.
Sinnvoll sind m.E. acht Hexadezimal-Ziffern, gruppiert
in zwei Blöcken zu je vier Ziffern. Wenn das problematisch für OCR
ist, kann man alternativ wohl auch acht Dezimal-Ziffern verwenden.
</p>

<p>Falls man einen Wohnungseinbruch meldet,
so wird die Einmal-Passwort-Liste gleich ungültig,
und man lässt sich eine neue ausstellen.
</p>

<p>Zusätzlich kann man optional verlangen, dass Träger nur mit
Personalausweis abgegeben werden dürfen. Der Träger wird bei der
Abgabe mit Ausweis vom Bankangestellten entsprechend markiert.
Verlangt man für sein Konto eine Abgabe mit Ausweis, so wird ein
Träger ohne Markierung zurückgewiesen. Markierte Träger aus dem
Briefkasten müssen natürlich auch zurückgewiesen werden. Dieses
Verfahren ist mir aber zu umständlich und fehleranfällig,
denn Ausweise sind leichter fälschbar als TAN-Listen. Wer schaut
sich einen Ausweis denn so genau an? Dafür braucht man wieder OCR
und eine Datenbank, was ich nicht so toll finde.</p>

<p>Die Überprüfung von Unterschriften ist dagegen, wie ich finde,
nicht mehr Zeitgemäß. Zusätzlich kann man es ja machen, aber als
Hauptsicherheitsmerkmal ist es unzulänglich. Es kann doch nicht sein,
dass die Authentizität der Träger heute noch mit Methoden aus dem
letzten Jahrhundert festgestellt wird.
</p>


<h2 id="rm">Remove</h2>
<div class="date">19. August 2015</div>
<p>Vor einiger Zeit habe ich mal mein Betriebssystem irreparabel
geschädigt, so dass ich es neu aufsetzen musste. Ich will kurz
berichten wie es dazu kam.
</p>

<p>Also ich besitze so einen USB-Stick bei dem ein paar Dateien
nicht mehr gelöscht werden können. Dessen ungeachtet funktioniert
er aber noch tadellos. Ich wollte die Dateien nun unbedingt
entfernen, weil der Mülleimer immer gefüllt wurde, wenn ich den Stick
mountete. Ich habe gedacht, man kann ihn irgendwie formatieren und
unterschiedliche Dinge ausprobiert.
</p>

<p>Nun kam ich mehr oder weniger verzweifelt auf die Idee mal
<code>rm</code> zu benutzen. Die Sache ist aber so: Das Verzeichnis
mit den Dateien hieß <code>bin</code>. Ich habe nun zwei fatale
Fehler gleichzeitig gemacht. Erstens habe ich aus Versehen
<code>rm -r /bin</code> anstelle von <code>rm -r bin</code>
oder <code>rm -r ./bin</code> geschrieben. Zweitens, als das
abgewürgt wurde, habe ich <code>rm</code> unachtsam mit
root-user-Rechten ausgeführt. Interessanterweise ist das System
danach nicht sofort abgestürzt. Man konnte aber nicht mehr viel
machen. Wenigstens konnte ich <code>rm</code> danach nicht mehr
benutzen und noch mehr schaden anrichten.
</p>


<h2 id="Passwoerter">Kryptische Passwörter</h2>
<div class="date">12. Dezember 2015</div>

<p>Ich las gerade einen Zeitungsartikel über Passwörter. Dort wurden
einem wie üblich Tipps genannt, um sich solche sicher zu erstellen.
Die Darstellung war simplifiziert und hob unwesentliche Dinge hervor.
Es wurde dann empfohlen, mindestens 12 Zeichen mit
Zufallskombinationen zu verwenden. Aber was soll das
<i>mindestens</i>? Warum nicht einfach
eine exakte Zahl von Zeichen? Viele Dienste wollen dann auch noch
unbedingt Sonderzeichen und große Buchstaben, andernfalls wird
das Passwort abgewiesen. Das ist natürlich ein ziemlicher Bullshit.
Ich will erklären warum.
</p>

<p>Gehen wir zunächst einmal von dem aus, was sicher ist. Man kann
durch theoretische Überlegungen leicht feststellen, dass ein
128bit-Passwort sicher ist. Falls Quantencomputer verwendet werden,
so soll man nach Meinung von Forschern die Passwortlänge verdoppeln,
also ein 256bit-Passwort verwenden.
</p>


<p>Nun kann man so ein Passwort zu einer bestimmten Basis
darstellen, wenn man es als Zahl im Stellenwertsystem auffasst.
Die Basis <code>B</code> ist dabei eine geordnete Menge von Ziffern.
Die Länge der Basis, d.h die Anzahl der Ziffern, bezeichnen wir
mit <code>b</code>. Im Dezimalsystem hat man folgende Basis.
</p>

<pre>
  B = {0,1,2,3,4,5,6,7,8,9}
  b = |B| = 10
</pre>


<p>Eigentlich ist ein Passwort keine Zahl, sondern nur
ein Symbolwort. Man nennt die Basis dann
Symbolalphabet. Aber das sind abstraktere
Begriffe, die nur für Informatiker verständlich sind. Die
nötige Passwortlänge wollen wir nun mit <code>L</code> bezeichnen,
präziser mit <code>L(b)</code>, da es sich um eine von <code>b</code>
abhängige Funktion handelt.
</p>

<p>Für eine einzelne Ziffer gibt es nun <code>b</code> Möglichkeiten,
für zwei sind es <code>b*b</code> und für <code>L</code> Ziffern sind
es <code>b^L</code>. Die Zahl</p>
<pre>
  S = b^L
</pre>
<p>bezeichnet man als Schlüsselraumgröße.
Ein bit hat zwei Möglichkeiten. Dann hat ein
128bit Passwort also <code>2^128</code> Möglichkeiten.
Damit erhält man die Gleichung
</p>
<pre>
  b^L = 2^128.
</pre>
<p>Logarithmieren auf beiden Seiten und Umformung bringt
<pre>
  L = 128 lg(2)/lg(b).
</pre>
<p>Zur Sicherheit wollen wir Aufrunden. Somit erhält man
für die notwendige Passwortlänge die Formel
</p>
<pre>
  L = ceil(128 lg(2)/lg(b)).
</pre>
<p>Hier sind nun einige Basen bzw. Alphabete wie sie praktisch
verwendet werden.
</p>
<table class="bt">
<tr><th>b<th>Basis
<tr><td>10<td>dezimale Ziffern
<tr><td>16<td>hexadezimale Ziffern
<tr><td>26<td>kleine Buchstaben
<tr><td>36<td>Buchstaben und Ziffern
<tr><td>62<td>kleine und große Buchstaben sowie Ziffern
<tr><td>90<td>druckbare ASCII-Zeichen
</table>

<p>Nun eine Tabelle mit der notwendigen Passwortlänge.
</p>
<pre>
b   | L
002 | 128
003 | 081
004 | 064
006 | 050
010 | 039
016 | 032
026 | 028
036 | 025
062 | 022
090 | 020
100 | 020
128 | 019
256 | 016
999 | 013
</pre>
<p>Man sieht, dass die notwendige Passwortlänge erst schnell und
dann immer langsamer abnimmt. Nur um fünf Zeichen zu sparen muss
man aber nicht große Buchstaben und Sonderzeichen verwenden.
Selbst wenn man 1000 Hanzi verwenden würde, wäre die Passwortlänge
immer noch 13 Zeichen.
</p>

<p>Es ist nun am sichersten (exakt gleichverteilte) zufällige Zeichen
zu benutzen. Diese ordnet man zur Lesbarkeit in Vierergruppen
an. Bei 24 kleinen Buchstaben und Ziffern sind das sechs Gruppen.
Ein Passwort sieht dann z.B. so aus:
</p>

<pre>
  k4ma 2kwq wmco piht ujx8 r37g
</pre>

<p>Leerzeichen sollten vom Eingabeparser
entfernt werden. Ich finde es sehr fehleranfällig, wenn
Eingabeparser so etwas nicht machen. 
</p>

<p>Das mit den nicht notwendigen Sonderzeichen lässt sich auch
so veranschaulichen: wenn man zwei hexadezimale Ziffern zu einem
Symbol zusammenfasst, hat man schon <code>b=256</code>.
Anstelle noch so kryptische Zeichen zu verwenden, kann man also auch
einfach die Passwortlänge verdoppeln und dabei nur hexadezimale
Ziffern benutzen.
</p>

<p>Für einen Account bei einem Server sollten sich <code>2^128</code>
Schlüssel aber nicht Brute-Force durchprobieren lassen. So etwas
wäre ja höchst auffällig. Nehmen wir mal an, jemand loggt sich
maximal 100 mal am Tag ein und der Account besteht maximal
für 100 Jahre. Dann ist die maximale Anzahl der Versuche
100*365*100. Man will nun eine Wahrscheinlichkeit von eins
zu einer Mio., dass jemand hierbei Zufällig den richtigen
Schlüssel findet. Man benötigt daher einen Schlüsselraum von
</p>
<pre>
  100*356*100*10^6 = 3.65*10^12
  = 1.66*2^41.
</pre>

<p>Bei <code>2^42</code> ergibt sich ein Passwort von
neun Buchstaben und Ziffern. Zur Sicherheit kann man 12 verwenden.
Ein Passwort wie
</p>
<pre>
  k4ma 2kwq wmco
</pre>
<p>sollte also ausreichend sicher sein. Ein Problem welches
sich jetzt ergibt, ist, dass von Passwörtern nur gesalzene
Hashwerte gespeichert werden sollten. Es kann möglich sein,
dass dabei zwei unterschiedliche Passwörter zur gleichen Hashwerte
führen. Bei SHA-256-Hashwerte ist so etwas aber fast
ausgeschlossen.
</p>
<p>Und damit ist nun klar, dass man weder Sonderzeichen
noch Großbuchstaben verwenden muss. Verängstigte können
die Passwortlänge einfach von 12 auf 16 erhöhen,
das bringt mehr als noch so kryptische Sonderzeichen.
Warum? Weil <code>36^16</code> größer ist als <code>90^12</code>.
</p>
<p>Um es mathematisch zu präzisieren: Wächst die Basis, so
ergibt sich für die Schlüsselraumgröße die Potenzfunktion
<code>S(x)=x^L</code>. Wächst jedoch die Schlüssellänge, so ergibt
sich für die Schlüsselraumgröße die Exponentialfunktion
<code>S(x)=b^x</code>. Exponentialfunktionen wachsen aber
viel schneller als Potenzfunktionen.
</p>

</main>

<aside id="right-aside">
</aside>
</div>

</div>

</body>
</html>


