<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Blog</title>
  <link href="blog.css" rel="stylesheet">
</head>
<body>

<div id="content">
<header id="header">
<h1>Blog</h1>
<a href="../de.htm">Home</a><!--
--><a href="../Rest/Portal.htm">Portal</a>
</header>

<div id="main-aside">
<main id="main">

<h2>Inhaltsverzeichnis</h2>
<ul>
<li><span class="date">[2015-12-12]</span>
  <a href="#Passwoerter">Kryptische Passwörter</a>
<li><span class="date">[2017-02-22]</span>
  <a href="#Index">Index clientseitig durchsuchen</a>
<li><span class="date">[2017-03-19]</span>
  <a href="#Midi">Probleme mit Midi auf Linux</a>
<li><span class="date">[2017-05-09]</span>
  <a href="#Int">Ganzzahldatentypen</a>
</ul>

<h2 id="Passwoerter">Kryptische Passwörter</h2>
<div class="date">12. Dezember 2015</div>

<p>Ich las gerade einen Zeitungsartikel über Passwörter. Dort wurden
einem wie üblich Tipps genannt, um sich solche sicher zu erstellen.
Die Darstellung war simplifiziert und hob unwesentliche Dinge hervor.
Es wurde dann empfohlen, mindestens 12 Zeichen mit
Zufallskombinationen zu verwenden. Aber was soll das
<em>mindestens</em>? Warum nicht einfach
eine exakte Zahl von Zeichen? Viele Dienste wollen dann auch noch
unbedingt Sonderzeichen und große Buchstaben, andernfalls wird
das Passwort abgewiesen. Das ist natürlich ein ziemlicher Bullshit.
Ich will erklären warum.

<p>Gehen wir zunächst einmal von dem aus, was sicher ist. Man kann
durch theoretische Überlegungen leicht feststellen, dass ein
128bit-Passwort sicher ist. Falls Quantencomputer verwendet werden,
so soll man nach Meinung von Forschern die Passwortlänge verdoppeln,
also ein 256bit-Passwort verwenden.

<p>Nun kann man so ein Passwort zu einer bestimmten Basis
darstellen, wenn man es als Zahl im Stellenwertsystem auffasst.
Die Basis <code>B</code> ist dabei eine geordnete Menge von Ziffern.
Die Länge der Basis, d.&nbsp;h. die Anzahl der Ziffern, bezeichnen wir
mit <code>b</code>. Im Dezimalsystem hat man folgende Basis:

<pre>
  B = {0,1,2,3,4,5,6,7,8,9}
  b = |B| = 10
</pre>


<p>Eigentlich ist ein Passwort keine Zahl, sondern nur
ein Symbolwort. Man nennt die Basis dann
Symbolalphabet. Aber das sind abstraktere
Begriffe, die nur für Informatiker verständlich sind. Die
nötige Passwortlänge wollen wir nun mit <code>L</code> bezeichnen,
präziser mit <code>L(b)</code>, da es sich um eine von <code>b</code>
abhängige Funktion handelt.

<p>Für eine einzelne Ziffer gibt es nun <code>b</code> Möglichkeiten,
für zwei sind es <code>b*b</code> und für <code>L</code> Ziffern sind
es <code>b^L</code>. Die Zahl
<pre>
  S = b^L
</pre>
<p>bezeichnet man als Schlüsselraumgröße.
Ein bit hat zwei Möglichkeiten. Dann hat ein
128bit Passwort also <code>2^128</code> Möglichkeiten.
Damit erhält man die Gleichung
<pre>
  b^L = 2^128.
</pre>
<p>Logarithmieren auf beiden Seiten und Umformung bringt
<pre>
  L = 128 lg(2)/lg(b).
</pre>
<p>Zur Sicherheit wollen wir Aufrunden. Somit erhält man
für die notwendige Passwortlänge die Formel
<pre>
  L = ceil(128 lg(2)/lg(b)).
</pre>
<p>Hier sind nun einige Basen bzw. Alphabete wie sie praktisch
verwendet werden.
<table class="bt">
<tr><th>b<th>Basis
<tr><td>10<td>dezimale Ziffern
<tr><td>16<td>hexadezimale Ziffern
<tr><td>26<td>kleine Buchstaben
<tr><td>36<td>Buchstaben und Ziffern
<tr><td>62<td>kleine und große Buchstaben sowie Ziffern
<tr><td>90<td>druckbare ASCII-Zeichen
</table>

<p>Nun eine Tabelle mit der notwendigen Passwortlänge:
<pre>
    b |   L
    2 | 128
    3 |  81
    4 |  64
    6 |  50
   10 |  39
   16 |  32
   26 |  28
   36 |  25
   62 |  22
   90 |  20
  100 |  20
  128 |  19
  256 |  16
  999 |  13
</pre>
<p>Man sieht, dass die notwendige Passwortlänge erst schnell und
dann immer langsamer abnimmt. Nur um fünf Zeichen zu sparen, muss
man aber nicht große Buchstaben und Sonderzeichen verwenden.
Selbst wenn man 1000 Hanzi verwenden würde, wäre die Passwortlänge
immer noch 13 Zeichen.

<p>Es ist nun am sichersten, (exakt gleichverteilte) zufällige Zeichen
zu benutzen. Diese ordnet man zur Lesbarkeit in Vierergruppen
an. Bei 24 kleinen Buchstaben und Ziffern sind das sechs Gruppen.
Ein Passwort sieht dann z.&nbsp;B. so aus:

<pre>
  b4ma 2kwq wmco piht ujx8 r37g
</pre>

<p>Leerzeichen sollten vom Eingabeparser
entfernt werden. Ich finde es sehr fehleranfällig, wenn
Eingabeparser so etwas nicht machen. 

<p>Das mit den nicht notwendigen Sonderzeichen lässt sich auch
so veranschaulichen: wenn man zwei hexadezimale Ziffern zu einem
Symbol zusammenfasst, hat man schon <code>b=256</code>.
Anstelle noch so kryptische Zeichen zu verwenden, kann man also auch
einfach die Passwortlänge verdoppeln und dabei nur hexadezimale
Ziffern benutzen.

<p>Für einen Account bei einem Server sollten sich <code>2^128</code>
Schlüssel aber nicht Brute-Force durchprobieren lassen. So etwas
wäre ja höchst auffällig. Nehmen wir mal an, jemand loggt sich
maximal 100 mal am Tag ein und der Account besteht maximal
für 100 Jahre. Dann ist die maximale Anzahl der Versuche
100*365*100. Man will nun eine Wahrscheinlichkeit von eins
zu einer Mio., dass jemand hierbei Zufällig den richtigen
Schlüssel findet. Man benötigt daher einen Schlüsselraum von
<pre>
  100*356*100*10^6 = 3.65*10^12
  = 1.66*2^41.
</pre>

<p>Bei <code>2^42</code> ergibt sich ein Passwort von
neun Buchstaben und Ziffern. Zur Sicherheit kann man 12 verwenden.
Ein Passwort wie
<pre>
  b4ma 2kwq wmco
</pre>
<p>sollte also ausreichend sicher sein. Ein Problem welches
sich jetzt ergibt, ist, dass von Passwörtern nur gesalzene
Hashwerte gespeichert werden sollten. Es kann möglich sein,
dass dabei zwei unterschiedliche Passwörter zum gleichen Hashwert
führen. Bei SHA-256-Hashwerten ist so etwas aber fast
ausgeschlossen.

<p>Und damit ist nun klar, dass man weder Sonderzeichen
noch Großbuchstaben verwenden muss. Verängstigte können
die Passwortlänge einfach von 12 auf 16 erhöhen,
das bringt mehr als noch so kryptische Sonderzeichen.
Warum? Weil <code>36^16</code> größer ist als <code>90^12</code>.

<p>Um es mathematisch zu präzisieren: Wächst die Basis, so
ergibt sich für die Schlüsselraumgröße die Potenzfunktion
<code>S(x)=x^L</code>. Wächst jedoch die Schlüssellänge, so ergibt
sich für die Schlüsselraumgröße die Exponentialfunktion
<code>S(x)=b^x</code>. Exponentialfunktionen wachsen aber
wesentlich schneller als Potenzfunktionen.

<h2 id="Index">Index clientseitig durchsuchen</h2>
<div class="date">22. Februar 2017</div>

<p>Interessanterweise lässt sich unter Verwendung von clientseitigem
Javascript auch ein Index auf einem Server durchsuchen.
Das Problem ist zunächst, dass der Index irgendwann größer wird als
ca. vier MB. Als Lösung wird der Index nun jedoch als Baumstruktur
gespeichert, wobei die Knoten der ersten Ebenen in unterschiedlichen
Dateien stehen. Über <code>XMLHttpRequest</code> lassen sich die
Dateien dann per Lazy Evaluation lesen. Angenommen man hat einen
1&nbsp;GB großen Suchbaum. Bei zwei Ebenen mit je 26 Buchstaben lässt
sich der Index dann auf 1,5&nbsp;MB große Dateien verteilen.

<p>Ein weiteres Problem, welches sich dabei ergibt, ist nun aber
die Suche von Teilzeichenketten im Index. Dazu müsste der gesamte
Index geladen und durchsucht werden. Man könnte nun auf die Idee
kommen, aus dem Index einen Meta-Index zu erzeugen. Aber die
Teilzeichenketten sind im Normalfall über den gesamten Index verteilt,
sodass man doch wieder alle Dateien laden müsste.

<p>Stattdessen ist es vorteilhaft, gleich einen Index zu erzeugen,
der auch die Teilzeichenketten umfasst. Dieser wird dann wohl
etwas größer werden. Aber das ist nicht so schlimm, auch wenn der Index
so groß werden würde wie der gesamte Text der Website. Solange beim
Auswerten des Suchbaumes nur zwei bis drei kleine Dateien geladen
werden müssen, ist das kein Nachteil. Man beachte, dass das
Text-Daten sind, das ist eigentlich sehr wenig Festplattenplatz.

<p>Ich hätte gerne eine Volltextsuche für
<a href="https://de.wikipedia.org/wiki/Project_Gutenberg"
>Project Gutenberg</a>. Die Website verwendet seit einiger Zeit
schon TLS. Man muss aber einen https-Link verwenden.

<h2 id="Midi">Probleme mit Midi auf Linux</h2>
<div class="date">19. März 2017</div>
<p>Zurzeit gibt es noch einige Probleme mit Midi auf Linux
(Ubuntu 16.04 LTS). Linthesia in Version <code>0.4.3</code>
funktionierte, stürzte aber nach einiger Zeit ab. Nach Software-Updates
scheint es jetzt in (immer noch Version <code>0.4.3</code>) nicht mehr
abzustürzen, aber man hört nichts mehr, weil TiMidity irgendwie nicht
richtig angesprochen wird. TiMidity selbst funktioniert, jedoch war es
mir nicht möglich, alternative Soundfonts zu installieren.

<p>Musescore hat auch mal gesponnen, sodass man nichts hörte.
Es scheint jetzt aber wieder korrekt zu funktionieren. Das Verhalten
kann sich nach Software-Updates ja verändern, und ich verfolge nicht
alle Software-Updates. Musescore wandelt Midi in einigen Fällen
sogar in einigermaßen korrekte Partituren um und scheint sogar
Auftakte und Tonarten erkennen zu können.

<p>Das <code>fluidsynth</code>-Plugin für den VLC funktioniert,
das ist schön. Wenn man eine Midi-Datei im Firefox anklickt, dann
öffnet sich VLC und spielt die ab. Die Zukunftsvorstellung ist dabei
jetzt natürlich, dass sich gleich Linthesia öffnen könnte.
Jedenfalls braucht jemand in Zukunft nicht mehr unbedingt Noten
schreiben. Es geht wesentlich schneller, mit einem Keyboard eine
Midi-Datei aufzunehmen und die dann mit Linthesia abspielen zu lassen.

<h2 id="Int">Ganzzahldatentypen</h2>
<div class="date">9. Mai 2017</div>
<p>Wart ihr euch schon einmal unsicher, welchen der vielen
Ganzzahldatentypen ihr in C benutzen sollt? Meines Erachtens
können die eingebauten Datentypen von einem Compiler sinnvollerweise
so definiert werden:
<pre>
  unsigned char  == uint_fast8_t
  unsigned short == uint_fast16_t
  unsigned int   == uint_fast16_t
  unsigned long  == uint_fast32_t
</pre>
<p>Prinzipiell könnte ein Compiler auch so konfiguriert werden,
dass er möglichst viel Speicher spart (meistens nicht sinnvoll).
Zum Beispiel könnte man auch auf solches stoßen:
<pre>
  unsigned char  == uint_least8_t
  unsigned short == uint_least16_t
  unsigned int   == uint_fast16_t
  unsigned long  == uint_least32_t
</pre>
<p>Angenommen man will nun eine UTF-8- oder eine UTF-32-Zeichenkette
speichern. Man könnte jetzt auf die Idee kommen, dafür ein Feld von
<code>uint8_t</code> bzw. <code>uint32_t</code> zu verwenden.
Es kann aber auf seltenen Architekturen der Fall sein, dass das nicht
sinnvoll oder nicht möglich ist. Vielmehr möchte man für diesen Zweck
eigentlich <code>uint_least8_t</code> bzw. <code>uint_least32_t</code>
verwenden.

<p>Die Dinge fangen nun an kompliziert zu werden, wenn man ein
<code>uint32_t</code> als Feld von vier <code>uint8_t</code>
betrachten möchte:
<pre>
  uint32_t x = 0xcafebabe;
  uint8_t* p = (uint8_t*)&amp;x;
  printf("%02x %02x %02x %02x\n",p[3],p[2],p[1],p[0]);
</pre>
<p>Möchte man Daten aus einer Datei lesen oder in eine Datei
schreiben, so kommt dabei aber <code>uint8_t*</code> nicht vor.
Vielmehr stößt man auf <code>char*</code>, welcher zunächst in
<code>unsigned char*</code> umgecastet werden sollte. Es muss
jedoch nicht unbedingt <code>sizeof uint8_t == sizeof unsigned char</code>
sein. Das ist problematisch, wenn man z.&nbsp;B. eine
<code>uint_least32_t</code>-Zahl aus einer Datei auslesen möchte.
Die Zahl ist über ein Feld von vier <code>unsigned char</code>
verteilt. Der naive Ansatz wäre folgender:
<pre>
  unsigned char* Daten;
  uint8_t* pu8 = (unsigned char*)Daten; // Aua! (1)
  unsigned long x = *(uint32_t*)(pu8+POSITION);
</pre>
<p>Nicht weniger naiv ist folgender Ansatz:
<pre>
  unsigned char* Daten;
  unsigned char* p = Daten+POSITION;
  unsigned long x;
  x = *(unsigned long*)p; // Aua! (2)
  x = *(uint32_t*)p; // Aua! (3)
</pre>
<p>Wenn z.&nbsp;B. <code>sizeof unsinged char == sizeof unsigned
long</code> ist, dann geht alles schief. Das Feld schaut dann
folgendermaßen aus:
<pre>
  B X X X B X X X B X X X B X X X ...
  ^       ^       ^       ^
  p[0]    p[1]    p[2]    p[3]
</pre>
<p>wobei die <code>B</code> die Bytes der Zahl sind und <code>X</code>
beliebiger Datenmüll ist. Schauen wir uns an, was mit <code>pu8</code>
passiert:
<pre>
  B == pu8[0]
  X == pu8[1]
  X == pu8[2]
  X == pu8[3]
  B == pu8[4]
  X == pu8[5]
  usw.
</pre>
<p>Bei (3) schaut es so aus:
<pre>
  B X X X == *(uint32_t*)(p+POSITION)
</pre>

<p>Bei (2) nehmen wir an, dass <code>unsigned long == uint64_t</code>
gilt:
<pre>
  B X X X B X X X == *(unsigned long*)(p+POSITION)
</pre>
<p>Der Ausdruck (2) ist ausgesprochen schlimm, denn selbst
wenn <code>unsigned char</code> einem Byte entspräche, wäre
<pre>
  B B B B X X X X == *(unsigned long*)(p+POSITION)
</pre>
wo Datenmüll <code>XXXX</code> im Datum liegt. Das Problem ist hier,
dass das nicht portabel ist und Leute es eventuell erst bemerken,
wenn das Programm nach dem Portieren von <code>ILP32</code> auf
<code>LP64</code> an irgendeiner Stelle abstürzt oder sinnlose
Ergebnisse liefert.

<p>Dass alles nicht schon genug ist, ergibt sich außerdem noch
das Problem, dass die Daten in der Datei im Little-Endian-Format
gespeichert sind, die Computer-Architektur aber die
Big-Endian-Konvention verwenden könnte.

<p>Eine portable Lösung schaut wie folgt aus:
<pre>
  unsigned char* Daten;
  unsinged char* p = Daten+POSITION;
  unsigned long x;
  x = ((unsigned long)p[3] &amp; 0xff)&lt;&lt;24
    | ((unsigned long)p[2] &amp; 0xff)&lt;&lt;16
    | ((unsigned long)p[1] &amp; 0xff)&lt;&lt; 8
    | ((unsigned long)p[0] &amp; 0xff);
</pre>
<p>Zur Optimierung verwendet man ein Makro oder eine Inline-Funktion.
Die high-end-Compiler <code>gcc</code> und <code>clang</code>
beherrschen natürlich das Inlinen von Funktionen. Für billige
Compiler ist ein Makro aber besser.

<p>Falls <code>unsigned char</code>
mit <code>uint8_t</code> koinzidiert, kann <code>&amp; 0xff</code>
entfallen. Das ist eine ganz banale Optimierung. Wenn ein Compiler
das nicht wegoptimiert, solltet ihr den Compiler besser in den
Mülleimer werfen. Man darf diese Optimierung auch für
Embedded-Compiler erwarten, weil dort die Verwendung von
Bitarithmetik maßgeblich ist.

<p>Die Programmiersprache&nbsp;C kann als Mischung aus Hochsprache
und Assembler betrachtet werden. Programmierung in&nbsp;C sollte
zu Gunsten von typsicheren Programmiersprachen möglichst vermieden
werden. Als nächstes wird man sich also fragen, wie das Lesen von
Daten in den effizienten Programmiersprachen Ada, D, Rust und OCaml
ermöglicht wird.
</main>

<aside id="right-aside">
</aside>
</div>

</div>

</body>
</html>
